# vue面试题

## vue响应式原理

### vue2 响应式原理

- Object.defineProperty()来进行数据劫持，针对对象特定属性通过设置getter和setter方法来劫持数据，当读取属性时会触发 getter函数；当view视图层发生变化时，会触发Object.defineProperty()中的setter方法。

### vue3 响应式原理

- Proxy 是针对object类型数据的所有属性都添加get和set方法进行监听，在实现嵌套数据时，更简单，原生支持数组类的监听。

## vue 生命周期

- onErrorCapture 捕获后代组件传递的错误时调用。
- onActivated 激活时(适用于 keep-alive 缓存的组件)
- onDeactivated 解散时调用(适用于 keep-alive 缓存的组件)

## 父子组件生命周期执行顺序

- 父组件 beforeCreated
- 父组件 created
- 父组件 beforeMounted
- 子组件 beforeCreated
- 子组件 created
- 子组件 beforeMounted
- 子组件 mounted
- 父组件 mounted

### 当父组件引入了mixin之后

- mixin beforeCreated
- 父组件 beforeCreated
- mixin created
- 父组件 created
- mixin beforeMounted
- 父组件 beforeMounted
- 子组件 beforeCreated
- 子组件 created
- 子组件 beforeMounted
- 子组件 mounted
- mixin mounted
- 父组件 mounted

## 导航守卫

- 全局守卫
  - beforeEach
  - beforeResolve
  - afterEach
- 路由守卫
  - beforeEnter
- 组件守卫
  - beforeRouteEnter
  - beforeRouteUpdate
  - beforeRouteLeave

- router.beforeEach(to,from,next) 全局前置守卫，路由跳转前触发
- router.beforeResolve() 全局解析守卫，在所有组件内守卫和异步组件被解析后触发
- router.afterEach() 路由跳转完成后触发
- beforeEnter 路由独享守卫

- 参数
  - to 即将要进入的目标路由对象
  - from 即将要离开的路由对象
  - next 是否可以进入某个具体路由，或者是某个具体路由的路径

## 从A页面跳转B页面时的生命周期

- A: beforeRouteLeave (组件守卫)
- beforeEach （全局守卫）
- beforeEnter （路由独享守卫）
- beforeRouteEnter （组件守卫）
- beforeResolve （全局解析守卫）
- afterEach （全局守卫）
- B: beforeCreate
- B: created
- B: beforeMount
- A: beforeDestroy
- A: destroyed
- B: mounted

## vue的传值方式

- $emit
- 路由传参
  - query传参(地址栏显示参数)
    - name和path都能用
    - 地址栏会显示参数
  - params传参(地址栏不显示参数)
    - 跳转只能用name ，不能用path
    - 地址栏不显示参数
- vuex
- localStore
- provide/inject
- $ref
  - this.$refs.children 、 this.$refs.parents

## 路由的两种模式

- hash 模式
- history 模式
- abstract 模式（用来在不支持浏览器API的环境中，充当fallback）

## vue的history和hash的实现原理

- hash是通过 `window.onHashChange()` 事件去监听的
- history 是通过 `window.history.pushState(null,null,path)`（新增历史记录）、`window.history.replaceState(null,null,path)` （替换历史记录）在不进行刷新的情况下，操作浏览器的历史记录

## vue优化方式

1. 减少v-if的活用v-show
2. v-for遍历添加key属性
3. 将组件进行切割(vue的更新是组件粒度的，将耗时任务单独拆分成一组件，父组件数据变化时只会重新渲染父组件，耗时组件并不会渲染，这样性能会更好)
4. 使用keep-alive缓存组件
5. 区分computed和watch
6. 图片资源懒加载
7. 动态加载组件，异步加载组件
8. 使用防抖和节流

## keep-alive 原理

- 通过缓存vnode实现，在渲染的时候对比组件的name（通过include和 exclude控制），命中缓存时就从缓存中读取。
- 问题： 使用keep-alive 的时候数据传递过去不会更新
- 会触发 activated deactivated
- 内存超限时通过LRU算法来管理

## nextTick 原理

- 在修改数据时，会开启一个异步队列，将watcher的update 更新操作缓存在同一事件循环中，同一个watcher只会被推入队列一次（通过watcherId去重），然后再下一事件循环中刷新队列，执行代码，这样做能减少频繁不必要的更新，提升更新渲染效率。
- 原理： nextTick 内部通过一系列异步api尝试将回调函数放在异步队列里， 包括 promise、mutationObserver、setImmediate、setTimeout。
- 所有的回调方法都会放在callbacks数组里，最后通过flushCallbacks 方法遍历 callbacks数组来依次执行回调。
- vue的dom更新是异步的，本身也是使用的 nextTick。

### nextTick 使用场景

- 获取数据更新后的dom
- 在created中进行dom操作
- 获取元素的宽高

## vue 模板编译过程

- 将模板编译为抽象语法树 AST(多叉树)，将AST转化为渲染函数，执行渲染函数生成VDOM,将VDOM映射为真实DOM。

## Vue.extend()

- 用于拓展组件生成一个构造器，通过new构造函数生成一个新的组件实例，类似组件继承。（在vue3.0里废弃了）。

## Vue.use()

- 实际调用了该插件的install方法，当引入的插件有install时需要调用。

## Suspense 组件

- 作用： 可以在组件树上层等待下层的多个嵌套异步依赖项时，渲染一个加载状态 通过 #fallback 的形式。

## teleport

- 作用： 将组件内部的一部分模板“传送”到该组件dom结构的最外层。

### vue中的插槽

- 具名插槽

```html
// 组件
<slot name="default" />

<template v-slot:default> </template>
// 或者
<template #default> </template>

```

- 作用域插槽

```html
<!-- <MyComponent> 的模板 -->
<div>
  <slot :text="greetingMessage" :count="1"></slot>
</div>


<MyComponent v-slot="slotProps">
  {{ slotProps.text }} {{ slotProps.count }}
</MyComponent>

```

### $attrs 和 $listeners

- 透传 Attributes 是指由父组件传入，且没有被子组件声明为 props 或是组件自定义事件的 attributes 和事件处理函数。
- 你可以通过 inheritAttrs: false 来禁用这个默认行为。

### watch 和 watchEffect的区别

- watch 需要传入侦听的数据源。而watchEffect是自动收集数据源作为依赖
- watchEffect 在初始化时就会执行一次。而 watch的话，只有设置了 `immediate: true` 时，才会在初始化时监听。

## watchEffect

- 立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行
- 设置 flush: post 将会使侦听器延迟到组件渲染后执行。
- 返回值是一个用来停止该副作用的函数。

```js
// 副作用清除
watchEffect(async (onCleanup) => {
  const { response, cancel } = doAsyncWork(id.value)
  // `cancel` 会在 `id` 更改时调用
  // 以便取消之前
  // 未完成的请求
  onCleanup(cancel)
  data.value = await response
})

// 停止侦听器
const stop = watchEffect(() => {})

//当不需要此侦听器时：
stop()

```

# 小程序面试题

## 打开一个小程序到页面展示，经历了什么

1. 启动小程序
2. 运行环境准备
3. 下载代码包
4. 缓存代码包
5. 代码注入
6. 逻辑层（jsCore）与渲染层（webview）双线程并行
7. 渲染页面

![](https://clouds.guowei.link/1640830848109444.png)

## 微信小程序原理

- 数据驱动的架构模式，UI和数据是分离的，所有页面的更新都需要通过数据的更改来实现。

## 小程序的 v-model和vue的有什么不一样

- 小程序设置this.data不会被同步到视图，必须要调用

```js
this.setData({})
```

## 小程序的优化

- 控制图片大小以及比例
- 避免wxml节点数过大
- 滚动区域设置惯性滚动。`-webkit-overflow-scrolling: touch`
- 避免短时间内发起太多请求
- 合理的使用分包
- 减少data的大小，非必要不 setData
- 组件化
- 按需注入

## bindtap 与 bindcatch 区别

- bindtap不会阻止事件冒泡，bindcatch`会阻止`事件冒泡

## webview中的页面怎么跳回小程序中?

- wx.miniProgram.navigateTo({url:'/pages/index/index'})

## webview的页面怎么跳转到小程序导航的页面?

- 通过 switchTab 跳转，但是默认情况下不会重新加载数据，若需要重新加载数据，则需要在success属性中手动调用

```js
// 在 webview中的success属性中添加以下代码

success:function (e) {
  var page = getCurrentPages().pop()
  if(page === undefined || page === null) return

  page.onLoad()
}

```

## webview怎么跟小程序通信？

## 微信小程序和h5的区别

- 运行环境不同
  - 小程序运行在 webview 内核中
  - h5运行环境是浏览器

- 开发成本不同
  - 只在微信中运行，不用顾虑浏览器兼容问题

## 小程序设置less

- `easy less` 插件，配置一下 `settings.json` 就可以了

## 小程序的生命周期

- App
  - onLanch
  - onShow

- Page
  - onLoad
  - onShow
  - onReady
  - onHide
  - onUnload
  - onShareMessage
  - onPageScroll
  - onPullDownRefresh

- Component
  - created
  - attached
  - ready
  - moved
  - detached
  - error

## 小程序绘制海报会出现的问题

- 图片显示不全，或者图片模糊
- 原因： 你设置的图片宽高例如为 750 x 1200 ，但实际在canvas画布上画出的尺寸为  375 x 600，图片会显示不全。

### wx.canvasToTempFilePath() 将画布指定区域导出生成指定大小的图片

- 解决
  - 图片居中问题
  - 生成图模糊问题

```js
wx.canvasToTempFilePath({
  x: 0,
  y: 0,
  width: 50,
  height: 50,
  destWidth: 100,
  destHeight: 100,
  canvasId: 'myCanvas',
  success(res) {
    console.log(res.tempFilePath)
  }
})
```

# React

## 组件通信

- 父传子: props；
- 子传父: 子调用父组件中的函数并传参；
- 兄弟: 利用redux实现和利用父组件。

## diff算法

- diff算法的本质: 就是找出两个对象之间的差异，目的是尽可能做到节点复用。
- 上述中的对象:指的其实就是vue中的virtual dom（虚拟dom树），即使用js对象来表示页面中的dom结构。

三个层级策略:
1、tree层级：dom节点跨层级的移动操作特别少，可以将其忽略不计。
2、component层级：拥有相同类的两个组件会生成类似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。
3、element层级：对于同一层级的一组子节点，可以通过唯一key进行区分。

## 高阶组件

- 高阶组件就是一个函数，且该函数接收一个组件作为参数，并返回一个新的组件。

## 常用的hooks

- seState: 设置和改变state，代替原来的state和setState
- useEffect: 代替原来的生命周期，componentDidMount，componentDidUpdate 和 componentWillUnmount 的合并版
- useLayoutEffect: 与 useEffect 作用相同，但它会同步调用 effect
- useMemo: 控制组件更新条件，可根据状态变化控制方法执行,优化传值
- useCallback: useMemo优化传值，usecallback优化传的方法，是否更新
- useRef: 跟以前的ref，一样，只是更简洁了

### useCallback和useMemo的区别

- useMemo 计算结果是return 出来的值。使用场景： 需要计算的状态。
- useCallback 计算结果是函数，主要用于缓存函数。使用场景：需要缓存的函数，因为函数式组件每次任何一个state的变化 整个组件都会被重新刷新，一些函数是没有必要重新刷新的，此时就应该缓存起来，提高性能和减少资源浪费。（利用缓存函数，使子组件不会重新渲染）

### hooks优势

1. 函数组件无this问题
2. 自定义Hooks方便状态复用
3. 副作用关注点分离。

## redux

核心概念:
store、action、reducer

关键函数:
getState() ：用于获取当前最新的状态
subscribe() ：用于订阅监听当前状态的变化，然后促使页面重新渲染
dispatch() ：用于发布最新的状态

执行流程:
（1）用户通过事件触发ActionCreator制造action
（2）同时，用户触发的事件内调用dispatch来派发action
（3）reducer接收action，并处理state返回newState
（4）View层通过 getState() 来接收newState并重新渲染视图层

# 基础

## var, let , const 的区别

- 变量提升、块级作用域、重复声明同名变量、重新赋值

## 防抖和节流

防抖(debounce)：触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间
节流(throttle)：高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率

区别：防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行。

## 常见code 码

200 - 请求成功
301 - 永久重定向
302 - 临时重定向
304 - 自从上次请求后，请求网页未修改过，服务器返回响应，不返回内容 （）
400 - 服务器不理解请求的语法
403 - Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求
404 - 请求的资源（网页等）不存在
413 - 请求体过大，超出服务器的处理能力上限
414 - 请求url太长，服务器无法处理
500 - 内部服务器错误
502 - Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应

## Object.is() 对比两个参数是否相等

```js
Object.is(NaN,NaN)  // true

Object.is(+0,-0) // false

// 自己实现一个Object.is
if(!Object.is) {
  Object.is = function (x, y){
    if (x === y) { // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }

}

// 如果要处理+0和-0的问题，通过Object.defineProperty()
Object.defineProperty(Object, 'is' , {
  get(){

  }

  set(){

  }
})
```

## 使用 DocumentFragment 创建并组成一个dom子树

- 目的： 减少重绘重排的次数

```js
<ul id="list"></ul>


const list = document.querySelector('#list')
const fruits = ['Apple', 'Orange', 'Banana', 'Melon']

const fragment = new DocumentFragment()

fruits.forEach((fruit) => {
  const li = document.createElement('li')
  li.textContent = fruit
  fragment.appendChild(li)
})

list.appendChild(fragment)

```

## 什么是纯函数

- 没有副作用的函数

## 什么是函数副作用

- 函数在正常工作任务之外对外部环境所施加的影响。

## 自己实现一个promise.all

```js
Promise.prototype.all = function (promises){
  let results = []
  let promiseCount = 0
  let promisesLength = promises.length

  return new Promise((resolve, reject) => {
    for(let val of promises) {
      Promise.resolve(val).then(function(res){
        promiseCount++;
        results[i] = res
        if(promiseCount === promisesLength) {
          return resolve(results) // 可以不用 return 出去
        }
      }, function (err){
        return reject(err) // 可以不用 return 出去
      })
    }
  })
}
```

### 数组对象去重

1. 使用 filter和map

```js
function uniqueFunc(arr, key){
  const res = new Map()
  return arr.filter((item) => !res.has(item[key]) && res.set(item[key], 1))
}
```

2. 使用 reduce

```js
function uniqueFunc(arr, key){
  let hash = {}
  return arr.reduce((prevValue,currentValue) => {
    hash[currentValue[key]] ? '' : hash[currentValue[key]] = true && prevValue.push(currentValue)
    return prevValue
  },[])
}
```

### css绘画一个半圆或者月亮类型的形状

### type 和 interface的区别

1. type后面有 = ，interface 没有。
2. type可以描述任何类型组合，interface 只能描述对象结构
3. interface 可以继承自（extends）interface 或对象结构的 type。type 也可以通过 & 做对象结构的继承。
4. 多次声明的同名 interface 会进行声明合并，type 则不允许多次声明。
5. type可以使用in 关键字 生成映射类型，interface不行。

- 用来描述对象或函数类型
- 可以通过交叉实现继承
  - interface可以扩展，type可以通过交叉实现interface的extends行为
  - interface可以extends type，同时type也可以与interface类型交叉
- type可以使用in 关键字 生成映射类型，interface不行。

```js
type Keys = "name" | "sex"
type DuKey = {
  [Key in Keys]: string //类似 for ... in
}
let stu: Dukey = {
  name: 'wang'，
  sex: 'man'
}
```

### type 怎么继承

```js
type Name = {
  name: string
}

type Person = Name & {
  age: number
}

const people: Person = {
  name: 'ren',
  age: 20
}

// interface 可以通过 extends 进行继承 ； type不能通过 extends进行继承
```

### nginx 怎么配置负载均衡？

### 怎么去做按钮权限的处理？

- 菜单栏权限怎么做？
- 按钮权限怎么做？

### vue2跟vue3的区别

### 浏览器缓存

#### 浏览器缓存的意义

- 避免了冗余的数据传输，节省流量
- 加快了用户访问速度
- 减小了服务器的压力

#### 浏览器缓存策略

- 第一次请求数据时，浏览器没有对应的缓存数据，此时需要请求服务器，服务器返回数据后，会把请求数据缓存。
- 当浏览器有缓存数据后，可以根据是否向服务器发送请求，将缓存类型分为： 协商缓存与强缓存

#### 强缓存

- 命中缓存后，不会向服务器发送请求,直接从本地获取。返回的状态码为 200(from disk cache) 或 200（from memory cache）

#### 协商缓存

- 缓存过期，浏览器会向服务器发送请求，协商对比服务端和本地的资源，验证本地资源是否失效。若服务器资源与本地资源相同，则命中缓存，返回304，否则直接请求服务器资源。
- 协商缓存的响应结果，不仅验证资源的有效性，同时还会更新浏览器缓存
- Age:0 表示命中了代理服务器的缓存, age 值为 0 表示代理服务器刚刚刷新了一次缓存.

#### 强缓存与协商缓存的关系

- 相同点： 强缓存与协商缓存在命中缓存资源后都是从本地读取资源。
- 不同点：
  - 如果强缓存生效，不需要再向服务端发起请求。
  - 协商缓存，不管是否使用缓存，必须向服务器发送一个请求来协商。

#### 优先级

- 两类缓存规则同时存在的情况下， `强缓存 > 协商缓存`
- 当执行强缓存的规则时，如果缓存生效，直接使用缓存，不再执行协商缓存规则。如果强制缓存规则不生效，则需要进行协商缓存判断

#### 总结

- 浏览器第一次请求数据时，浏览器缓存中没有对应的缓存数据，此时需要请求服务器，浏览器返回数据后，会把请求数据缓存。
- 浏览器再次访问同一url，则会根据请求资源是否过期向服务器发送不同请求，此时分为强缓存和协商缓存。
- 若资源未过期（expires和cache-control）时，命中缓存，不会向服务器发送请求，直接从缓存中读取。
- 若资源显示过期（if-modified-since/Last-Modified）和（if-none-match/Etag），则会向服务器发送请求，协商对比服务器资源，验证是否失效。若相同，命中协商缓存，返回304，否则直接请求服务器。

#### 清除浏览器缓存

- meta标签中令cache-control为no-cache或者expires为0

```js
//不缓存
<META HTTP-EQUIV="Cache-Control" CONTENT="no-cache, must-revalidate">
<META HTTP-EQUIV="expires" CONTENT="0">
```

#### 哪些不能被浏览器缓存

1. http头中cache-control为no-cache或者为max-age: 0
2. 需要根据cookie，和输入内容的动态请求
3. 经过https加密的请求
4. post请求不可以被缓存
5. http响应头中不含Last-Modified/Etag，也不包含Cache-Control/Expires的请求无法被缓存

### meta标签有多少属性

- name
  - name属性的几个值
    - keywords 关键字
    - description 描述
    - viewport 视口
    - robots 搜索引擎的索引方式
    - renderfer 搜索引擎的渲染方式
    - revisit-after 搜索引擎的重访时间
- http-equiv
  - http-equiv属性的几个值
    - content-Type 设定网页字符集
    - X-UA-Compatible 告知浏览器以何种方式渲染页面
    - cache-control 请求和响应的缓存机制
    - expires 网站过期时间
    - refresh 自动刷新并重新跳转指定页面
    - set-Cookie 设置cookie

```html
<meta name="xxx" content="xxxx">

<!-- 相当于设置http -->
<meta http-equiv="参数" content="具体的描述">
```

### 跨终端解决方案

- flutter
- Taro
- React Native
- H5 Hybrid
- 桌面端对应的方案就是Electron

#### jsBridge

- [jsBridge](https://juejin.cn/post/6936814903021797389)

- Web端和Native可以类比于Client/Server模式，Web端调用原生接口时就如同Client向Server端发送一个请求类似，JSB在此充当类似于HTTP协议的角色，实现JSBridge主要是两点：
  - 将native 端的原生接口封装为JavaScript接口
  - 将 JavaScript 接口 封装为 原生接口

#### 开源的 jsBridge

- DSBridge，主要通过注入API的形式。`DSBridge for Android`、`DSBridge for IOS`
- JSBridge， 主要通过拦截 URL Schema 的形式， `JsBridge`

#### 跨终端web适配方式

- 可以写多套代码，输入网址时判断pc或mobile，返回对应的内容。
- 响应式设计 bootstrap

### less是怎么编译成css的

- 通过less和less-loader
- less 使用less语言的特性，嵌套语法，变量，函数，常量，map
- less-loader 将 less 编译成css文件
- css-loader 解析css文件里面的css代码（默认webpack只解析js代码的）
- style-loader 将css-loader解析的内容挂载到html页面中

### require 和 import 的区别

- require 是`运行时加载`；import 是编译时输出接口。
- require 是同步加载模块； import 是异步加载模块（有一个独立模块依赖的解析阶段）。
- require 输出的是一个值的（浅）拷贝；import 输出的是值的引用。

### js基础数据类型和引用数据类型存在哪

- `基础数据类型`存在`栈（stack）`(特点：先进后出)中。
- `引用数据类型`存在`堆（heap）`（特点：数据任意存放）中。

### 在浏览器中输入一个网址到页面展示，会经历什么？（重要）

[传送门](https://www.zhihu.com/question/440812545/answer/2379426038)

1. 浏览器输入url
2. 查找缓存： 浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有，则显示该页面，没有则进行下一步.
3. DNS域名解析： 浏览器向dns服务器发送请求，解析该URL域名中对应的ip地址。（dns服务器是基于UDP的，因此会用到UDP协议）
4. 建立TCP连接：解析出IP地址后，根据IP地址和默认的端口，和服务器建立TCP连接。
5. 发起http请求： 浏览器发起读取文件的http请求，改请求作为TCP三次握手的第三次数据发送给服务器
6. 服务器响应并返回结果： 服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器
7. 关闭TCP连接： 通过四次挥手释放TCP连接
8. 浏览器渲染： 客户端解析html内容并渲染出来
   1. 构建dom树：词法分析然后解析成dom树（dom tree），是由dom元素及属性节点组成，树的跟是document对象
   2. 构建css规则树： 生成css规则树（CSS Rule Tree）
   3. 构建render树： 浏览器将dom和CSSOM结合，并构建出渲染树（render Tree）
   4. 布局（Layout）：计算出每个节点在屏幕中的位置
   5. 绘制（Painting）：遍历render树，并使用UI后端层绘制每个节点

### TCP的三次握手和四次挥手

- 三次握手
  - 客户端向服务端发送syn请求包，询问服务端能不能收到请求
  - 服务端接收后向客户端发送ack确认包，告诉客户端能收到
  - 客户端向服务端发送ack确认包，告诉服务端我也能收到，然后客户端进入准备状态，服务器接收后也进入准备状态。

- 四次挥手
  - 客户端向服务端发送fin请求包，告诉服务端要断开连接
  - 服务端收到后发送ack确认包告诉客户端收到了断开请求
  - 服务端有未传完的数据会继续传完，然后向客户端发送fin请求包，告诉客户端可以断开连接了
  - 客户端收到后向服务端发送ack确认包，然后客户单断开连接，服务端收到后也断开连接

### 浏览器的重绘、重排/回流

- 重排/回流（Reflow）: 当dom变化影响元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为：重新生成布局，重新排列元素。
- 重绘(Repaint): 当一个元素外观发生改变，但没有改变布局，重新把元素外观绘制出来的过程，叫重绘。表现为某些元素的外观被改变

#### 如何触发重排和重绘？

- 添加、删除、更新DOM节点
- 通过display: none隐藏一个DOM节点-触发重排和重绘
- 通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化
- 移动或者给页面中的DOM节点添加动画
- 添加一个样式表，调整样式属性
- 用户行为，例如调整窗口大小，改变字号，或者滚动。

#### 如何避免重排重绘？

- 集中改变样式，不要一条一条地修改 DOM 的样式
- 不要把 DOM 结点的属性值放在循环里当成循环里的变量。
- 为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的
- 不使用 table 布局
- 尽量只修改position：absolute或fixed元素，对其他元素影响不大
- 动画开始GPU加速，translate使用3D变化
- 提升为合成层
  - 合成层的位图，会交由 GPU 合成，比 CPU 处理要快
  - 当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层
  - 对于 transform 和 opacity 效果，不会触发 layout 和 paint

### dispatchEvent 点击和真实点击的区别

- 没啥大区别，最终调用的都是 fireEventListener
- 其中的 microtask 执行条件是必须在 host 包装嵌套深度为 0 时才跑
- 用户点击时候，microtask 执行时，是回调完成后，此时包装深度已经是 0 了
- 而 dispatchEvent 时，由于 dispatchEvent 本身就是个层包装，需要它执行完成后包装深度才能是 0，才能 runMicrotask。

```html
<!-- 可以通过 event.isTrusted 判断是否由用户触发 true 用户触发；false 代码触发-->
<button class="btn">测试dispatchEvent()方法</button>

<script>
  let btn = document.querySelector('.btn');

  btn.addEventListener('click', function () {
    alert('点击了');
  });

  let clickEvent = new Event('click');
  btn.dispatchEvent(clickEvent);
</script>
```

### 深拷贝

```js
function clone(target, map = new Map()) {
  if (typeof target === 'object') {
    let cloneTarget = Array.isArray(target) ? [] : {}
    if (map.get(target)) {
      return map.get(target)
    }
    map.set(target, cloneTarget)
    for (const key in target) {
      cloneTarget[key] = clone(target[key], map)
    }
    return cloneTarget
  } else {
    return target
  }
}
```

## 字节

### 算法题

### 什么是单链表

#### 链表

- 线性递归结构，通过指针相连
- 可以用git仓库的储存理解，不同的分支和节点连接在一起

#### 判断一个单链表中是否有环？

```js
// 判断一个链表中是否有环

// 例如：A->B->C->D->B->C->D

// D指向B形成环

// 要求：在空间复杂度O(1)的情况下，时间复杂度最小


// 思路： 做一个快指针，做一个慢指针，快指针每次走两步，慢指针每次走一步；如果有环的话，就慢指针就会追上快指针。
function ListNode(x){
    this.val = x;
    this.next = null;
}
function EntryNodeOfLoop(pHead){
    if(pHead === null)
        return null;
    var fast = pHead;
    var slow = pHead;

    while(fast.next !==null && fast.next.next !== null) {
        slow = slow.next;
        fast = fast.next.next;
        if(slow === fast)
            break;
    }

    if(fast === null || fast.next === null)
        return null;
    // 有环，slow重新回到链表头
    slow = pHead;

    // slow和fast重新相遇时，相遇节点就是入环节点
    while(slow !== fast) {
        slow = slow.next;
        fast = fast.next;
    }

    return slow;
}
```

#### 有一个LinkedList类，实现一个单链表中的 insert、find、append 方法。

```js
class LinkedList {
  constructor(){
    this.size = 0;  // 单链表的长度
    this.head = new Node('head');  // 表头节点
    this.currNode = '';  // 当前节点的指向
  }

  insert(item, element){
    let itemNode = this.find(item);

    if(!itemNode) {  // 如果item元素不存在
        return;
    }

    let newNode = new Node(element);

    newNode.next = itemNode.next; // 若currNode为最后一个节点，则currNode.next为空
    itemNode.next = newNode;

    this.size++;
  }

  isEmpty() {
    return this.size === 0;
  }

  findLast() {
    let currNode = this.head;

    while (currNode.next) {
        currNode = currNode.next;
    }

    return currNode;
}

  find(item){
    let currNode = this.head;

    while (currNode && (currNode.data !== item)) {
        currNode = currNode.next;
    }

    return currNode;
  }
  delete(item){
    if(!this.find(item)){  // item元素在单链表中不存在时
      return;
  }

  // 企图删除头结点
  if (item === 'head') {
      if (!(this.isEmpty())) {
          return;
      } else {
          this.head.next = null;
          return;
      }
  }

  let currNode = this.head;

  while (currNode.next.data !== item) {
      // 企图删除不存在的节点
      if (!currNode.next) {
          return;
      }
      currNode = currNode.next;
  }


  currNode.next = currNode.next.next;
  this.size--;
  }
}
```

### 从浏览器输入url网址到展示页面发生了什么

### ISO 七层模型

### https和http 的区别

### https的加密是在ISO七层模型中的哪一层？

- https的加密在ISO 七层模型中的`表示层`。

### new 一个构造函数会发生什么

### 你还知道哪些加密方法？

- aes/des加密
- base64加密（不可逆）
- MD5加密
- sha512加密（不可逆）

### 为什么要使用aes（对称加密）进行加密？

- 优点： 算法公开、计算量小、加密速度快、加密效率高
- 缺点：
	- 交易双方都使用同样钥匙，安全性得不到保证
	- 密钥管理困难，使用成本较高

### 频繁的请求后台，不会有什么问题吗？用户量不大吗？

### 怎么在不使用变量的情况下 交换两个变量的值

```js
let a = 1;
let b = 2;
[b,a] = [a,b]
```

#### [b, a] = [a, b] 的原理是什么，它是怎么交换两个变量的值的？

- `[a, b] = [b=a, a=3]`
- 解构的过程为：
  1. 以从左到右的顺序计算出右侧数组的值，得到数组
  2. 以从左到右的顺序，将右侧数组的值赋值给左侧

- 可以看到解构赋值的过程中会有一个包含两个元素的的临时数组，并没有比传统方法节省空间，甚至空间会比传统方法多一个int值大小的空间

## 斐波拉契数列数组

```js
const map = new Map()
const list = []
function fn(num) {
  if(map.has(num)) {
    return map.get(num)
  }

  if(num === 1 || num === 2) {
    if(!map.has(num)) {
      list.push(1)
      map.set(num, 1)
    }
    return 1
  }

  const result = fn(num - 1 ) + fn(num - 2)
  map.set(num, result)
  list.push(result)
  return result
}

console.log('list',list)
```

## 斐波那契数列 二叉树分布，寻找最左边节点值组成的集合

![二叉树找最左边节点](https://clouds.guowei.link/二叉树找最左边节点.png)

```js
 // [1,1,2,3,5,8,13,21,34,....,n-2,n-1]
let index = 1
const newList = [list[0]]
list.forEach((item,i) => {
  if(index > i ) {
    return;
  }
  if(i === index) {
    newList.push(item)
    index = 2 * index + 1
  }
})
```

# 安全方面

## 黑客上传了一个文件到我们服务器之后，是怎么黑进我们系统的？

## 页面常见攻击方式

- xss攻击
- crsf攻击

## liunx 修改文件读取权限

- chmod -R 777
  - 表示的意思：
    - 第一个 7 表示：文件所有者访问权限
    - 第二个 7 表示：群组访问权限
    - 第三个 7 表示：其他人访问权限

- r(read)w(write)x(eXecute) 读、写、执行
  - 权限值：4
  - 权限值：2
  - 权限值：1

## 前端怎么去防止sql注入

- 防止 SQL 注入唯一可靠的方式是`验证输入`和`参数化查询`
- 开发者必须`检查所有用户输入`，而不是仅检查网页表单中的输入,比如登录表单。他们必须移除潜在的恶意代码因素,比如`单引号`。在你的线上环境中屏蔽数据库错误也是个好主意。因为结合数据库错误，SQL 注入攻击将获得更多数据库相关信息

### sql注入的危害

- 通过sql注入可以添加、编辑、删除数据库中的数据
- 可以拿到其他用户的凭证。伪装成这些用户。
- 甚至可以拿到数据库管理员权限。窃取数据。
- 影响应用的可用性。
- 可以通过sql注入作为初始手段，攻击防火墙背后的内网。

### sql注入攻击的过程及原因

- 为了发起 SQL 注入攻击，攻击者首先需要在网站或应用程序中找到那些易受攻击的用户输入。这些用户输入被有漏洞的网站或应用程序直接用于 SQL 查询语句中。攻击者可创建这些输入内容。这些内容往往被称为恶意载体，它们是攻击过程中的关键部分。随后攻击者将内容发送出去，恶意的 SQL 语句便会在数据库中被执行。
  - 攻击者可利用 SQL 注入，从数据库中得到其他用户的用户凭证。之后他们便能伪装成这些用户。这些用户中甚至有可能包括有所有数据库权限的数据库管理员。
  - SQL 可用于从数据库中选择并输出数据。SQL 注入漏洞允许攻击者访问数据库服务中的所有数据。
  - SQL 也可用于修改数据库中数据，或者添加新数据。例如，在金融产品中，攻击者能利用 SQL 注入修改余额，取消交易记录或给他们的账户转账。
  - SQL 可用于从数据库中删除记录，甚至删除数据表。即使管理员做了数据库备份，在数据库中数据恢复之前，被删除的数据仍然会影响应用的可用性。而且，备份很可能没有覆盖最近的数据。
  - 在某些数据库服务中，可通过数据库服务访问操作系统。这种设计可能是有意的，也可能是无意的。在这种情况下，攻击者将 SQL 注入作为初始手段，进而攻击防火墙背后的内网

### 预防sql注入

- 培养并保持安全意识
- 不要信任任何用户输入
- 使用白名单，而不是黑名单： 不要基于黑名单过滤用户输入。因为聪明的攻击者总是能找到绕过黑名单的方法，所以应尽可能只使用严格的白名单，对用户输入进行验证和过滤。
- 采用最新的技术
- 采用经过验证的机制
- 周期性扫描： SQL 注入漏洞可能被开发者引入，也可能被外部库、模块或软件引入。你应该使用网站漏洞扫描器（比如 Acunetix）周期性扫描你的网站。如果你使用 Jenkins，你可以安装 Acunetix 插件，实现每次构建时进行自动扫描。

## 你知道哪些算法

- 递归
- 冒泡排序
- 插入排序
- 选择排序
- 快速排序
- 堆排序

## 自动化测试有没有了解过? 自动化测试有什么好处?

- [自动化测试](https://juejin.cn/post/7150482292564033566)

### 自动化测试的流程

- 输入 - 断言 - 验证
- 不管是单测还是 E2E 都可以遵循这个原则，如果不知道如何开始，可以考虑我们的预期结果是什么，以终为始，再去慢慢实现函数或组件的具体功能，这就是 TDD 的一种模式

- 自动化这种方案基本上能做到不漏测一个功能，而且不需要我们手动去输入数据和点击页面去验证了，提升了代码的质量
- 人工测试：通过开发人员或测试人员与程序的交互来完成，即手动操作验证。
- 自动化测试：通过自动化脚本与程序的交互来完成，除了刚开始编写的自动化脚本时间，基本上无需手动操作

### 自动化测试解决了什么问题?

- 解决了耗时时间和人力成本

### 自动化测试的应用场景

- 白盒测试：说白了就是代码的逻辑是否正确，流程逻辑，函数调用，异常处理等等，比如常见的单元测试。
- 黑盒测试：主要是对一个功能的验证，不关心代码的具体实现，比如端到端测试（E2E，也是集成测试的一种类别）

### 单元测试

> 一般是对程序最小单元运行测试的过程

- 单元测试的场景
  - 组件的单元测试：UI 组件、无状态组件、基础组件
  - 纯函数的单元测试
  - 我们可能会封装一些 util 工具等等，但是要保证我们写的函数是易于测试的，即没有副作用，函数的输入和输出是稳定的

#### 优点

- 测试速度很快。
- 代码覆盖率较高。
- 有助于模块的设计。
- 易于代码维护

#### 缺点

- 无法验证多个单元运行到一起是否正确，能做到这一点的是我们要介绍的集成测试。

### 集成测试/端到端测试(E2E)

> 集成测试是把不同的模块集成在一起，来测试模块与模块之前的配合是否正常工作。

- 在前端我们点击一个按钮会进行表单提交，而这涉及到按钮的点击事件是否正常，表单的校验或者发送请求是否正常触发。
- 而 E2E的定义和集成测试是差不多的，它们通常都是站在用户视角并且以真正的运行环境来测试整个流程和功能的。集成测试和端到端的定义的边界是较模糊的，所以我们可以放在一起介绍。下面是一个用户使用某个系统的简单场景
  - 访问某个系统主页
  - 点击某个元素，然后进入另外一个页面

- 那么它的测试代码可以这么写（以 Cypress 为例）：

```js
describe('My First Test', () => {
  it('clicking "type" navigates to a new url', () => {
    // 1.访问 https://example.cypress.io -> 模拟用户输入 URL
    cy.visit('https://example.cypress.io')

    // 2.点击某个元素 -> 模拟用户点击
    cy.contains('type').click()

    // 3.跳转新页面的断言
    // includes '/commands/actions'
    cy.url().should('include', '/commands/actions')
  })
})
```

## 测试模式

- TDD（测试驱动开发）：测试驱动开发，先写测试后实现功能
- BDD（行为驱动开发）：行为驱动开发，先实现功能后写测试

### TDD开发流程

- 编写测试用例
- 运行测试
- 编码使测试用例通过
- 重构/优化代码
- 新增功能，重复流程

#### TDD优点

- 功能代码未动，测试先行，能够用 “以终为始” 的开发思路来保证代码的质量。
- 可以促进开发人员去思考模块设计和重构代码。
- 测试的覆盖率较高，因为编写的代码需要按照测试的用例去跑，基本上每个用例都要考虑到

#### TDD缺点

- 测试代码量增多，比如 Vue 2.x 中 的 keep-alive 源码实现只有 100 多行，而单元测试代码有 800 多行
- 当代码调整时，测试代码也要调整，比如函数加了参数，函数里面加了 if 语句（这说明代码的设计不好）
- 最终做出来的东西和实际功能需求可能相偏离。

### BDD开发流程

- 需求确认（一般是从 PM 那获取需求）
- 以自动化的方式将需求建立起来（比如将需求录入某个迭代系统）。
- 实现每个文档示例描述的行为，并从自动化测试开始以指导代码的开发。
- 特点
  - 解决 TDD 模式下开发和实际功能需求不一致而诞生。
  - 不需要面向细节设计测试，而是面向行为测试。
  - 从产品的角度出发，鼓励开发与非开发人员之间的协作。
  - 注重功能测试，所以 BDD 更多结合的是集成测试，是黑盒的。

#### BDD优点

- 由于侧重于需求功能的完整度，所以能给开发人员增加更多对程序的信心。
- 由于仅关注功能，不关注实现细节，有利于测试代码和实际代码解耦。
- 由于大多数为编写集成测试，相比 TDD 有更好的开发效率。

#### BDD缺点

- 以功能性的集成测试为主，因此不是那么关注每个函数功能，测试覆盖率比较低。
- 没有 TDD 那么严格的保证代码质量。

## 在使用新技术的时候，是怎么去做 新旧技术的融合的？

## 有没有自己写过爬虫脚本？

## 怎么自己的网站不被爬虫爬？

[爬虫](https://zhuanlan.zhihu.com/p/553965796)

- 限制User-Agent字段：User-Agent字段能识别用户所使用的操作系统、版本、CPU、浏览器等信息，如果请求来自非浏览器，就能识别其为爬虫，阻止爬虫抓取网站信息
- 限制IP：限制IP是最常见的手段之一，为了效率，恶意爬虫的请求频率往往比正常流量高，找出这些IP并限制其访问，可以有效降低恶意爬虫造成的危害。
- 添加验证码：在登录页等页面，添加验证码，以识别是正常流量还是恶意爬虫，也是一种基本的操作。不过如今爬虫技术，早已能解决验证码的问题，例如二值化、中值滤波去噪等等。
- Cookies限制： 根据业务需求，可对Cookies进行限制，要求用户登录后才能使用某些功能或权限，并针对同一账号的访问速度进行限制。
- 使用爬虫管理产品： 可以使用防火墙产品，能够有效防范爬虫，比如阿里云、腾讯云

## 首页白屏怎么优化

- ssr渲染（后端渲染）
- 预渲染（prerender-spa-plugin）
- 使用骨架屏

## 前端秘钥怎么存储

1. 前端需要传输时，需要先向服务器获取一个`加密公钥`(加密密钥对由后端生成，以公钥为key,私钥为value存储在redis中)
2. 获取到数据后，将数据进行加密并将加密后的数据和公钥一起传给后端。
3. 后端通过公钥从redis中得到配对的秘钥，然后对密码解密

## 添加加密后接口访问速度比之前快还是慢，慢多少？

- 没有影响

## 前端怎么做性能优化？

## k8s怎么配置的？
