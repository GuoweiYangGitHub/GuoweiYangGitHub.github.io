# 速背知识

## Vue 部分

### 怎么理解 Vue 中 MVVM？

`vue.js` 是采用数据劫持结合发布者-订阅者模式的方式，通过 `Object.defineProperty()`来劫持各个属性的`getter`，`setter`，在数据变动时发布消息给订阅者，触发相应的监听回调。

`MVVM`作为数据绑定的入口，整合`Observer`、`Compile` 和 `Watcher` 三者，通过`Observer`来监听自己的`model`数据变化，通过`Compile`来解析编译模板指令，最终利用`Watcher`搭起`Observer`和`Compile`之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(`input`) -> 数据`model`变更的双向绑定效果。

### MVC 和 MVVM 的区别

- 没有很大的区别，只是 MVC 是单项数据绑定，只绑定了数据，数据更改然后视图跟着渲染，而 MVVM 实现了双向数据绑定，在基础上多了一层视图更改，对应数据绑定也跟着更改。要从 MVC 到 MVVM 其实不难，一个 onchange 事件搞定，所以没有很大区别。

### 怎样理解单项数据流

- 这个概念出现在组件通讯。父组件是通过 prop 把数据传递到子组件的，但是这个 prop 只能由父组件修改，子组件不能修改，否则会报错。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收后，由子组件修改。

### 使用过哪些 vue 的插件

- vuex
- axios
- vue-router
- element-ui
- vant
- ant-vue
- iview
- mint-ui

#### 手机端使用 echarts 有没有遇到过什么问题

- 同一个 echartsDOM 你要渲染两种不同类型的图表时，你要先 echartsDOM.clear()移除实例中所有的组件和图表
- 移动端 echarts 字号设置不受浏览器最小字号限制，我们可以随意的设置更符合界面显示需要的字号
- tooltip 显示框默认是出现在用户交互的数据点附近，在手机端可能会有显示不全的问题，可以动态设置 tooltip 的位置

### es6 新增

- promise
- Set()
- Map()
- Object.assign() //浅拷贝
- 箭头函数
- let 和 const
- 模板字符串
- class
- 数据解构
- 数据展开 ...操作符
- import export

## 兼容性问题

### 1.Android 端文字未垂直居中

```text
1. 通过line-height等于height设置时有时会出现未垂直居中,换用flex布局的align-items: center;

2.小于12px大小的字体会偏上: 通过transform: scale() 和 transform-origin控制字体缩放
```

### 2.ios 页面底部 margin-bottom 失效（有人没遇到过这个问题？？）

- 设置一个空的 div 撑起 margin-bottom 设置的高度

### 3.absolute 定位元素被输入法顶起

- 当 absolute 元素的父元素设置 height 等于屏幕高度时,输入法弹起,屏幕高度缩小,导致定位元素顶起,遮盖了其他元素
- 解决方法:
  - input 获取焦点时,让定位元素隐藏或改成静态定位,失去焦点时恢复.

### 4.输入法弹窗导致窗口变小

输入法弹窗显示时,会导致 window 窗口高度变小

- 场景:
  - 页面 a,输入法弹窗显示时,跳到页面 b,会导致页面 b 通过 window.innerHeight 获取的高度有问题
- 解决方法:
  - 1.跳转页面之前,先用 document.activeElement.blur()隐藏虚拟键盘,然后延时 300 毫秒再跳转
  - 2.跳转前先通过 window.innerHeight 获取输入法未弹起时的内容窗口高度,再通过地址拼接传递该高度.

### 移动端 1px 的问题

> devicePixelRatio = 物理像素 / css 像素。

- 使用伪类 + transform scale 配合

```css
.div::after {
  content: '';
  box-sizing: border-box;
  position: absolute;
  z-index: 1;
  left: 0;
  top: 0;
  width: 300%;
  height: 300%;
  border: 1.5px solid #bfbfbf;

  transform: scale(1/3);
  transform-origin: left top; /*缩放原点*/
  border-radius: 6px;
}
```

#### computed 和 watch 的区别

- 计算属性是自动监听依赖值得变化，而动态返回内容，监听是一个过程，在监听的值变化时，可以触发一个回调，并做一些事情。
- 所以区别来源于用法，只是需要动态值，那就用计算属性；需要知道值的改变后执行业务逻辑，采用 watch，用反或混用虽然可行，但都是不正确的用法。

#### Vue 中的组件通讯

- 父组件向子组件传值 props
- 子组件向父组件传值 \$emit
- 父子,兄弟,跨级组件通讯 bus
- Vuex 状态管理
- provide/inject
- $parent/$children

#### 常见攻击方式有哪些

- CSRF: 跨站请求伪造
  - F 是网站 A 的用户，且已登录，网站 A 对用户 F 进行身份认证后下发了 cookie，保存在 F 浏览器中。
  - F 访问网站 B，网站 B 存在引诱点击（往往是个链接，指向网站 A 的 API 接口，通常是 GET 类型），然后访问了 A 网站，浏览器会自动上传 cookie。
  - 网站 A 对传来的 cookie 进行确认，是合法用户，则执行接口的动作
- XSS: 跨站脚本攻击
  - 攻击原理: 向页面的合法渠道注入脚本 (在脚本里执行想做的事情,不一定要登录)

#### 前后端的通信有哪些

- ajax: 同源下的通信
- WebSocket: 不受同源策略限制
- CORS: 支持跨域通信,也支持同源通信

#### 跨域的解决方案有哪些(协议，域名，端口)

- 1.jsonp 跨域
- 2.location.hash 跨域
- 3.postMessage 跨域
- 4.WebSocket 跨域
- 5.CORS 跨域(后台设置响应头)
- 6.反向代理(在 vue 中经常用到)
- nginx 代理

#### HTTP 报文的组成部分

- 请求报文: 请求行 请求头 空行 请求体
- 响应报文: 状态行 响应头 空行 响应体
  - 请求头: HTTP 方法,页面地址,http 协议及版本
  - 请求头: key-value 值,告诉服务端需要的内容
  - 空行: 告知服务端一下内容为请求体
  - 请求体: 数据部分

#### 重排(Reflow)与重绘(Repaint)

- 重排

  - 定义: DOM 中各个元素都有自己的盒子模型,需要浏览器根据样式进行计算,并根据计算结果将元素放到特定位置,这就是重排
  - 触发条件:
    - 增.删.改.移 DOM
    - 修改 CSS 样式
    - 改变浏览器窗口的大小
    - 页面滚动
    - 修改网页的默认字体
    - 获取一些 style 信息时 ,offsetWidth, offsetHeight, ...

- 重绘
  - 当各种盒子的位置,大小以及其他属性改变时,浏览器需要吧这些元素都按照各自的特性回执一遍,这个过程为重绘
  - 触发条件:
    - DOM 改动
    - CSS 某些改动样式的改动,比如 颜色

#### 提升页面性能的方法

- 资源压缩合并,减少 http 请求
- 非核心代码异步加载
- 使用浏览器缓存
- 使用 CDN 缓存
- 预解析 DNS
- HTTP 优化,如使用语义化标签,避免重定向
- CSS 优化,如布局代码写在前面,根据需求加载网络字体,避免使用 css 表达式

#### new 运算符实现机制

- 创建了一个新对象
- 将构造函数的作用域赋给新对象(让 this 指向了这个对象)
- 执行了构造函数(为这个新对象添加属性)
- 返回新对象

#### this 指向 (函数的 4 种调用模式)

- 普通函数调用 this 执行 window
- 对象调用 this 指向 调用的这个对象
- new 构造函数 调用, this 指向 new 构造函数的实例
- setTimeout setInterval this 指向 window
- 箭头函数 ,this 指向上下文(context 也就是作用域)
- call,apply 调用 this 指向你要替换的对象

### 垃圾回收机制

- `标记清除法清除`(现代浏览器都使用的是标记清除法)

  - 此算法假定设置一个叫做根(root)的对象, 在(js 中,根是全局对象 window),定期的让垃圾回收器从根开始,找到所有从根开始引用的对象, 然后找到这些对象的引用对象, 从根开始,垃圾回收器将找到所有可以获得的对象和所有不能获得的对象

#### 斐波拉契数列

```js
// 1,1,2,3,5,8,13,21,34,55,89,144   //数组的第n个是第 n-1 个和 n-2 个的和
function outer() {
  var arr = [];
  function fn(n) {
    if (n === 0 || n === 1) {
      return 1;
    }
    if (arr[n]) {
      return arr[n];
    } else {
      var temp = fn(n - 1) + fn(n - 2);
      arr[n] = temp;
      return temp;
    }
  }
  return fn;
}
var fn = outer();
var result = fn(100);
console.log(result);
```

### 弹性布局

- initial 设置它的属性为它的默认值
- inherit 让父元素继承该属性

- 主轴对齐方式 justify-content: flex-start | flex-end | center| baseline
- 侧轴对齐方式 align-items: flex-start | flex-end | center | space-between | space-around
- 改变主轴方向 flex-decoration: row | row-reverse | column | column-reverse | initial | inherit
  - row(默认值)水平显示 | 与 row 相同,顺序相反 | 垂直显示 | 垂直显示, 顺序相反 | | 从父元素继承该属性值
- 给 flex 布局盒子固定宽度: flex-basis: number | auto | initial | inherit

### BFC 块级格式化上下文

- 一个创建了新的 BFC 的盒子是独立布局的，盒子内元素的布局不会影响盒子外面的元素。在同一个 BFC 中的两个相邻的盒子在垂直方向上一个接一个的放置，BFC 是指浏览器中创建了一个独立的渲染区域，该区域内所有元素的布局不会影响到区域外元素的布局，这个渲染区域只对块级元素起作用。

#### 哪些元素会生成 BFC

- float 不为 none
- position 不为 static/relative
- overflow 不为 visible
- display 的值为 table table-cell table-caption
- 根元素

## webpack 优化

### 开启 gzip 压缩 ( compression-webpack-plugin)

### 通过 splitchunk 切割大文件

### js 文件最小化处理

### 图片资源压缩 (image-webpack-loader)

## 其他优化

- webpack 模块打包和 JavaScript 压缩（如 gzip 压缩）
- 利用 CDN
- 按需加载资源
- 在使用 DOM 操作库时用上 array-ids
- 缓存优化
- 避免重定向
- 启用 HTTP/2
- 应用性能分析
- 使用负载均衡方案
- 为了更快的启动时间考虑一下同构
- 使用索引加速数据库查询
- 使用更快的转译方案
- 避免或最小化 JavaScript 和 CSS 的使用而阻塞渲染
- 用于未来的一个建议：使用 service workers + 流
- 图片编码优化，尽量使用 svg 和字体图标

### 箭头函数与普通函数的区别

- 箭头函数中的 this 在编写代码的时候就已经确定了,及箭头函数本身所在的作用域,普通函数在调用时确定 this
- 箭头函数没有 `arguments`
- 箭头函数没有 `prototype`属性

### 浅拷贝

- 浅拷贝是值的赋值,对于对象是内存地址的赋值,目标对象的引用和原对象的引用指向的是同一块内存空间.如果其中一个对象改变,就会影响到另一个对象

### 深拷贝

- 深拷贝是将一个对象从内存中完整的拷贝一份出来,对象与对象间不会共享内存,而是在堆内存中心开辟一个空间去储存,所以修改心对象不会影响原对象

### 数组对象去重

```js
let arr = [
  { id: 1, name: 'aa' },
  { id: 2, name: 'cc' },
  { id: 3, name: '前端开发' },
  { id: 1, name: 'web前端' }
];
// 利用了map的特性
// Map的键实际上是一个和内存地址绑定的，只要内存地址不一样，就视为两个键。这样就解决了同名属性碰撞（clash）的问题。
const mp = new Map(
  arr.map((item) => {
    return [item['id'], item];
  })
);
console.log([...mp.values()]);
```

### 从浏览器地址栏输入 url 到显示页面的步骤

- 浏览器根据请求的 URL 交给 DNS 域名解析，找到真实 IP 向服务器发送请求
- 服务器交给后台处理完成后返回数据，浏览器接收文件（html，js，css，图像等）
- 浏览器对加载到的资源（HTML，JS, CSS）等进行语法解析，建立相应的内部数据结构（如 HTML 的 DOM）；
- 载入解析到资源文件，渲染页面，完成。

### MVC 和 MVVM 的区别

- 没有很大的区别，只是 MVC 是单项数据绑定，只绑定了数据，数据更改然后视图跟着渲染，而 MVVM 实现了双向数据绑定，在基础上多了一层视图更改，对应数据绑定也跟着更改。要从 MVC 到 MVVM 其实不难，一个 onchange 事件搞定，所以没有很大区别。

### 怎样理解单项数据流

- 这个概念出现在组件通讯。父组件是通过 prop 把数据传递到子组件的，但是这个 prop 只能由父组件修改，子组件不能修改，否则会报错。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收后，由子组件修改。

### require.context(string,Boolean, RegExp)【属于前端工程化】

- 参数 1: 读取文件的路径
- 参数 2: 是否遍历文件的子目录
- 参数 3: 匹配文件的正则

```js
const files = require.context('@/components/', true, /index.vue$/);

function registerComponent(fileData) {
  // fileData 是一个工厂函数
  // fileData.keys() 拿到的是每个可以匹配到的相对路径
  if (fileData) {
    let _mVant = {};
    fileData.keys().map((key) => {
      console.log(fileData(key)); //可以拿到当前模块， fileData(key).default: 可以拿到当前模块内的内容
      _mVant[fileData(key).default.name] = fileData(key).default;
    });
    return _mVant;
  }
}

const components = registerComponent(files);

export default components;
```

### import 和 require 的区别？

- 遵循规范的不同
  - require 是 AMD 规范引入
  - import 是 es6 的一个标准语法，如果要兼容浏览器的话必须转化成 es5 的语法
- 调用时间的不同
  - require 是运行时调用，所以 require 理论上可以运用在代码的任何地方
  - import 是编译时调用，所以必须放在文件开头
- 本质区别
  - require 是赋值过程，其实 require 的结果就是对象，数字，字符串，函数等，再把 require 的结果赋值给某个变量
  - import 是解构过程，我们在 node 中使用 babel 支持 es6，也仅仅是将 es6 转码为 ES5 再执行，import 语法会被转换成 require

### 封装的公共样式 Less

- 将变量提取为 variable.less 文件。将通用颜色挂载写入， 并通过 webpack 挂载到全局 `style-resources-loader`
- 封装 单行溢出，多行溢出，1px 问题
- 设置一些通用的东西，去掉浏览器默认样式等

### opacity:0, visibility:hidden,display:none 的区别？

- 空间占据
  - display：none 隐藏后不占据额外空间，它会产生回流和重绘
  - visibility：hidden 或 opacity：0 隐藏后会占用空间，只会发生重绘
- 子元素继承
  - display：none 不会被子元素继承， 父元素不在了，子元素肯定也不会显示
  - visibility：hidden 会被子元素继承， 子元素可以设置 visibility：visible； 使子元素显示出来。
  - opacity：0，也会被子元素继承，但是不能设置子元素 opacity：1，使其重新显示。
- 事件绑定
  - display：none 和 visibility：hidden 绑定的事件无法触发
  - opacity：0 绑定的事件是可以被触发
- 过渡动画
  - transition 对 display 和 visibility 是无效的。
  - 但是对于 opacity 是有效的。

## vue3 新增

> 为什么 vue3 的打包体积比 vue2.x 的小了很多？

- 有一部分原因是 tree shaking,删除了一部分全局的方法
- vue 将功能进行模块化， 在需要的时候去引入它

- 全局的 API tree shaking
  - 受到影响的 API
    - nextTick
    - observable(用 Vue.reactive 替换)
    - version
    - compile
    - set
    - delete
  - vue3 中所有的组件都是按需加载的，你想用某个组件 比如 nextTick,ref,toRefs, watch, computed 等 , 都是可以按需加载的。
- composition api
  - ref 接受一个内布置并返回一个响应式且可变的 ref 对象。ref 对象具有指向内部值得单个 property `value`
  - reactive 返回的是一个对象的响应式副本，直接就可以读取。
  - toRefs 可以将解构的数据转化成响应式
  - reactive + toRefs 形式，可以转化为跟 vue2.x 相似的写法
  - isRef 判断当前值是否是一个 Ref 对象
- proxy

## Vue3 和 vue2.62 的区别有哪些？

- 数据响应式的区别：vue3 使用 proxy，vue2 使用的是 Object.defaineProperty()
- 全局的 API 重构为 可以按需引入的实例
- 插件的安装方式不太一样，vue3 是要 createApp(App) 之后才可以 use 插件。而 vue2.x 通过 Vue.use() 就可以安装插件了。
- 一些普通的更改和一些不兼容语法的更改。
  - 比如生命周期的重命名
  - router 中写法的更改
  - v-model 的更改
  - composition API 的新增 setup()
  - style 标签中 vars 的添加

> 数据绑定的区别， vue2 使用的是 Object.defineProperty() ,Vue3 使用的是 Proxy 代理

### 在升级过程中 vue ，有的第三方库有没有遇到过什么问题？

- vue-count-to 这个第三方库不支持 ，需要将插件下载下来，手动更改一下 将 beforeDestory 修改为 beforeUnmount

### 样式中的 /deep/ 变成了 ::deep

- 样式中增加了 vars

```vue
<script>
export default {
  data() {
    return {
      color: 'red'
    };
  }
};
</script>

<style vars="{ color }">
.text {
  color: var(--color);
}
</style>
```

### Reflect 对象

- Reflect 对象与 Proxy 对象一样， 也是 ES6 为了操作对象而提供的新 API。
- Reflect.get(target, name, receiver): 查找并返回 target 对象的 name 属性，如果没有改属性，则返回 undefined。
- Reflect.set(target,name, value, receiver): 设置 target 对象的 name 属性等于 value

```js
// proxy代理
const target = {
  name: 'yang',
  sex: 'man'
};
const handler = {
  get(target, key) {
    console.log('获取名字');
    return Reflect.get(target, key);
  },
  set(target, key, value) {
    return Reflect.set(target, key, `强行设置为${value}`);
  }
};
const proxy = new Proxy(target, handler);
console.log(proxy.name);
// 在获取name属性是先进入get方法，在get 方法里面打印了获取名字/性别，然后通过 Reflect.get(target, key) 的返回值拿到属性值，相当于 target[key]
```

- proxy 会改变 target 中的 this 指向，一旦 Proxy 代理了 target，target 内部的 this 则指向了 Proxy 代理

```js
const target = new Date('2021-01-01');
const handler = {
  get(target, prop) {
    if (prop === 'getDate') {
      return target.getDate.bind(target); //重新绑定this指向
    }
    return Reflect.get(target, prop);
  }
};
const proxy = new Proxy(target, handler);
console.log(proxy.getDate());
```

### main.js 中的区别

```js
import App from './App.vue';
const app = createApp(App);
/**
 * 1.不能通过 vue.prototype 挂载全局属性
 *  如果想要在vue3中挂载全局属性，可以通过 app.config.globalProperties.$axios = axios 进行挂载全局属性， 官方不推荐挂载全局的属性
 *
 * 2. 创建方式不一样
 *  vue2中创建实例的方式： new Vue({}), vue 2可以在实例化之前去 .use() 使用vue插件
 *  在vue3中创建实例 const app = createApp(App),  vue3中 你必须先 createApp() 之后 ，才可以去.use() vue 的插件
 */
```

### router 中的差别

```js
// ========= 区别 1 ==========
// vue 2中的router
import Vue from  'vue'
import Router from 'vue-router'
export const constantRoutes = []
const createRouter = () =>
  new Router({
    mode: 'history'
    routes: constantRoutes
  })
export default createRouter

// vue3中的router
import { createRouter, createWebHashHistory } from 'vue-router'
const routes = []
const router = new createRouter({
  history: createWebHashHistory(),
  routes: routes
})
export default router

// ========= 区别 2 ==========
// *匹配所有页面的微小差别
// vue2中匹配所以页面的写法
const routes = [
  {
    path:'*',
    redirect: '/404',
    hidden: true
  }
]

// vue3中匹配所有页面的写法
const routes = [
  {
    path:'/:pathMatch(.*)*',
    redirect: '/404',
    hidden: true
  }
]

```

### 异步组件的使用(defineAsyncComponent)新增

```js
// vue2中的异步组件
Vue.component('async-example', function (resolve, reject) {
  setTimeout(function () {
    resolve({
      template: '<div>I am async!</div>'
    });
  }, 1000);
});
// 一个推荐的做法是将异步组件和 webpack 的 code-splitting 功能一起配合使用：
Vue.component('async-webpack-example', function (resolve) {
  // 这个特殊的 `require` 语法将会告诉 webpack
  // 自动将你的构建代码切割成多个包，这些包
  // 会通过 Ajax 请求加载
  require(['./my-async-component'], resolve);
});

// 可以在工厂函数中返回一个promise
Vue.component('async-webpack-example', () => import('./my-async-component'));

// 组件局部使用的时候
new Vue({
  components: {
    'my-component': () => import('./my-async-component')
  }
});

// vue3的异步组件
// defineAsyncComponent 方法可以接收一个对象，加载成功的时候的组件，正在加载时的组件和加载失败时候的组件，还有一些配置
import { defineAsyncComponent } from 'vue';
export default {
  components: {
    toolBox: defineAsyncComponent(() => import('./components/toolbox'))
  }
};
```

### `<keep-alive>` 不会在函数式组件中正常工作，因为它们没有缓存实例

### vue 3 使用 `router-view` 的差别

- v-slot 中解构的属性有:
  - href
  - route
  - navigate
  - isActive
  - isExactActive
  - Component

```html
<router-view v-slot="{ Component }">
  <keep-alive>
    <component :is="Component"></component>
  </keep-alive>
</router-view>
```

### 新增 Suspense 组件

```vue
<template>
  <Suspense>
    // 正常结果的组件
    <template #default>
      <async-comp />
    </template>

    // 还没有请求完成时显示的组件
    <template #fallback>
      <div>Loading...</div>
    </template>
  </Suspense>
</template>

<script>
import { onErrorCaptrued } from 'vue';
export default {
  name: 'App',
  setup() {
    // 可以捕获异常的钩子函数
    onErrorCaptured((error) => {
      console.log(error);
    });
  }
};
</script>

// 异步组件
<template>
  <div>
    这是个异步组件,结果为
    {{ result }}
  </div>
</template>

<script>
export default {
  async setup() {
    const resData = await getData();
    console.log(res);

    return { result: resData.data };
  }
};
</script>
```

### 新增 Teleport 组件

> 可以将组件挂载在 DOM 的任何地方

```js
// index.html
<div id="model"></div>


// 在组件中使用 有一个to属性
<teleport to="#model">
  <model-component />
</teleport>
```

### 插槽的区别

> vue3 中只保留了两种插槽，修改了 slot-scoped, 一种是具名插槽， 一种是带作用域的插槽

- 注意点
  - 默认插槽的缩写语法不能和具名插槽混用，这样会导致作用域不明确。

```vue

// =========== 方式一 (具名插槽) ============
// 设置具名插槽
<template>
  <slot name="header">
</template>

// 使用插槽
<template>
  //  使用 v-slot:header 或使用简写 #header
  <template #header>
  </template>
</template>

// =========== 方式二 (作用域插槽) ============
// 设置作用域插槽(可以拿到插槽内的数据去渲染)
<template>
  <div v-for="item in items">
    <slot name="header" :item="item">
  </div>
</template>

// 使用插槽, 点后面的属性跟的是自定义属性
<template>
  <template #header="slotProps">
    {{ slotProps.item }}
  </template>
</template>

// =========== 如果只有一个默认插槽的时候 ============


// 使用
<template>
  <div v-slot="slotProps">
    // 要插入的内容
  </div>
</template>

```

### Proxy 和 Object.defineProperty()的区别

- Proxy 代理的是整个对象，Object.defineProperty 只代理对象中的某一个属性
- 对象上定义新属性时，Proxy 可以监听到，Object.defineProperty 监听不到
- 数组上新增删除修改时，Proxy 可以监听到， Object.defineProperty 监听不到
- Proxy 不兼容 IE， Object.defineProperty 不兼容 IE8 及以下

### Vue 首屏优化

- 仔细考虑组件是否全局引入 （app.js）过大？
- 使用更轻量级的工具库
- CDN 优化，我们可以将 vue ，vue-router，vuex，axios 等使用 cdn 资源引入
- 开启 Gzip 压缩
- 路由懒加载

### 在 Vue 中怎么检测数组变化？

- vue 重写了这几个方法， push pop shift unshift
- this.$set

### Vue 怎么封装一个复用性比较高的组件

> 封装：求同存异

- 相同部分, 封装在一起
- 不同部分
  - 有两种方式:
    - 当不同部分变化的种类比较多时： 1.由外部来处理，可以通过插槽的方式，将不同的部分插入进去。
    - 当种类只有固定的几种时： 2.由内部来处理；写一个方法，将种类传进来 ，通过 v-if 的形式判断，渲染其中的一种，

### 在什么场景下会用到 slot

- 频繁的替换或更新时，可以使用 slot
- slot 相当于传递了一个组件给子组件

### 图片加载优化

- 减少文件体积大小，减少图片资源请求，
- 预加载

```js
var images = new Array();
function preload() {
  for (var i = 0; i < preload.arguments.length; i++) {
    images[i] = new Image();
    images[i].src = preload.arguments[i];
  }
}
preload('1.png', '2.png', '3.png');
```

- 懒加载， 按需加载。图片在页面渲染的时候先不加载，页面渲染完成后在指定动作触发后再加载图片.

- weakMap 使用场景在深拷贝中

- map() 没有 return 返回值 为 undefined
- sort() 默认会按着 ask 码来排序
- push() 返回值为当前 push 的元素

- contentHash 只打包更改的项目，不打包没有更改的项目。

#### 函数柯里化

```js
function currying(fn, arr = []) {
  let len = fn.length;
  return (...args) => {
    let concatArgs = [...arr, ...args];
    if (concatArgs.length < len) {
      return currying(fn, concatArgs);
    } else {
      return fn.call(this, ...concatArgs);
    }
  };
}
let sum = (a, b, c, d) => {
  // console.log(a, b, c, d);
  console.log(a + b + c + d);
};
let newSum = currying(sum);
newSum(1)(2)(3)(4);
```

#### 函数反柯里化

```js
Function.prototype.uncurring = function () {
  var self = this;
  return function () {
    var obj = Array.prototype.shift.call(arguments);
    return self.apply(obj, arguments);
  };
};
```

#### 手写深拷贝

- weakMap 的目的是为了循环引入 (比如 a.b = a)

```js
function deepClone(obj, map = new WeakMap()) {
  if (obj === null || typeof obj !== 'object') return obj;
  const type = Object.prototype.toSting().call(obj).slice(8, -1);
  let strategy = {
    Date: (obj) => new Date(obj),
    RegExp: (obj) => new RegExp(obj),
    Array: clone,
    Object: clone
  };

  function clone(obj) {
    if (map.get(obj)) return map.get(obj);
    let target = new obj.constructor();
    map.set(obj, target);
    for (let key in obj) {
      if (obj.hasOwnProperty(key)) {
        target[key] = deepClone(obj[key], map);
      }
    }
    return target;
  }
  return strategy[type] && strategy[type](obj);
}
```

#### js 中怎么使 if(aﾠ==1 && a== 2 && ﾠa==3) 返回 true？

```js
let a = {
  i: 1,
  toString: function () {
    return a.i++;
  }
};
```

- 通过 keep-alive 缓存的组件，在切换的时候不会被销毁，
- 怎么手写一个深拷贝
- v-model 响应式原理

### Vue 的缺点

- 首页白屏的情况
- 为什么会有这种情况？
  - Vue 在启动应用时，Vue 会对组件中的 data 和 computed 中状态值通过 Object.defineProperty 方法转化成 set,get 访问属性， 以便对数据变化进行监听。这一过程都是在启动应用时完成的，这也势必导致页面启动阶段比非 JS 驱动（如 jQuery 应用）的页面要慢一些

### 手机端页面首页首次加载白屏怎么处理

> 为什么会产生白屏？
>
> > 在 JS 代码解析完成之前，页面不会展示任何内容，就是所谓的白屏

1. SSR

   - 服务端渲染的好处
     - SEO
     - 加快内容展示

2. 预渲染

   - 在项目构建过程中，通过一些渲染机制， 比如 puppeteer 或者 jsdom 将页面在构建的过程中就渲染好，然后插入到 html 中，这样页面启动之前首先看到的就是预渲染的页面了。
   - 预渲染并不会把异步加载的数据在构建文件的过程中就渲染好，而是把每个页面静态的那部分提前在构建的时候渲染出来

3. 骨架屏
   - 骨架页面 指的是当你打开一个移动端 web 页面， 在页面解析和数据加载之前，首先给用户展示页面的大概样式。在骨架页面中，图片，文字，图标都将通过灰色矩形或圆形块来战士，在真实页面展示之前，用户能够感知到即将加载页面的基本 css 样式和页面布局。

### 浏览器的缓存机制

- 强缓存
- 协商缓存
- 不缓存

### 怎么处理高并发情况？ （比如 1000 张图片要同时上传）

### flex: 1; 是 flex-group ，flex-shrink，flex-basis 三个属性的缩写

- flex: 1 其实全写 是： flex: 1 1 auto;
- flex-group 定义项目的放大比例 （默认 0）
- flex-shrink 定义项目的缩小比例 （默认 1）
- flex-basis 定义分配多余空间之前，项目占据的主轴空间，根据此属性 计算主轴是否有多余空间 （默认 auto）

### 怎么将[1,2,[3,4,[5,6,7],[8,9]],10,11] 变成 [1,2,3,4,5,6,7,8,9,10,11]

```js
// const flattenDeep = (array) => array.flat(Infinity)

let arr = [1, 2, [3, 4, [5, 6, 7], [8, 9]], 10, 11];
function newArray() {
  while (arr.some((item) => Array.isArray(item))) {
    console.log(arr);
    arr = [].concat(...arr);
  }
  let setlist = new Set([...arr]);
  return arr;
}

newArray();
console.log(arr);

// 使用递归的方法
const ans = [];
var flaten = function (nums) {
  if (typeof nums == 'number') {
    return nums;
  }
  nums.forEach((e) => {
    let tmp = flaten(e);
    if (tmp !== null) {
      ans.push(tmp);
    }
  });
};
```

### JSON.parse(JSON.stringify()) 深拷贝的问题

- 弊端

  1. 如果 obj 里面有时间对象，则 JSON.stringify 后再 JSON.parse 的结果 ，时间将知识字符串的形式，而不是对象的形式。
  2. 如果 obj 里有 RegExp，Error 对象，序列化的结果只得到空对象
  3. 如果 obj 里有函数，undefined，则序列化的结果会把函数或 undefined 丢失
  4. 如果对象里有 NaN,infinity 和-Infinity，序列化的结果会变成 null
  5. JSON.stringify()只能序列化对象的可枚举的自有属性，例如 如果 obj 中的对象是有构造函数生成的，则使用 JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的 constructor
  6. 如果对象中存在循环引用的情况也无法正确实现深拷贝

- 浅拷贝：
  - 只会讲对象的各属性进行依次复制，并不会递归复制。
- 深拷贝：
  - 不仅将原对象的各属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深拷贝的方法递归复制到新对象上

```js
function deepClone(obj, map = new WeakMap()) {
  if (obj === null || typeof obj !== 'object') return obj;
  const type = Object.prototype.toString.call(obj).slice(8, -1);
  let strategy = {
    Date: (obj) => new Date(obj),
    RegExp: (obj) => new RegExp(obj),
    Array: clone,
    Object: clone
  };

  function clone(obj) {
    if (map.get(obj)) return map.get(obj);
    let target = new obj.constructor();
    map.set(obj, target);
    for (let key in obj) {
      if (obj.hasOwnProperty(key)) {
        target[key] = deepClone(obj[key], map);
      }
    }
    return target;
  }
  return strategy[type] && strategy[type](obj);
}
```
