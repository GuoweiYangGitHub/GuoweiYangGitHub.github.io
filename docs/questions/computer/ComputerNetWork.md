# 计算机网络

## 常用code码

- 200 - 请求成功
- 301 - 永久重定向
- 302 - 临时重定向
- 304 - 自从上次请求后，请求网页未修改- 过，服务器返回响应，不返回内容（从缓存中读取）
- 400 - 服务器不理解请求的语法
- 403 - Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求
- 404 - 请求的资源（网页等）不存在
- 413 - 请求体过大，超出服务器的处理能力上限
- 414 - 请求url太长，服务器无法处理
- 500 - 内部服务器错误
- 502 - Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应

## 浏览器缓存

### 浏览器缓存的意义

- 避免了冗余的数据传输，节省流量
- 加快了用户访问速度
- 减小了服务器的压力

### 浏览器缓存策略

- 第一次请求数据时，浏览器没有对应的缓存数据，此时需要请求服务器，服务器返回数据后，会把请求数据缓存。
- 当浏览器有缓存数据后，可以根据是否向服务器发送请求，将缓存类型分为： 协商缓存与强缓存

#### 强缓存

- 命中缓存后，不会向服务器发送请求,直接从本地获取。返回的状态码为 200(from disk cache) 或 200（from memory cache）

#### 协商缓存

- 缓存过期，浏览器会向服务器发送请求，协商对比服务端和本地的资源，验证本地资源是否失效。若服务器资源与本地资源相同，则命中缓存，返回304，否则直接请求服务器资源。
- 协商缓存的响应结果，不仅验证资源的有效性，同时还会更新浏览器缓存
- Age:0 表示命中了代理服务器的缓存, age 值为 0 表示代理服务器刚刚刷新了一次缓存.

#### 强缓存与协商缓存的关系

- 相同点： 强缓存与协商缓存在命中缓存资源后都是从本地读取资源。
- 不同点：
  - 如果强缓存生效，不需要再向服务端发起请求。
  - 协商缓存，不管是否使用缓存，必须向服务器发送一个请求来协商。

#### 优先级

- 两类缓存规则同时存在的情况下， `强缓存 > 协商缓存`
- 当执行强缓存的规则时，如果缓存生效，直接使用缓存，不再执行协商缓存规则。如果强制缓存规则不生效，则需要进行协商缓存判断

#### 总结

- 浏览器第一次请求数据时，浏览器缓存中没有对应的缓存数据，此时需要请求服务器，浏览器返回数据后，会把请求数据缓存。
- 浏览器再次访问同一url，则会根据请求资源是否过期向服务器发送不同请求，此时分为强缓存和协商缓存。
- 若资源未过期（expires和cache-control）时，命中缓存，不会向服务器发送请求，直接从缓存中读取。
- 若资源显示过期（if-modified-since/Last-Modified）和（if-none-match/Etag），则会向服务器发送请求，协商对比服务器资源，验证是否失效。若相同，命中协商缓存，返回304，否则直接请求服务器。

#### 清除浏览器缓存

- meta标签中令`cache-control`为`no-cache`或者`expires`为`0`

```js
//不缓存
<meta http-equiv="Cache-Control" content="no-cache, must-revalidate">
<meta http-equiv="expires" content="0">
```

### 哪些不能被浏览器缓存

1. http头中cache-control为no-cache或者为max-age: 0
2. 需要根据cookie，和输入内容的动态请求
3. 经过https加密的请求
4. post请求不可以被缓存
5. http响应头中不含Last-Modified/Etag，也不包含Cache-Control/Expires的请求无法被缓存

## 浏览器原理

### 在浏览器中输入一个网址到页面展示，会经历什么？（重要）

[传送门](https://www.zhihu.com/question/440812545/answer/2379426038)

1. 浏览器输入url
2. 查找缓存： 浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有，则显示该页面，没有则进行下一步.
3. DNS域名解析： 浏览器向dns服务器发送请求，解析该URL域名中对应的ip地址。（dns服务器是基于UDP的，因此会用到UDP协议）
4. 建立TCP连接：解析出IP地址后，根据IP地址和默认的端口，和服务器建立TCP连接。
5. 发起http请求： 浏览器发起读取文件的http请求，改请求作为TCP三次握手的第三次数据发送给服务器
6. 服务器响应并返回结果： 服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器
7. 关闭TCP连接： 通过四次挥手释放TCP连接
8. 浏览器渲染： 客户端解析html内容并渲染出来
   1. 构建dom树：词法分析然后解析成dom树（dom tree），是由dom元素及属性节点组成，树的跟是document对象
   2. 构建css规则树： 生成css规则树（CSS Rule Tree）
   3. 构建render树： 浏览器将dom和CSSOM结合，并构建出渲染树（render Tree）
   4. 布局（Layout）：计算出每个节点在屏幕中的位置
   5. GPU绘制（Painting）：遍历render树，并使用UI后端层绘制每个节点

### TCP的三次握手和四次挥手

#### 三次握手

- 客户端向服务端发送syn请求包，询问服务端能不能收到请求
- 服务端接收后向客户端发送ack确认包，告诉客户端能收到
- 客户端向服务端发送ack确认包，告诉服务端我也能收到，然后客户端进入准备状态，服务器接收后也进入准备状态。

#### 四次挥手

- 客户端向服务端发送fin请求包，告诉服务端要断开连接
- 服务端收到后发送ack确认包告诉客户端收到了断开请求
- 服务端有未传完的数据会继续传完，然后向客户端发送fin请求包，告诉客户端可以断开连接了
- 客户端收到后向服务端发送ack确认包，然后客户单断开连接，服务端收到后也断开连接

### 浏览器的重绘、重排/回流

- 重排/回流（Reflow）: 当dom变化影响元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为：重新生成布局，重新排列元素。
- 重绘(Repaint): 当一个元素外观发生改变，但没有改变布局，重新把元素外观绘制出来的过程，叫重绘。表现为某些元素的外观被改变

#### 如何触发重排和重绘？

- 重排
  - 触发条件:
    - 增.删.改.移 DOM
    - 修改 CSS 样式
    - 改变浏览器窗口的大小
    - 页面滚动
    - 修改网页的默认字体
    - 获取一些 style 信息时 ,offsetWidth, offsetHeight, ...
- 重绘
  - 触发条件:
    - DOM 改动
    - CSS 某些改动样式的改动,比如 颜色

#### 如何避免重排重绘？

- `集中改变样式`，不要一条一条地修改 DOM 的样式
- `不要把 DOM 节点的属性值放在循环里当成循环里的变量`。
- `动画元素使用定位`，那么修改他们的CSS时是不会重排的。
- `不使用 table 布局`。
- `尽量只修改定位元素`。例如`position：absolute`或fixed元素，对其他元素影响不大
- 动画`开启GPU加速`，translate使用3D变化

## OSI七层模型

- （1）应用层 （**为计算机用户提供应用接口或网络服务**。网络协议： HTTP,HTTPS,FTP,POP3,SMTP）
- （2）表示层 （提供应用层数据的加密**例如base64、ase加密**）
- （3）会话层 （负责**建立、管理、终止表示层之间的通信**）
- （4）传输层 （为上层协议**提供端到端的数据传输服务**）
- （5）网络层 （通过IP寻址**建立两个节点之间的连接**）
- （6）数据链路层 （将比特组合成字节，再将字节组合成帧，使用链路层地址访问介质，并进行差错检测。）
- （7）物理层 （最终信号的传输。通过物理介质传输比特流**网线、中继器**）

### https的加密是在ISO七层模型中的哪一层？

- https的加密在OSI 七层模型中的`表示层`。

## http、http2、https

### HTTP 报文的组成部分

- 请求报文: 请求行 请求头 空行 请求体
- 响应报文: 状态行 响应头 空行 响应体
  - 请求头: HTTP 方法,页面地址,http 协议及版本
  - 请求头: key-value 值,告诉服务端需要的内容
  - 空行: 告知服务端一下内容为请求体
  - 请求体: 数据部分

### https

- https是通过tls对数据进行了加密，使用了对称加密(AES)和非对称加密(RSA)

### http2和http的区别

- http1同时只能请求6个连接，而http2实现了多路复用，可以复用一个tcp连接。
- http1通过文本方式传输数据，http2通过二进制传输。
- https2对header进行了压缩。
- http2可以由服务端push推送。

### https和http的区别

- 安全方面：http使用的是`无状态和明文传输`。而https实际上是`http+ssl协议组成的加密传输协议`
- 响应速度： 理论上http响应速度更快，只需要三次握手；而https则在三次握手的情况下，还需要一次ssl握手
- 端口： http默认是`80`端口，而https默认端口是`443`
- 消耗资源方面：https是构建在ssl之上的协议，所以https会消耗更多的服务资源。
- 展示方面： https会在浏览器上面加上一个绿色的锁。

## UDP和TCP

> 与TCP相比，UDP更轻便，不需要经历建立连接和断开连接的阶段，适合直播。

- TCP三次握手：
  - 客户端向服务端发送syn请求包，询问服务端能不能收到请求
  - 服务端接收后向客户端发送ack确认包，告诉客户端能收到
  - 客户端向服务端发送ack确认包，告诉服务端我也能收到，然后客户端进入准备状态，服务器接收后也进入准备状态。

- TCP四次挥手：
  - 客户端向服务端发送fin请求包，告诉服务端要断开连接
  - 服务端收到后发送ack确认包告诉客户端收到了断开请求
  - 服务端有未传完的数据会继续传完，然后向客户端发送fin请求包，告诉客户端可以断开连接了
  - 客户端收到后向服务端发送ack确认包，然后客户单断开连接，服务端收到后也断开连接

## 前后端的通信有哪些

- ajax: 同源下的通信
- WebSocket: 不受同源策略限制
- CORS: 支持跨域通信,也支持同源通信

## 跨域的解决方案有哪些(协议，域名，端口)

- 1.jsonp 跨域
- 2.location.hash 跨域
- 3.postMessage 跨域
- 4.WebSocket 跨域
- 5.CORS 跨域(后台设置响应头)
- 6.反向代理(在 vue 中经常用到)
- nginx 代理

## 垃圾回收机制

- `标记清除法清除`(现代浏览器都使用的是标记清除法)

  - 此算法假定设置一个叫做根(root)的对象, 在(js 中,根是全局对象 window),定期的让垃圾回收器从根开始,找到所有从根开始引用的对象, 然后找到这些对象的引用对象, 从根开始,垃圾回收器将找到所有可以获得的对象和所有不能获得的对象
