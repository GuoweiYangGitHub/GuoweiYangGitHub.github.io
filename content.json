{"meta":{"title":"一昂杨丶","subtitle":"山中何事？松花酿酒，春水煎茶。","description":"山中何事？松花酿酒，春水煎茶。","author":"一昂杨丶","url":"https://guoweiyanggithub.github.io","root":"/"},"pages":[{"title":"categories","date":"2019-03-13T02:31:15.000Z","updated":"2019-03-13T02:32:38.028Z","comments":false,"path":"categories/index.html","permalink":"https://guoweiyanggithub.github.io/categories/index.html","excerpt":"","text":""},{"title":"photos","date":"2019-03-14T07:31:22.000Z","updated":"2019-03-14T08:48:42.209Z","comments":false,"path":"photos/index.html","permalink":"https://guoweiyanggithub.github.io/photos/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-03-13T02:38:41.000Z","updated":"2019-03-15T06:26:39.204Z","comments":true,"path":"tags/index.html","permalink":"https://guoweiyanggithub.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"贪吃蛇小游戏","slug":"贪吃蛇小游戏","date":"2019-03-20T07:13:17.000Z","updated":"2019-03-20T07:20:26.207Z","comments":true,"path":"2019/03/20/贪吃蛇小游戏/","link":"","permalink":"https://guoweiyanggithub.github.io/2019/03/20/贪吃蛇小游戏/","excerpt":"","text":"贪吃蛇小游戏代码直接复制粘贴直接用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245 Document html,body { margin: 0; padding: 0; background-color: #333; } .content { width: 900px; height: 500px; margin: 0 auto; background-color: #f0f0f0; margin-top: 40px; margin-bottom: 10px; position: relative; } .start { text-align: center; } .start-game { width: 100px; height: 50px; margin: 0 auto; } 点击开始游戏 let beforeFood //表示一个之前的food dom let box = document.querySelector('.content') let btn = document.querySelector('.start') // 创建食物的类 class Food { constructor(options) { options = options || {} this.width = options.width || 20 this.height = options.height || 20 this.x = options.x || 0 this.y = options.y || 0 this.color = options.color || this._randomColor() } // 食物的渲染函数 render(box) { // 先删除之前创建的食物 if(beforeFood) { box.removeChild(beforeFood) } // 再创建一个食物 let newFood = document.createElement('div') beforeFood = newFood //让这个食物赋值给外面的food newFood.style.width = `${this.width}px` newFood.style.height = `${this.height}px` newFood.style.backgroundColor = this.color newFood.style.borderRadius = '20px' newFood.style.position = 'absolute' box.appendChild(newFood) //加入到 content 里面 this.x = this._randomPosition(0, box.offsetWidth / newFood.offsetWidth - 1) * newFood.offsetWidth this.y = this._randomPosition(0, box.offsetHeight / newFood.offsetHeight - 1) * newFood.offsetHeight newFood.style.left = `${ this.x }px` newFood.style.top = `${ this.y }px` } // 内置函数,随机获取一种颜色 _randomColor() { return `rgb(${Math.floor(Math.random()*256)},${Math.floor(Math.random()*256)},${Math.floor(Math.random()*256)})` } // 内置函数,随机一个位置 _randomPosition(min,max) { return Math.floor(Math.random() * (max - min + 1)) + min; } } // 创建蛇的类 class Snake { constructor(options) { options = options || {} this.width = options.width || 20 this.height = options.height || 20 this.direction = options.direction || 'right' //默认的方向 this.body = [ {x:4,y:4}, {x:3,y:4}, {x:2,y:4}, {x:1,y:4}, ] this._arr = [] } // 将snake渲染到页面上 render(box) { // 先删除 this.remove(box) this.body.forEach( (item,i) => { let snakeBody = document.createElement('div') this._arr.push(snakeBody) //这个是添加数组 snakeBody.style.width = `${this.width}px` snakeBody.style.height = `${this.height}px` snakeBody.style.position = `absolute` if(i % 2 === 0) { if(i === 0) { snakeBody.style.backgroundColor = `red` }else { snakeBody.style.backgroundColor = `#fff` } }else { snakeBody.style.backgroundColor = `#333` } snakeBody.style.border = `1px solid red` snakeBody.style.borderRadius = `20px` snakeBody.style.left = `${ item.x * this.width }px` snakeBody.style.top = `${ item.y * this.height }px` box.appendChild(snakeBody) //这个是添加dom }) } // 蛇的移动 move() { for(let i = this.body.length - 1; i > 0; i--) { this.body[i].x = this.body[i - 1].x this.body[i].y = this.body[i - 1].y } // 判断,通过按着不同的按钮给不同的 switch (this.direction) { case 'left': this.body[0].x -= 1 break; case 'top': this.body[0].y -= 1 break; case 'right': this.body[0].x += 1 break; case 'bottom': this.body[0].y += 1 break; default: break; } } // 先删除最后一个 remove(box) { for(let i = 0,len = this._arr.length; i < len; i++) { box.removeChild(this._arr[0]) this._arr.splice(0, 1) } } } // 创建游戏的类 class Game { constructor(box) { this.box = box this.food = new Food() this.snake = new Snake() this._score = 0 this._id; } // 游戏开始的函数 start() { this.food.render(this.box) this.snake.render(this.box) this.autoMove() // 键盘监听事件 document.onkeydown = (e) => { switch (e.keyCode) { case 37: // 判断是否按下去的键是否跟移动的方向是一样的,如果一样, return if(this.snake.direction === 'right') return this.snake.direction = 'left' break; case 38: if(this.snake.direction === 'bottom') return this.snake.direction = 'top' break; case 39: if(this.snake.direction === 'left') return this.snake.direction = 'right' break; case 40: if(this.snake.direction === 'top') return this.snake.direction = 'bottom' break; default: throw new Error(`只能按上下左右`) } } } // 自动移动事件 autoMove() { this._id = setInterval(() => { this.snake.move() // 判断是否撞墙 let flag = this.isGameOver() if(flag) return let head = this.snake.body[0] // 判断是否吃到食物 if(head.x * this.snake.width === this.food.x && head.y * this.snake.height === this.food.y) { // 重新渲染 this.food.render(box) this._score++ // 让蛇变长 let last = this.snake.body[this.snake.body.length - 1] this.snake.body.push({ x : last.x, y : last.y }) } // 重新渲染蛇皮 this.snake.render(box) }, 150); } // 判断是否撞墙 isGameOver() { let head = this.snake.body[0] let maxX = this.box.offsetWidth / this.snake.width - 1 let maxY = this.box.offsetHeight / this.snake.height - 1 if(head.x < 0 || head.y < 0|| head.x > maxX || head.y > maxY) { clearInterval(this._id) alert(`游戏结束,得分为 ${ this._score } ,请再接再厉!!`) return true } } } // 点击开始按钮, 让游戏开始 btn.addEventListener('click',function(){ var game = new Game(box) game.start() })","categories":[{"name":"js写小游戏","slug":"js写小游戏","permalink":"https://guoweiyanggithub.github.io/categories/js写小游戏/"}],"tags":[{"name":"贪吃蛇小游戏","slug":"贪吃蛇小游戏","permalink":"https://guoweiyanggithub.github.io/tags/贪吃蛇小游戏/"}]},{"title":"通过hexo快速搭建博客","slug":"通过hexo快速搭建博客","date":"2019-03-11T07:46:18.000Z","updated":"2019-03-15T06:36:11.470Z","comments":true,"path":"2019/03/11/通过hexo快速搭建博客/","link":"","permalink":"https://guoweiyanggithub.github.io/2019/03/11/通过hexo快速搭建博客/","excerpt":"","text":"windows系统使用hexo快速搭建blog前提环境准备环境(都有的话可以直接跳过): node环境 github账号 域名(可选) git环境 一.node环境https://www.cnblogs.com/zhouyu2017/p/6485265.html 二.github账号打开 http://github.com 右上角有sign up ,点击进去, 然后注册你的用户名, 邮箱和密码即可.注意, 邮箱需要验证 三.域名可以到阿里云里面 https://www.aliyun.com 可以用支付宝账号进行登录,登录进去之后 搜索域名注册 可以选.com类型的域名或.cn之类的域名, 任意点一个进去之后就搜索自己喜欢的域名即可, 点击加入购物车, 结算购物车, 付款即可.然后在你的控制台里面的域名注册里就有你购买的域名了 四.git环境https://www.cnblogs.com/ximiaomiao/p/7140456.html 开始搭建一.在github上新建一个项目 登录github账号 右上角头像旁边有一个加号 点击之后出来一个框 点new repository repository name 名字必须是 你的github名.github.io(例如:你的github用户名为 lanmaom, 则必须为 : lanmaom.github.io) description(描述你可以随便写) 下面有一个public和private 选择 public这个选项, 勾选中 Initialize this repository with a README 然后点击 create repository 创建成功 二.将github与git绑定https://blog.csdn.net/hc_ttxs/article/details/79375788 注意: 1.在本地创建ssh key ,就是在你输入ssh-keygen -t rsa -C \"your_email@youremail.com这个命令的时候,在 安装git 的目录里git bash 2.关于User文件夹对应的用户下创建.ssh文件夹,是在全局文件, C盘-> User(或’用户’) -> 你的电脑名字 -> .ssh文件夹, 找到 id_rsa.pub 文件,ctrl + a 全部复制,然后粘贴到你的github 中的settings里 3.验证是否绑定本地成功, 直接输入 ssh -T git@github.com,直接复制这个命令, 最后设置全局的用户名和邮箱就可以了 4.然后设置仓库别名 git remote 你的仓库别名(一般可以写origin) 你的github仓库地址(注意,是ssh的地址,不是https的地址) 5.然后就把通过 ssh 地址 克隆到本地文件,要克隆到哪个文件夹,就在当前文件夹git bash ,然后输入 git clone 你的ssh仓库地址 三.初始化hexo(并设置想要的皮肤) 下载 hexo1npm i -g hexo 初始化(如果初始化不了,需要到一个空的文件夹下面初始化,初始化完成之后再复制进去即可)1hexo init 然后编译1hexo g 预览一下1hexo s 自带的皮肤挺丑,换一个皮肤的话,在当前目录的 themes文件夹下面,我用的 diaspora 皮肤1git clone https://github.com/Fechin/hexo-theme-diaspora.git diaspora 然后在最外面的_config.yml 文件的 theme中 写上 diaspora, 注意,名称前面一定要有一个空格, 没有空格会有问题,详细可到hexo官网去看https://hexo.io/zh-cn/docs/configuration 1theme: diaspora 其他的,你需要配置一下你的路径 1234567891011#Site 里配置一下timezone(是在哪个时间分区,北京,上海,纽约还是哪里)timezone: Asia/Shanghai#URL选项中url: 你的github地址(例如:https://lanmaom.github.io)#Deployment中deploy: type: git repository: git@github.com:lanmaom/lanmaom.github.io.git branch: master 四.绑定域名 win + R 打开运行窗口 输入 cmd 回车 ping 你的github名.github.io 例如: 1ping lanmaom.github.io 然后你就会得到一个ipv4地址,多ping几下, 是不是一样的(一般都是一样的) 打开你的阿里云控制台域名->解析 ->新手引导->输入你ping的ipv4地址 ->确定 -> 确定 然后在 source目录下新建一个CNAME文件,注意: 不是 CNAME.txt,没有后缀, 然后再在CNAME文件里面写入你的域名.例如 1lanmaom.com 域名已经设置好了,试一下: 1234$ hexo g //编译如果编译的时候报了:ERROR Deployer not found: git原因:需要再安装一个插件 npm install hexo-deployer-git --save$ hexo d //上传 输入你的域名,就可以访问了, 如果你没有绑定域名, 输入你的 github名.github.io 访问 五.配置你的主题和 你的网站icon 你可以到iconfont库里面找一个图标, 也可以自己设计 网站 :https://www.iconfont.cn/ 找到之后,png下载下来 然后通过 https://www.easyicon.net/covert/ 网站进行转icon , 上传文件之后,选 microsoft.icon,尺寸的话选 32 x 32的就好 下载之后,把文件放入 最外面(博客的) source 文件夹(注意:不是主题的source文件夹里面) -> img文件夹(如果没有新建一个) -> 放入你的ico图片 ,然后再配置 landscape文件目录下面的_config.yml文件 1favicon: img/你的icon名.ico 重新编译上传即可 六.写文章1hexo new 'my-first-blog' 1.在md文件里的配置项 123456789101112---title: postName #文章页面上的显示名称，一般是中文date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: 默认分类 #分类tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面mp3: 当前页面播放的歌曲cover: 当前显示的图片---以下是正文 2.最后,编译上传 详细请参照我的另一个博客 http://lanmaom.com","categories":[{"name":"blog","slug":"blog","permalink":"https://guoweiyanggithub.github.io/categories/blog/"}],"tags":[{"name":"通过hexo快速搭建博客","slug":"通过hexo快速搭建博客","permalink":"https://guoweiyanggithub.github.io/tags/通过hexo快速搭建博客/"}]},{"title":"vue生命周期","slug":"vue生命周期","date":"2019-03-08T08:01:20.000Z","updated":"2019-03-14T01:49:06.516Z","comments":true,"path":"2019/03/08/vue生命周期/","link":"","permalink":"https://guoweiyanggithub.github.io/2019/03/08/vue生命周期/","excerpt":"","text":"实例生命周期 所有的 Vue 组件都是 Vue 实例，并且接受相同的选项对象即可 (一些根实例特有的选项除外)。 实例生命周期也叫做：组件生命周期 生命周期介绍 vue生命周期钩子函数 简单说：一个组件（实例）从开始到最后消亡所经历的各种状态，就是一个组件（实例）的生命周期 生命周期钩子函数的定义：从组件被创建，到组件挂载到页面上运行，再到页面关闭组件被卸载，这三个阶段总是伴随着组件各种各样的事件，这些事件，统称为组件的生命周期函数！ 开发人员可以通过Vue提供的钩子函数，让我们写的代码参与到Vue的生命周期里面来，让我们的代码在合适的阶段起到相应的作用。 注意：Vue在执行过程中会自动调用生命周期钩子函数，我们只需要提供这些钩子函数即可 注意：钩子函数的名称都是Vue中规定好的！ 钩子函数 - beforeCreate() 说明：在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用 注意：此时，无法获取 data中的数据、methods中的方法 钩子函数 - created() 注意：这是一个常用的生命周期，可以调用methods中的方法、改变data中的数据 vue实例生命周期 参考1 vue实例生命周期 参考2 使用场景：发送请求获取数据 钩子函数 - beforeMounted() 说明：在挂载开始之前被调用 钩子函数 - mounted() 说明：此时，vue实例已经挂载到页面中，可以获取到el中的DOM元素，进行DOM操作 钩子函数 - beforeUpdated() 说明：数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。 注意：此处获取的数据是更新后的数据，但是获取页面中的DOM元素是更新之前的 钩子函数 - updated() 说明：组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。 钩子函数 - beforeDestroy() 说明：实例销毁之前调用。在这一步，实例仍然完全可用。 使用场景：实例销毁之前，执行清理任务，比如：清除定时器等 钩子函数 - destroyed() 说明：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 axios Promise based HTTP client for the browser and node.js 以Promise为基础的HTTP客户端，适用于：浏览器和node.js 封装ajax，用来发送请求，异步获取数据 安装：npm i -S axios axios 推荐 vue-resource 原来推荐使用，现在不推荐 123456789101112131415161718192021222324252627282930// 在浏览器中使用，直接引入js文件使用下面的GET/POST请求方式即可// 1 引入 axios.js// 2 直接调用axios提供的API发送请求created: function () { axios.get(url) .then(function(resp) {})}// 配合 webpack 使用方式如下：import Vue from 'vue'import axios from 'axios'// 将 axios 添加到 Vue.prototype 中Vue.prototype.$axios = axios// 在组件中使用：methods: { getData() { this.$axios.get('url') .then(res => {}) .catch(err => {}) }}// API使用方式：axios.get(url[, config])axios.post(url[, data[, config]])axios(url[, config])axios(config) Get 请求1234567891011121314151617181920212223242526const url = 'http://localhost:8899/api/getnewslist'// url中带有query参数axios.get('/user?id=89') .then(function (response) { console.log(response) }) .catch(function (error) { console.log(error) })// url和参数分离，使用对象axios.get('/user', { params: { id: 12345 }})// axios() 直接发送get请求axios({ method: 'get', url: 'http://localhost:8899/api/getnewslist',}) .then(res => { console.log(res) }) Post 请求 OPTIONS 预检请求 不同环境中处理 POST请求 默认情况下，axios 会将JS对象序列化为JSON对象（此时的 Content-Type为：application/json 而这个类型会导致预检请求）。为了使用 application/x-www-form-urlencoded 格式发送请求，我们可以这样： 123456789// 使用 qs 包，处理将对象序列化为字符串// 注意：在浏览器环境中，需要通过引入 qs.js 以后，然后，通过 Qs 来使用~// npm i -S qs// var qs = require('qs')import qs from 'qs'axios.post('/foo', qs.stringify({ 'bar': 123 }))// 或者：axios.post('/foo', 'bar=123&age=19') 1234567891011121314151617181920212223const url = 'http://localhost:8899/api/postcomment/17'axios.post(url, 'content=写的一手好段子')axios.post('/user', qs.stringify({ firstName: 'Fred', lastName: 'Flintstone' })) .then(function (response) { console.log(response) }) .catch(function (error) { console.log(error) })// axios() 直接发送post请求axios({ method: 'post', url: 'http://localhost:8899/api/postcomment/17', data: 'content=' + this.txt}) .then(res => { console.log(res) }) 全局配置12// 设置请求公共路径：axios.defaults.baseURL = 'http://localhost:8899' 拦截器 拦截器会拦截发送的每一个请求，请求发送之前执行request中的函数，请求发送完成之后执行response中的函数 1234567891011121314151617181920// 请求拦截器axios.interceptors.request.use(function (config) { // 所有请求之前都要执行的操作 return config }, function (error) { // 错误处理 return Promise.reject(error) })// 响应拦截器axios.interceptors.response.use(function (response) { // 所有请求完成后都要执行的操作 return response }, function (error) { // 错误处理 return Promise.reject(error) }) 自定义指令 作用：进行DOM操作 使用场景：对纯 DOM 元素进行底层操作，比如：文本框获得焦点 vue 自定义指令用法实例 两种指令：1 全局指令 2 局部指令 全局指令1234567891011// 第一个参数：指令名称// 第二个参数：配置对象，指定指令的钩子函数Vue.directive('directiveName', { bind() {}, update() {}})Vue.directive('directiveName', function() {})Vue.directive('red', function(el, binding) { el.style.color = binging.value}) 指令的钩子函数 bind 和 inserted 的区别 123456789// DOM对象还没有插入到页面中// bind中只能对元素自身进行DOM操作，而无法对父级元素操作bind(el) { console.log(el.parentNode) // null},// inserted这个钩子函数调用的时候，当前元素已经插入页面中了，也就是说可以获取到父级节点了inserted(el) { console.log(el.parentNode) // ...}, update 和 componentUpdated 的区别 123456789// DOM重新渲染前update(el) { console.log('update:', el.innerHTML)},// DOM重新渲染后componentUpdated(el) { console.log('componentUpdated: ', el.innerHTML)}, 案例：1 模拟v-text 2 模拟v-on:click.prevent 局部指令12345{ directives: { directiveName: {} }} vue 剖析Vue原理&实现双向绑定MVVM 组件 组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树 创建组件的两种方式：1 全局组件 2 局部组件 Vue实例中的配置项（如：methods、filters、watch、computed、directives、生命周期钩子函数）都可以在组件中使用 全局组件 说明：全局组件在所有的vue实例中都可以使用 注意：先注册组件，再初始化根实例 注意：组件中的 data 必须是函数 12345678910111213141516171819// 1 注册全局组件Vue.component('my-component', { template: 'A custom component!', data() { return { msg: '注意：组件的data必须是一个函数！！！' } }})// 2 使用：以自定义元素的方式 // =====> 渲染结果 A custom component! template属性的值可以是： 1 模板字符串 2 模板id 123456 A custom component!template: '#tpl' extend：使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。 123456789101112// 注册组件，传入一个扩展过的构造器Vue.component('my-component', Vue.extend({ /* ... */ }))// 注册组件，传入一个选项对象 (自动调用 Vue.extend)Vue.component('my-component', { /* ... */ })// 内部执行过程：const Home = Vue.extend({ template: '', data() {}})Vue.component('home', Home) 局部组件 说明：局部组件，是在某一个具体的vue实例（组件）中定义的，只能在这个vue实例（组件）中使用 1234567891011const Child = { template: 'A custom component!'}new Vue({ // 注意：此处为 components components: { // 将只在当前vue实例中使用 'my-component': Child }}) 组件通讯父组件到子组件 方式：通过props属性来传递数据 注意：属性的值必须在组件中通过props属性显示指定，否则，不会生效 说明：传递过来的props属性的用法与data属性的用法相同 12345678910111213 components: { hello: { // 显式创建props及其传递过来的属性 props: ['msg', 'myMsg'], template: '这是 hello 组件，这是消息：{{msg}} --- {{myMsg}} ' } } 子组件到父组件 方式：父组件给子组件传递一个函数，由子组件调用这个函数 说明：借助vue中的自定义事件（v-on:cunstomFn=”fn”） $emit()：触发事件 12345678910111213141516171819202122 new Vue({ methods: { // 父组件：提供方法 parentFn(data) { console.log('父组件：', data) } } }) Vue.component('hello', { template: '按钮', methods: { // 子组件：通过$emit调用 fn() { this.$emit('pfn', '这是子组件传递给父组件的数据') } } }) 非父子组件通讯 在简单的场景下，可以使用一个空的 Vue 实例作为事件总线 $on()：绑定事件 123456789const bus = new Vue()// 触发组件 A 中的事件bus.$emit('id-selected', 1)// 在组件 B 创建的钩子中监听事件bus.$on('id-selected', function (id) { // ...}) 示例：组件A —> 组件B 1234567891011121314151617181920212223242526272829303132333435363738 const bus = new Vue() const vm = new Vue({ el: '#app', components: { comB: { template: '组件A告诉我：{{msg}}', data() { return { msg: '' } }, created() { // 定义事件： bus.$on('tellComB', (msg) => { this.msg = msg }) } }, comA: { template: '告诉B', methods: { emitFn() { // 调用组件B中定义的事件： bus.$emit('tellComB', '地瓜地瓜我是土豆') } } } } }) 获取组件（或元素） - refs 说明：vm.$refs 一个对象，持有已注册过 ref 的所有子组件（或HTML元素） 使用：在 HTML元素 中，添加ref属性，然后在JS中通过vm.$refs.属性来获取 注意：如果获取的是一个子组件，那么通过ref就能获取到子组件中的data和methods 在使用第三方的组件，可能会用到这个功能 123456 vm.$refs.dv","categories":[{"name":"vue","slug":"vue","permalink":"https://guoweiyanggithub.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://guoweiyanggithub.github.io/tags/vue/"},{"name":"vue生命周期","slug":"vue生命周期","permalink":"https://guoweiyanggithub.github.io/tags/vue生命周期/"},{"name":"vue拦截器","slug":"vue拦截器","permalink":"https://guoweiyanggithub.github.io/tags/vue拦截器/"},{"name":"组件通讯","slug":"组件通讯","permalink":"https://guoweiyanggithub.github.io/tags/组件通讯/"}]},{"title":"ES6","slug":"ES6","date":"2019-03-08T03:25:30.000Z","updated":"2019-03-15T08:17:17.736Z","comments":true,"path":"2019/03/08/ES6/","link":"","permalink":"https://guoweiyanggithub.github.io/2019/03/08/ES6/","excerpt":"","text":"变量声明- let、constlet ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 let特点： 1 块级作用域（ES6） 2 先声明再使用 3 不允许重复声明 1234567/* 基本使用 */let num = 2{ let num = 9}console.log(num) const const声明一个只读的常量。一旦声明，常量的值就不能改变。 const的作用域与let命令相同：只在声明所在的块级作用域内有效 123456789const PI = 3.1415console.log(PI) // 3.1415// 修改 常量的值 会报错PI = 3 // TypeError: Assignment to constant variable.// 可以修改对象中属性的值const user = { name: 'rose' }user.name = 'jack' 字符串模板 说明：代替原始的字符串拼接 1234const num = 1// ${} 中可以使用JS表达式let dv = `${num}` 箭头函数 ES6箭头函数 注意 1：函数体内的this对象，就是定义时所在的对象（一般是外层函数中的this） 注意 2：无法使用arguments，没有arguments对象 注意 3：不能当作构造函数，不能使用new创建对象 注意：不要在Vue的选项属性或回调上使用箭头函数 比如：created: () => console.log(this.a) 或 vm.$watch('a', newValue => this.myMethod()) 123456789101112131415/* 语法： */var fn = arg => arg// 上面的箭头函数等同于：var fn = function (arg) { return arg}var fn = () => { console.log('随机内容')}// 等同于：var fn = function () { console.log('随机内容')} rest参数 ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了 说明：rest 参数的类型是：数组 注意：rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错 123456789101112131415function add(...values) { var sum = 0 values.forEach(function(val) { sum += val }) return sum}add(2, 5, 3) // 10// 报错function f(a, ...b, c) { // ...} 解构赋值 ES6解构 ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 1234567891011121314151617// 对象解构var { foo, bar } = { foo: \"aaa\", bar: \"bbb\" }foo // \"aaa\"bar // \"bbb\"// 数组解构var [a, b, c] = [1, 2, 3]a // 1b // 2c // 3// 函数参数的解构赋值function foo({x, y}) { console.log(x, y) // 1 2}foo({x: 1, y: 2}) 对象简化语法 对象中的属性和方法，都可以使用简化语法 1234567891011121314151617181920/* 属性的简化语法： */var foo = 'bar'var baz = {foo}// 等同于var baz = {foo: foo}/* 方法的简化语法： */var o = { method() { return \"Hello!\" }}// 等同于var o = { method: function() { return \"Hello!\" }} 属性名表达式 ES6 允许字面量定义对象时，用表达式作为对象的属性名，即把表达式放在方括号内。 12345678910var propKey = 'foo'var methodKey = 'bar'var obj = { [propKey]: true, ['a' + 'bc']: 123, [methodKey]() { return 'hi' }} class关键字 ES6以前，JS是没有class概念的，而是通过构造函数+原型的方式来实现的 注意：ES6中的class仅仅是一个语法糖，并不是真正的类，与Java等服务端语言中的类是有区别的 ES6 - 文档 12345678910111213141516class Person { constructor() { // 实例属性 this.name = 'jack' } // 实例方法 say() {} // 静态方法 static coding() {}}// 静态属性Person.age = 0console.log(Person.age) 类继承： 1 如果子类提供了 constructor，那么，必须要调用super() 2 子类添加属性，必须在 super() 调用后面 12345678910// 类继承：class Chinese extends Person { constructor(name, gender, weight) { super(name, gender) this.weight = weight }}const ch = new Chinese('小明', '男', 130) 静态属性和实例属性 静态属性：直接通过类名访问 实例属性：通过实例对象访问 ES6模块化 - import和export 导入和导出 import：导入模块 export：导出模块 注意1：export default 每个模块只能使用一次 注意2：export 每个模块可以使用多次 注意3：一个模块可以导出多个内容，export default 和 export 可以一起使用 12345678// main.js// 导入 default 内容，可自定义导入名称// import num from './a.js'import num1 from './a.js'// a.jsconst num = 123export default num 1234567891011121314// main.js// 导入 export内容// 注意：导入非default模块内容（str、fn），必须与 导出名称 相同，或者通过 as 修改// 注意：必须使用花括号import { str, fn } from './b'// 加载并修改变量名// import { str as str1, fn } from './b'// 整体加载// import * as bModule from './b'// b.jsexport const str = 'abc'export function fn() {} 12345678// main.jsimport { str, fn } from './b'// b.jsconst str = 'abc'function fn() {}// 一次性导出export { str, fn } 数组扩展运算符 扩展运算符（spread）是三个点（…）。作用：将一个数组转为用逗号分隔的参数序列 12345var arr = ['a', 'b', 'c']console.log(...arr)// 上面这句代码相当于：console.log(arr[0], arr[1], arr[2]) 对象扩展运算符 注意：该语法不是真正的ES规范，需要使用stage-2解析 123var obj = { name: 'jack', age: 19 }var o = { ...obj, gender: 'male' }// o => {name: 'jack', age: 19, gender: 'male'} Promise 异步编程 Promise 是异步编程的一种解决方案，它允许你以一种同步的方式编写异步代码 promise：承诺、保证 ES6 - Promise 回调地狱问题 JS是通过回调函数来实现异步编程的，当异步操作多了以后，就会产生回调嵌套回调的问题，这就是回调地狱 1234567891011121314// 按序读取文件：a -> b -> c -> dreadFileAsync('a.txt', (err, data) => { console.log('文件a: ', data) readFileAsync('b.txt', (err, data) => { console.log('文件b: ', data) readFileAsync('c.txt', (err, data) => { console.log('文件c: ', data) readFileAsync('d.txt', (err, data) => { console.log('文件d: ', data) }) }) })}) Promise方式：将异步操作以同步操作的方式表达出来，避免了层层嵌套的回调函数 12345678910111213141516readFileAsync('a.txt') .then((data) => { console.log('文件a: ', data) return readFileAsync('b.txt') }) .then((data) => { console.log('文件b: ', data) return readFileAsync('c.txt') }) .then((data) => { console.log('文件c: ', data) return readFileAsync('d.txt') }) .then((data) => { console.log('文件d: ', data) }) 12345678910111213// 终极形态：async function fn () { const fileA = await readFileAsync('a.txt') console.log(fileA) const fileB = await readFileAsync('b.txt') console.log(fileB) const fileC = await readFileAsync('c.txt') console.log(fileC) const fileD = await readFileAsync('d.txt') console.log(fileD)}fn() 三种状态 Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败） 状态改变 1：pending -> fufilled 状态改变 2：pending -> rejected 一旦状态改变，就不会再变 基本使用 Promise构造函数：就是一个容器，用来封装异步操作 12345678910111213141516// Promise 是一个构造函数// 通过 new 创建Promise的实例对象const p = new Promise(function(resolve, reject) { // resolve 表示成功，异步操作成功调用 // reject 表示失败，异步操作失败调用 fs.readFile('a.txt', (err, data) => { if (err) { // 文件读取失败，调用 reject reject(err) return } // 文件读取成功，调用 resolve resolve(data) })}) then 和 catch 说明：获取异步操作的结果 then() ：用于获取异步操作成功时的结果 -> resolve catch()：用于获取异步操作失败时的结果 -> reject 说明：then()方法可以有多个，按照先后顺序执行，通过回调函数返回值传递数据给下一个then 1234567891011121314151617p // 成功 .then((value) => { console.log('文件a的内容为：', value) }) // 失败（比如：文件路径错误） .catch((err) => { console.log('文件读取失败：', err) })// ----------- 或者 -----------p .then((value) => { // 成功 }, (err) => { // 失败 }) all 和 race123456789101112131415161718192021// 所有请求发送成功：const p = Promise.all([ axios('http://vue.studyit.io/api/getlunbo'), axios('http://vue.studyit.io/api/getnewslist')])p.then(function (res) { // res 是 all() 方法中所有异步操作的结果 console.log('两个异步请求完成：', res)})// 哪个请求先发送成功：const p = Promise.race([ axios('http://vue.studyit.io/api/getlunbo'), axios('http://vue.studyit.io/api/getnewslist')])p.then(function (res) { // res 是 race() 方法中先完成的异步操作的结果： console.log('一个异步请求完成：', res)}) Promise 的实现方式 q bluebird co when async 和 await 异步编程终极方案 注意：await只能在async函数中使用 注意：await后面是一个Promise实例对象 注意：await关键字用来暂停后面的函数，等到获取到结果后，下面的代码才会执行 这样，就可以按照代码书写的顺序来理解代码执行顺序 使用ES2017的Async功能 async/await替代Promise的6个理由 12345678910111213141516171819202122// 封装 Promise函数function timeout(ms) { return new Promise(resolve => { // setTimeout(resolve, ms, 'await') setTimeout((data) => { resolve(data) }, ms, '定时器') })}// 使用 async关键字 创建一个异步函数async function fn() { console.log('await 前面') // 使用await关键字暂停函数，等待 Promise 的结果 const ret = await timeout(3000) console.log(ret) console.log('await 后面')}fn() Promise 执行顺序问题1234567891011let promise = new Promise(function(resolve, reject) { console.log('1 Promise') // 异步操作 setTimeout(resolve, 1000, 'done')})promise.then(function() { console.log('3 resolved.')})console.log('2 Hi!') webpack 4.0 使用 webpack 4.0 webpack 4 测试版 —— 现在让我们先一睹为快吧！ 1 npm i -D webpack webpack-cli 2 webpack --mode development ./src/main.js 1234使用上的变化：1 需要单独安装 webpack-cli 才能使用 webpack命令2 使用webpack命令需要指定模式（development 或者 production）3 默认的入口为：./src/index.js 默认出口为：./dist 说明 1 webpack的默认入口为：/src/index.js 2 webpack两种模式（mode） 开发模式：development 生成模式：production 压缩版 指定入口：webpack ./src/main.js 指定出口：webpack ./src/main.js -o ./dist/bundle.js","categories":[{"name":"es6","slug":"es6","permalink":"https://guoweiyanggithub.github.io/categories/es6/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://guoweiyanggithub.github.io/tags/javascript/"},{"name":"web前端","slug":"web前端","permalink":"https://guoweiyanggithub.github.io/tags/web前端/"},{"name":"ES6","slug":"ES6","permalink":"https://guoweiyanggithub.github.io/tags/ES6/"}]},{"title":"Redux","slug":"Redux","date":"2019-03-08T03:24:04.000Z","updated":"2019-03-14T03:07:40.295Z","comments":true,"path":"2019/03/08/Redux/","link":"","permalink":"https://guoweiyanggithub.github.io/2019/03/08/Redux/","excerpt":"","text":"起源1234567891011React 只是 DOM 的一个抽象层，并不是 Web 应用的完整解决方案。有两个方面，它没涉及1 代码结构2 组件之间的通信对于大型的复杂应用来说，这两方面恰恰是最关键的。因此，只用 React 没法写大型应用。2014年 Facebook 提出了 Flux 架构的概念，引发了很多的实现。2015年，Redux 出现，将 Flux 与函数式编程结合一起，很短时间内就成为了最热门的前端架构。Flux 是最早的 状态管理 工具，它提供了状态管理的思想，也提供对应的实现除了 Flux、redux 之外，还有：Mobx 等状态管理工具 注意：如果你不知道是否需要 Redux，那就是不需要它。只有遇到 React 实在解决不了的问题，你才需要 Redux 特点 1 提供可预测的状态管理 2 通过开发者工具，提供：代码热替换（hot reload）和时间旅行（time travel）功能 3 提供中间件机制 123state 变化的过程：子 reducers 会把他们创建的副本传回给根 reducer，而根 reducer 会把这些副本组合起来形成一颗新的状态树。最后根 reducer 将新的状态树传回给 store，store 再将新的状态树设为最终的状态。 react项目技术栈 react react-router（react-router-dom） 状态：mobx （简单）/ redux（复杂） dva：集成了 react/react-router/redux 让 react 开发大型项目变的更加简单 dva react 技术栈 使用 安装：npm i -S redux 原则和理念 1 单一数据源 2 State 是只读的 3 使用纯函数来执行修改 解释：不要直接修改状态，而是返回一个新的状态 1234567891011// 比如，state = { list: [1, 2, 3]}// 错误做法：state.list.push(4)return state// 正确做法return [...state.list, 4] 理解三个核心概念 核心概念：store、action、reducer store：管理者，管理action和reducer action：“砖家”，只提想法不干活 reducer：劳动者，搬砖的人 1234567891011121314151617角色扮演： 妈妈 ===> store 孩子 ===> action 爸爸 ===> reducer场景：孩子饿了要吃饭孩子要吃饭： 吃饭这是一个动作 说明：孩子是“专家”，提出了吃饭的想法，但是，孩子自己不会吃饭爸爸喂孩子吃饭： 喂孩子吃饭，是吃饭这个动作的具体响应 说明：爸爸是劳动者，但是比较笨，不会主动喂孩子吃饭妈妈让爸爸喂孩子吃饭 说明：妈妈是管理者，妈妈把孩子饿了这事告诉爸爸，爸爸知道孩子饿了后，就会喂孩子吃饭更多：孩子尿床了换尿布 Action action 是行为的抽象，视图中的每个用户交互都是一个action 比如：添加任务、删除任务、登录、加入购物车 等 作用一：定义应用中可以执行的动作（或操作）的类型（type） 作用二：提供并传递 要改变的状态 使用方式：通过 store.dispatch() 将 action 传到 store 12345678910注意点：1 类型：JS对象2 要求：必须有type属性（string），表示要执行的动作，使用全大写字母表示可以带有_3 如果这个交互动作使用数据，应该提供使用的数据4 一般由方法生成进阶：5 当应用规模越来越大时，type 会被定义成字符串常量。建议使用单独的模块或文件来存放 action 一般会定义名称为：actionTypes.js的文件，用来存储所有 action 的名称 123456789101112131415161718// action 示例：{ type: 'ADD_TODO', text: 'Build my first Redux app'}// 使用action创建函数：（添加任务）const addTodo = (text) => ({ type: 'ADD_TODO', text})addTodo('Build my first Redux app') // {type: '', text: ''}// 无参数：（值加1）const increment = () => ({ type: 'INCREMENT'})increment() // { type: '' } reducer reducer 是行为响应的抽象，也就是：根据action，执行相应的逻辑操作，返回最新的state 代码解释：(previousState, action) => newState 根据应用现有状态和触发的action返回新状态的函数称为reducer 注意：不要直接修改state，应该返回一个新state，保证数据的不可变性（immutability） 123456789注意点：1 纯函数（输入决定输出） - 不要直接修改state2 传入旧状态和action3 返回新状态进阶：4 每个 reducer 只负责管理应用全部 state 中，它负责的一部分（职责单一）5 随着应用的膨胀，需要对 reducer 函数 进行拆分，拆分后的每一块独立负责管理 state 的一部分 123456789101112131415// 处理ADD_TODO动作的reducer：const todos = (state = [], action) => { switch (action.type) { case 'ADD_TODO': // 返回新的state return [ ...state, { text: action.text, completed: false } ] }} combineReducers 作用：把一个由不同 reducer 函数作为值的对象，合并成一个根reducer函数 说明：合并reducer会影响redux中state的结构 => state结构与该方法对象参数结构相同 说明：合并后的 reducer 可以调用各个子 reducer，并把它们的结果合并成一个 state 对象。state 对象的结构由传入的多个 reducer 的 key 决定。 combineReducers 解释 1234567891011121314151617// 使用 combineReducers 合并多个reducer：import { combineReducers } from 'redux'function todos (state = [], action) {}function visibilityFilter (state = 'SHOW_ALL', action) {}// 合并两个reducer：// todos 和 visibilityFilter 的state 会被合并为一个 state对象// 说明：最终的 state 中包含两个属性 => { todos, visibilityFilter }，与对象参数结构相同const todoApp = combineReducers({ todos, visibilityFilter})// 导出根reducerexport default todoApp 1234// combineReducers() 函数做了什么？// 合并后的 reducer 可以调用各个子 reducer，并把它们返回的结果合并成一个 state 对象。 由 combineReducers() 返回的 state 对象，会将传入的每个 reducer 返回的 state 按其传递给 combineReducers() 时对应的 key 进行命名// 说明：第一次初始化state以及每次state改变，都要遍历所有的 reducer，分别查看每个reducer中的state有没有改变，如果变了，就使用新的state reducer纯函数的说明 特点：只要是同样的输入，必定得到同样的输出 原则：（一定要遵守！！！） 不得改写参数 不能调用Date.now()或者Math.random()等不纯的方法，因为每次会得到不一样的结果 不能调用系统 I/O 的API 1 reducer必须是一个纯函数 2 纯函数主要的含义就是它不可以修改影响输入值 3 没有副作用，副作用指的是例如函数中一些异步调用或者会影响函数作用域之外的变量一类的操作 store 一个应用应该只有一个store store负责将 action 和 reducer 关联在一起 store的作用：维持应用的 state 123456789101112131415161718192021222324// 根据reducer创建 store：import { createStore } from 'redux'import todoApp from './reducers'// 根据 reducers 创建storelet store = createStore(todoApp)// 获取state：store.getState()// 1 注册监听器：// 2 返回注销该监听器的函数// 说明：每次 state 更新时，都会执行该回调函数打印日志const unsubscribe = store.subscribe(() => { console.log( store.getState() )})// 1 更新 state：// 2 调用所有已经注册的监听器函数，比如：上面打印日志监听器store.dispatch( addTodo('Learn about store') )// 注销监听器：unsubscribe() 搭配react 安装：npm i -S react-redux 1react-redux 规定，所有的 UI组件 都由用户提供，容器组件则是由 react-redux 自动生成。也就是说，用户负责视觉层，状态管理则是全部交给它。 connect()方法 react-redux 作用：用于从 UI组件 生成 容器组件。connect的意思，就是将这两种组件连起来。 1connect的理解：其实就相当于connect在获取了Redux的store之后，再根据我们传入的方法，把我们需要的部分对应到props属性中，再传递到我们的组件当中 12345678// 将 UI组件 转换成 容器组件：import { connect } from 'react-redux'// TodoList是 UI 组件// TodoListContainer就是由 react-redux 通过connect方法自动生成的容器组件// 说明：因为没有定义业务逻辑，这个容器组件毫无意义，只是 UI 组件的一个单纯的包装层const TodoListContainer = connect()(TodoList) 为了定义业务逻辑，需要给出下面两方面的信息： 12（1）输入逻辑：redux中的state对象（数据），如何在 UI组件 中使用（2）输出逻辑：用户发出的动作如何变为 Action 对象，从 UI 组件传出去 123456789101112131415161718192021222324import { connect } from 'react-redux'// 示例 - 映射stateconst mapStateToProps = (state) => ({ count: state})// 示例 - 映射dispatchconst mapDispatchToProps = ( dispatch ) => ({ handleIncreament: () => { dispatch(increament(3)) }, handleDecreament: () => { dispatch(decreament(1)) }})// connect方法的功能有以下两点：// 1、包装原组件，将state和action通过props的方式传入到原组件内部// 2、监听 store 中state的变化，使其包装的原组件可以响应state变化，实现更新// 说明：通过 connect() 创建的组件，在mount的时候就注册监听器，当通过 dispatch 修改状态的时候，会触发这个监听器。监听器中调用 setState() 触发了组件更新（内部有相关的优化机制提升性能）const VisibleTodoList = connect( // 建立从（外部的）state对象到（UI 组件的）props的映射关系 mapStateToProps, // 用来建立 UI 组件的参数到store.dispatch方法的映射 // 定义了 UI 组件的参数怎样发出 Action mapDispatchToProps)(TodoList) Provider组件 作用：Provider的唯一功能就是传入store对象，让容器组件（中的所有组件）可以使用store中的state 123456789let store = createStore(todoApp)// Provider组件，可以让容器组件拿到staterender( , document.getElementById('root'))","categories":[{"name":"react","slug":"react","permalink":"https://guoweiyanggithub.github.io/categories/react/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://guoweiyanggithub.github.io/tags/Redux/"}]},{"title":"React笔记","slug":"React笔记","date":"2019-03-08T03:21:14.000Z","updated":"2019-03-14T03:08:39.624Z","comments":true,"path":"2019/03/08/React笔记/","link":"","permalink":"https://guoweiyanggithub.github.io/2019/03/08/React笔记/","excerpt":"","text":"React 背景介绍 React 入门实例教程 React 起源于 Facebook 的内部项目，因为该公司对市场上所有 JavaScript MVC 框架，都不满意，就决定自己写一套，用来架设 Instagram 照片墙 的网站。做出来以后，发现这套东西很好用，就在2013年5月开源了。 什么是React A JAVASCRIPT LIBRARY FOR BUILDING USER INTERFACES 用来构建UI的 JavaScript库 React 官网 React 中文文档 特点 1 通过 JSX语法 实现组件化开发，为函数式的 UI 编程方式打开了大门 2 性能高的让人称赞：通过 diff算法 和 虚拟DOM 实现视图的高效更新 3 HTML仅仅是个开始 123456> JSX --TO--> EveryThing- JSX --> HTML- JSX --> native ios或android中的组件（XML）- JSX --> VR- JSX --> 物联网 为什么要用React 1 使用组件化开发方式，符合现代Web开发的趋势 2 技术成熟，社区完善，配件齐全，适用于大型Web项目（生态系统健全） 3 由Facebook专门的团队维护，技术支持可靠 4 ReactNative - Learn once, write anywhere: Build mobile apps with React 5 使用方式简单，性能非常高，支持服务端渲染 6 React非常火，从技术角度，可以满足好奇心，提高技术水平；从职业角度，有利于求职和晋升，有利于参与潜力大的项目 React中的核心概念 1 虚拟DOM（Virtual DOM） 2 Diff算法（虚拟DOM的加速器，提升React性能的法宝） 虚拟DOM（Vitural DOM） React将DOM抽象为虚拟DOM，虚拟DOM其实就是用一个对象来描述DOM，通过对比前后两个对象的差异，最终只把变化的部分重新渲染，提高渲染的效率 如何实现一个 Virtual DOM 算法 理解 Virtual DOM VituralDOM的处理方式 1 用 JavaScript 对象结构表示 DOM 树的结构，然后用这个树构建一个真正的 DOM 树，插到文档当中 2 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异 3 把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了 Diff算法 Reconciliation diff diff算法 - 中文文档 不可思议的 react diff React diff 算法 当你使用React的时候，在某个时间点 render() 函数创建了一棵React元素树，在下一个state或者props更新的时候，render() 函数将创建一棵新的React元素树，React将对比这两棵树的不同之处，计算出如何高效的更新UI（只更新变化的地方） 1234了解：有一些解决将一棵树转换为另一棵树的最小操作数算法问题的通用方案。然而，树中元素个数为n，最先进的算法 的时间复杂度为 O(n3) 。如果直接使用这个算法，在React中展示1000个元素则需要进行10亿次的比较。这操作太过昂贵，相反，React基于两点假设，实现了一个O(n)算法，提升性能： React中有两种假定： 1 两个不同类型的元素会产生不同的树 2 开发者可以通过key属性指定不同树中没有发生改变的子元素 Diff算法的说明 - 1 如果两棵树的根元素类型不同，React会销毁旧树，创建新树 1234567891011// 旧树 // 新树 执行过程：destory Counter -> insert Counter Diff算法的说明 - 2 对于类型相同的React DOM 元素，React会对比两者的属性是否相同，只更新不同的属性 当处理完这个DOM节点，React就会递归处理子节点。 1234567891011// 旧// 新只更新：className 属性// 旧// 新只更新：color属性 Diff算法的说明 - 3 1 当在子节点的后面添加一个节点，这时候两棵树的转化工作执行的很好 123456789101112131415// 旧 first second// 新 first second third执行过程：React会匹配新旧两个first，匹配两个second，然后添加 third tree 2 但是如果你在开始位置插入一个元素，那么问题就来了： 123456789101112131415// 旧 1 2// 新 3 1 2执行过程：React将改变每一个子节点，而非保持 Duke 和 Villanova 不变 key 属性 为了解决以上问题，React提供了一个 key 属性。当子节点带有key属性，React会通过key来匹配原始树和后来的树。 123456789101112131415// 旧 1 2// 新 3 1 2执行过程：现在 React 知道带有key '2014' 的元素是新的，对于 '2015' 和 '2016' 仅仅移动位置即可 说明：key属性在React内部使用，但不会传递给你的组件 推荐：在遍历数据时，推荐在组件中使用 key 属性：{item.name} 注意：key只需要保持与他的兄弟节点唯一即可，不需要全局唯一 注意：尽可能的减少数组index作为key，数组中插入元素的等操作时，会使得效率底下 key demo 执行过程：B != A，则创建并插入 B，删除 A；以此类推，创建并插入 A、D、C，删除 B、C、D 执行过程：B、D 不做任何操作，A、C 进行移动操作 React的基本使用 安装：npm i -S react react-dom react：react 是React库的入口点 react-dom：提供了针对DOM的方法，比如：把创建的虚拟DOM，渲染到页面上 1234567891011// 1. 导入 reactimport React from 'react'import ReactDOM from 'react-dom'// 2. 创建 虚拟DOMconst divVD = React.createElement('div', { title: 'hello react'}, 'Hello React！！！')// 3. 渲染ReactDOM.render(divVD, document.getElementById('app')) API说明 createElement()：知道即可 render() 123456789101112131415161718192021222324252627// https://reactjs.org/docs/react-api.html// 作用：根据指定的参数，创建react对象//// 第一个参数：指定创建虚拟DOM的类型// 类型：string 或者 react组件// 1 任意字符串类型的标签名称，比如：'div' / 'span'// 2 react组件类型，比如：// 第二个参数：指定元素自身的属性// 类型：对象或者null// 第三个参数：当前元素的子元素// 类型：string 或者 createElement() 的返回值// 返回值：react对象React.createElement( type, [props], [...children])// https://reactjs.org/docs/react-dom.html// 作用：渲染react元素// 第一个参数：指定要渲染的react对象// 第二个参数：指定渲染到页面中的容器（DOM对象）// 第三个参数：回调函数ReactDOM.render( element, container) createElement()的问题 说明：createElement()方式，代码编写不友好，太复杂 12345678910111213141516171819202122232425var dv = React.createElement( \"div\", { className: \"shopping-list\" }, React.createElement( \"h1\", null, \"Shopping List for \" ), React.createElement( \"ul\", null, React.createElement( \"li\", null, \"Instagram\" ), React.createElement( \"li\", null, \"WhatsApp\" ) ))// 渲染ReactDOM.render(dv, document.getElementById('app')) JSX 的基本使用 注意：JSX语法，最终会被编译为 createElement() 方法 推荐：使用 JSX 的方式创建组件 JSX - JavaScript XML 安装：npm i -D babel-preset-react （依赖与：babel-core/babel-loader） 注意：JSX的语法需要通过 babel-preset-react 编译后，才能被解析执行 123456789101112131415161718192021/* 1 在 .babelrc 开启babel对 JSX 的转换 */{ \"presets\": [ \"env\", \"react\" ]}/* 2 webpack.config.js */module: [ rules: [ { test: /\\.js$/, use: 'babel-loader', exclude: /node_modules/ }, ]]/* 3 在 js 文件中 使用 JSX */const dv = ( Hello JSX!)/* 4 渲染 JSX 到页面中 */ReactDOM.render(dv, document.getElementById('app')) JSX的注意点 注意 1: 如果在 JSX 中给元素添加类, 需要使用 className 代替 class 类似：label 的 for属性，使用htmlFor代替 注意 2：在 JSX 中可以直接使用 JS代码，直接在 JSX 中通过 {} 中间写 JS代码即可 注意 3：在 JSX 中只能使用表达式，但是不能出现 语句！！！ 注意 4：在 JSX 中注释语法：{/* 中间是注释的内容 */} React组件 React 组件可以让你把UI分割为独立、可复用的片段，并将每一片段视为相互独立的部分。 组件是由一个个的HTML元素组成的 概念上来讲, 组件就像JS中的函数。它们接受用户输入（props），并且返回一个React对象，用来描述展示在页面中的内容 React创建组件的两种方式 1 通过 JS函数 创建（无状态组件） 2 通过 class 创建（有状态组件） 123函数式组件 和 class 组件的使用场景说明：1 如果一个组件仅仅是为了展示数据，那么此时就可以使用 函数组件2 如果一个组件中有一定业务逻辑，需要操作数据，那么就需要使用 class 创建组件，因此，此时需要使用 state JavaScript函数创建 注意：1 函数名称必须为大写字母开头，React通过这个特点来判断是不是一个组件 注意：2 函数必须有返回值，返回值可以是：JSX对象或null 注意：3 返回的JSX，必须有一个根元素 注意：4 组件的返回值使用()包裹，避免换行问题 1234567891011121314151617function Welcome(props) { return ( {/* 注释的写法 */} Shopping List for {props.name} Instagram WhatsApp )}ReactDOM.render( , document.getElementById('app')) class创建 注意：基于 ES6 中的class，需要配合 babel 将代码转化为浏览器识别的ES5语法 安装：npm i -D babel-preset-env 1234567891011121314151617class ShoppingList extends React.Component { constructor(props) { super(props) } render() { return ( Shopping List for {this.props.name} Instagram WhatsApp ) }} 给组件传递数据 - 父子组件传递数据 组件中有一个 只读的对象 叫做 props，无法给props添加属性 获取方式：函数参数 props 作用：将传递给组件的属性转化为 props 对象中的属性 123456789101112function Welcome(props){ // props ---> { username: 'zs', age: 20 } return ( Welcome React 姓名：{props.username}----年龄是：{props.age} )}// 给 Hello组件 传递 props：username 和 ageReactDOM.reander(, ......) 封装组件到独立的文件中1234567891011121314151617181920212223// ./components/Hello2.js// 1. 引入React模块// 由于 JSX 编译后会调用 React.createElement 方法，所以在你的 JSX 代码中必须首先声明 React 变量。import React from 'react'// 2. 使用function构造函数创建组件function Hello2(props){ return ( 这是Hello2组件 这是大大的H1标签，我大，我骄傲！！！ 这是小小的h6标签，我小，我傲娇！！！ )}// 3. 导出组件export default Hello2// app.js// 使用组件：import Hello2 from './components/Hello2' props和stateprops 作用：给组件传递数据，一般用在父子组件之间 说明：React把传递给组件的属性转化为一个对象并交给 props 特点：props是只读的，无法给props添加或修改属性 props.children：获取组件的内容，比如： 组件内容 中的 组件内容 12345678910111213141516// props 是一个包含数据的对象参数，不要试图修改 props 参数// 返回值：react元素function Welcome(props) { // 返回的 react元素中必须只有一个根元素 return hello, {props.name}}class Welcome extends React.Component { constructor(props) { super(props) } render() { return Hello, {this.props.name} }} state 作用：用来给组件提供组件内部使用的数据 注意：只有通过class创建的组件才具有状态 注意：状态是私有的，完全由组件来控制 注意：不要在 state 中添加 render() 方法中不需要的数据，会影响渲染性能！ 可以将组件内部使用但是不渲染在视图中的内容，直接添加给 this 注意：不要在 render() 方法中调用 setState() 方法来修改state的值 但是可以通过 this.state.name = 'rose' 方式设置state（不推荐!!!!） 12345678910111213class Hello extends React.Component { constructor() { this.state = { gender: 'male' } } render() { return ( 性别：{ this.state.gender } ) }} JSX语法转化过程12345678910111213141516171819202122232425262728// JSXconst element = ( Hello, world! )// JSX -> createElementconst element = React.createElement( 'h1', {className: 'greeting'}, 'Hello, world!')// React elements: 使用对象的形式描述页面结构// Note: 这是简化后的对象结构const element = { tagName: 'h1', props: { className: 'greeting', }, children: ['Hello, world']}// HTML Hello, world! 评论列表案例 巩固有状态组件和无状态组件的使用 两个组件： 和 12345678910[ { user: '张三', content: '哈哈，沙发' }, { user: '张三2', content: '哈哈，板凳' }, { user: '张三3', content: '哈哈，凉席' }, { user: '张三4', content: '哈哈，砖头' }, { user: '张三5', content: '哈哈，楼下山炮' }]// 属性扩散 style样式1234567891011121314151617// 1. 直接写行内样式：// 2. 抽离为对象形式var styleH3 = {color:'blue'}var styleObj = { liStyle:{border:'1px solid red', fontSize:'12px'}, h3Style:{color:'green'}} 评论内容：{props.content}// 3. 使用样式表定义样式：import '../css/comment.css'评论人：{props.user} 相关文章 React数据流和组件间的沟通总结 单向数据流和双向绑定各有什么优缺点？ 怎么更好的理解虚拟DOM? React中文文档 React 源码剖析系列 － 不可思议的 react diff 深入浅出React（四）：虚拟DOM Diff算法解析 ES6中class关键字的使用 ES6中的所有的代码都是运行在严格模式中的 1 它是用来定义类的，是ES6中实现面向对象编程的新方式 2 使用static关键字定义静态属性 3 使用constructor构造函数，创建实例属性 class 关键字 1234567891011class Person { constructor(age){ // 实例属性 this.age = age }}// 静态属性Person.staticName = '静态属性'const p = new Person(19) 在class中定义方法 123456789// 实例方法sayHello () { console.log('大家好，我今年' + this.age + '了');}// 静态方法static wangwang () { console.log('我是小明，我新get了一个技能，会暖床');} 实现继承的方式 123456789class American extends Person { constructor() { // 必须调用super(), super表示父类的构造函数 super() this.skin = 'white' this.eyeColor = 'white' }} react 生命周期组件的生命周期 简单说：一个组件从开始到最后消亡所经历的各种状态，就是一个组件的生命周期 组件生命周期函数的定义：从组件被创建，到组件挂载到页面上运行，再到页面关闭组件被卸载，这三个阶段总是伴随着组件各种各样的事件，那么这些事件，统称为组件的生命周期函数！ 通过这个函数，能够让开发人员的代码，参与到组件的生命周期中。也就是说，通过钩子函数，就可以控制组件的行为 react component React Native 中组件的生命周期 React 生命周期的管理艺术 智能组件和木偶组件 组件生命周期函数总览 说明：通过 Counter计数器的小案例，理解组件的生命周期函数基本使用 组件的生命周期包含三个阶段：创建阶段（Mounting）、运行和交互阶段（Updating）、卸载阶段（Unmounting） Mounting： constructor()componentWillMount()render()componentDidMount() Updating componentWillReceiveProps()shouldComponentUpdate()componentWillUpdate()render()componentDidUpdate() Unmounting componentWillUnmount() 组件生命周期 - 创建阶段(Mounting) 特点：该阶段的函数只执行一次 constructor() 作用：1 获取props 2 初始化state 说明：通过 constructor() 的参数props获取 设置state和props 12345678910111213141516class Greeting extends React.Component { constructor(props) { // 获取 props super(props) // 初始化 state this.state = { count: props.initCount } }}// 初始化 props// 语法：通过静态属性 defaultProps 来初始化propsGreeting.defaultProps = { initCount: 0}; componentWillMount() 说明：组件被挂载到页面之前调用，其在render()之前被调用，因此在这方法里同步地设置状态将不会触发重渲染 说明：1 可以调用 setState() 方法来改变状态值 注意：2 无法获取页面中的DOM对象 123456componentWillMount() { console.warn(document.getElementById('btn')) // null this.setState({ count: this.state.count + 1 })} render() 作用：渲染组件到页面中，无法获取页面中的DOM对象 注意：不要在render方法中调用 setState() 方法，否则会递归渲染 原因说明：状态改变会重新调用render()，render()又重新改变状态 1234567891011121314render() { console.warn(document.getElementById('btn')) // null return ( 打豆豆一次 { this.state.count === 4 ? null : } )} componentDidMount() 1 组件已经挂载到页面中 2 可以进行DOM操作，比如：获取到组件内部的DOM对象 3 可以发送请求获取数据 4 可以通过 setState() 修改状态的值 注意：在该方法里设置状态将会触发重渲 1234componentDidMount() { // 此时，就可以获取到组件内部的DOM对象 console.warn('componentDidMount', document.getElementById('btn'))} 组件生命周期 - 运行阶段（Updating） 特点：该阶段的函数执行多次 说明：每当组件的props或者state改变的时候，都会触发运行阶段的函数 componentWillReceiveProps() 说明：组件接受到新的props前触发这个方法 参数：当前组件props值 可以通过 this.props 获取到上一次的值 使用：若你需要响应属性的改变，可以通过对比this.props和nextProps并在该方法中使用this.setState()处理状态改变 注意：修改state不会触发该方法 123componentWillReceiveProps(nextProps) { console.warn('componentWillReceiveProps', nextProps)} shouldComponentUpdate() 作用：根据这个方法的返回值决定是否重新渲染组件，返回true重新渲染，否则不渲染 优势：通过某个条件渲染组件，降低组件渲染频率，提升组件性能 说明：如果返回值为false，那么，后续render()方法不会被调用 注意：这个方法必须返回布尔值！！！ 参数： 第一个参数：最新属性对象 第二个参数：最新状态对象 场景：根据随机数决定是否渲染组件 12345shouldComponentUpdate(nextProps, nextState) { console.warn('shouldComponentUpdate', nextProps, nextState) return nextState.count % 2 === 0} componentWillUpdate() 作用：组件将要更新 参数：最新的属性和状态对象 123componentWillUpdate(nextProps, nextState) { console.warn('componentWillUpdate', nextProps, nextState)} render() 渲染 作用：重新渲染组件，与Mounting阶段的render是同一个函数 注意：这个函数能够执行多次，只要组件的属性或状态改变了，这个方法就会重新执行 componentDidUpdate() 作用：组件已经被更新 参数：旧的属性和状态对象 123componentDidUpdate(prevProps, prevState) { console.warn('componentDidUpdate', prevProps, prevState)} 组件生命周期 - 卸载阶段（Unmounting） 组件销毁阶段：组件卸载期间，函数比较单一，只有一个函数，这个函数也有一个显著的特点：组件一辈子只能执行依次！ 使用说明：只要组件不再被渲染到页面中，那么这个方法就会被调用（ 渲染到页面中 -> 不再渲染到页面中 ） componentWillUnmount() 作用：在卸载组件的时候，执行清理工作，比如 1 清除定时器 2 清除componentDidMount创建的DOM对象 React - createReactClass（知道） React.createClass({}) 方式，创建有状态组件，该方式已经被废弃！！！ 通过导入 require('create-react-class')，可以在不适用ES6的情况下，创建有状态组件 getDefaultProps() 和 getInitialState() 方法：是 createReactClass() 方式创建组件中的两个函数 React without ES6 React 不使用ES6 12345678910111213141516171819202122232425262728293031323334353637383940414243var createReactClass = require('create-react-class');var Greeting = createReactClass({ // 初始化 props getDefaultProps: function() { console.log('getDefaultProps'); return { title: 'Basic counter!!!' } }, // 初始化 state getInitialState: function() { console.log('getInitialState'); return { count: 0 } }, render: function() { console.log('render'); return ( {this.props.title} {this.state.count} ); }, handleIncrement: function() { var newCount = this.state.count + 1; this.setState({count: newCount}); }, propTypes: { title: React.PropTypes.string }});ReactDOM.render( React.createElement(Greeting), document.getElementById('app')); state和setState 注意：使用 setState() 方法修改状态，状态改变后，React会重新渲染组件 注意：不要直接修改state属性的值，这样不会重新渲染组件！！！ 使用：1 初始化state 2 setState修改state 123// 修改state（不推荐使用）// https://www.reactjscn.com/docs/state-and-lifecycle.html#不要直接更新状态this.state.test = '这样方式，不会重新渲染组件'; 12345678910111213141516171819202122232425262728293031323334353637constructor(props) { super(props) // 正确姿势！！！ // -------------- 初始化 state -------------- this.state = { count: props.initCount }}componentWillMount() { // -------------- 修改 state 的值 -------------- // 方式一： this.setState({ count: this.state.count + 1 }) this.setState({ count: this.state.count + 1 }, function(){ // 由于 setState() 是异步操作，所以，如果想立即获取修改后的state // 需要在回调函数中获取 // https://www.reactjscn.com/docs/react-component.html#setstate }); // 方式二： this.setState(function(prevState, props) { return { counter: prevState.counter + props.increment } }) // 或者 - 注意： => 后面需要带有小括号，因为返回的是一个对象 this.setState((prevState, props) => ({ counter: prevState.counter + props.increment }))} 组件绑定事件 1 通过React事件机制 onClick 绑定 2 JS原生方式绑定（通过 ref 获取元素） 注意：ref 是React提供的一个特殊属性 ref的使用说明：react ref React中的事件机制 - 推荐 注意：事件名称采用驼峰命名法 例如：onClick 用来绑定单击事件 1234 JS原生方式 - 知道即可 说明：给元素添加 ref 属性，然后，获取元素绑定事件 123456789101112// JSX// 将当前DOM的引用赋值给 this.txtInput 属性 this.txtInput = input } type=\"button\" value=\"我是豆豆\" />componentDidMount() { // 通过 this.txtInput 属性获取元素绑定事件 this.txtInput.addEventListener(() => { this.setState({ count:this.state.count + 1 }) })} 事件绑定中的this 1 通过 bind 绑定 2 通过 箭头函数 绑定 通过bind绑定 原理：bind能够调用函数，改变函数内部this的指向，并返回一个新函数 说明：bind第一个参数为返回函数中this的指向，后面的参数为传给返回函数的参数 123456789101112131415161718192021// 自定义方法：handleBtnClick(arg1, arg2) { this.setState({ msg: '点击事件修改state的值' + arg1 + arg2 })}render() { return ( 事件中this的处理 {this.state.msg} )} 在构造函数中使用bind 12345678constructor() { super() this.handleBtnClick = this.handleBtnClick.bind(this)}// render() 方法中：事件中this的处理 通过箭头函数绑定 原理：箭头函数中的this由所处的环境决定，自身不绑定this 123456789 { this.handleBtnClick('参数1', '参数2') }} />handleBtnClick(arg1, arg2) { this.setState({ msg: '在构造函数中绑定this并传参' + arg1 + arg2 });} 受控组件 表单和受控组件 非受控组件 浅析React中的受控组件和非受控组件 在React中，可变的状态通常保存在组件的state中，并且只能用 setState() 方法进行更新.我们通过使react变成一种单一数据源的状态来结合二者。React负责渲染表单的组件仍然控制用户后续输入时所发生的变化。相应的，其值由React控制的输入表单元素称为“受控组件”。 在React应用中，任何可变数据应该只有一个：“单一数据源” 注意：只能通过setState来设置受控组件的值 1234567891011// 模拟实现文本框数据的双向绑定// 当文本框内容改变的时候，触发这个事件，重新给state赋值handleTextChange = event => { console.log(event.target.value) this.setState({ msg: event.target.value })} props校验 作用：通过类型检查，提高程序的稳定性 命令：npm i -S prop-types 类型校验文档 使用：给类提供一个静态属性 propTypes（对象），来约束props 123456789// 引入模块import PropTypes from 'prop-types'// ...以下代码是类的静态属性：// propTypes 静态属性的名称是固定的！！！static propTypes = { initCount: PropTypes.number, // 规定属性的类型 initAge: PropTypes.number.isRequired // 规定属性的类型，且规定为必传字段} React 单向数据流 和 状态提升 单向数据流 状态提升 作用：规定组件通讯的使用模式 单向数据流：任何状态始终由某些特定组件（一般是顶层父组件）所有，并且该状态只能影响树中下方的组件 状态提升：在React中，状态分享是通过将state提升至离需要这些数据的组件最近的父组件来完成的，这就是所谓的状态提升 模式：父组件提供数据（状态），子组件从父组件中获取数据，并进行展示处理 123状态是属于组件的私有数据，除了拥有它的组件外，其他组件不能访问，组件可以将私有的状态作为属性传递给子组件，这通常被称为单向数据流（方向：父组件 --> 子组件） 组件通讯 父 -> 子：props 子 -> 父：父组件通过props传递回调函数给子组件，子组件调用函数将数据作为参数传递给父组件 兄弟组件：因为React是单向数据流，因此需要借助父组件进行传递，通过父组件回调函数改变兄弟组件的props React中的状态管理： flux（提出状态管理的思想）/ Redux 推荐 / Mobx / … Vue中的状态管理： Vuex 简单来说，就是统一管理了项目中所有的数据，让数据变的可控 vue技术栈：vue + vue-router + vuex + axiosreact技术栈：react + react路由 + redux + axios/fetch 组件通讯 Context特性 注意：如果不熟悉React中的数据流，不推荐使用这个属性 这是一个实验性的API，在未来的React版本中可能会被更改 作用：跨级传递数据（爷爷给孙子传递数据），避免向下每层手动地传递props 说明：需要配合PropTypes类型限制来使用 1234567891011121314151617181920212223242526272829303132333435363738394041class Grandfather extends React.Component { // 类型限制（必须），静态属性名称固定 static childContextTypes = { color: PropTypes.string.isRequired } // 传递给孙子组件的数据 getChildContext() { return { color: 'red' } } render() { return ( ) }}class Child extends React.Component { // 类型限制，静态属性名字固定 static contextTypes = { color: PropTypes.string } render() { return ( // 从上下文对象中获取爷爷组件传递过来的数据 爷爷告诉文字是红色的 ) }}class Father extends React.Component { render() { return ( ) }}","categories":[{"name":"react","slug":"react","permalink":"https://guoweiyanggithub.github.io/categories/react/"}],"tags":[{"name":"web前端","slug":"web前端","permalink":"https://guoweiyanggithub.github.io/tags/web前端/"},{"name":"React","slug":"React","permalink":"https://guoweiyanggithub.github.io/tags/React/"}]},{"title":"vue常见的面试题","slug":"vue常见的面试题","date":"2019-03-08T03:13:27.000Z","updated":"2019-03-14T03:15:33.068Z","comments":true,"path":"2019/03/08/vue常见的面试题/","link":"","permalink":"https://guoweiyanggithub.github.io/2019/03/08/vue常见的面试题/","excerpt":"","text":"####1.Vue组件之间怎么通信123456789101112131415父组件-->子组件方式：父组件给子组件绑定属性，子组件通过props属性来接收传递的数据注意：属性的值必须在组件中通过props属性指定，属性名必须与父组件中定义的一致。props可以是一个数组或对象 子组件-->父组件方式：在父组件中声明一个接受数据的函数,父组件给子组件绑定事件，子组件通过$emit触发事件，并且可在此时传递参数， 父组件通过定义好的监听事件接收参数兄弟组件之间的通信方式: 创建一个新Vue的实例，让各个兄弟共用同一个事件机制。（关键点） 传递数据方，通过事件触发$emit(方法名， 传递的数据)。 接收数据方，在mounted() 钩子函数(挂载实例) 中 触发事件$on(方法名， callback(接收数据的数据))， 此时callback函数中的this已经发生了改变， 可以使用箭头函数。 对于大型复杂的项目，采用vuex 状态管理更适合 ####2.常见指令123456789v-text:更新DOM对象的 textContentv-html:更新DOM对象的 innerHTMLv-bind:当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOMv-on:绑定事件v-for:基于源数据多次渲染元素或模板块v-if：根据表达式的值的真假条件，销毁或重建元素v-show：根据表达式之真假值，切换元素的 display CSS 属性v-pre:跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译v-once:只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能 ####3.怎么定义组件123全局定义：Vue.component(组件名, {template: 模板字符串})局部定义：components:{组件名: {template: 模板字符串}}单文件组件：包含template，script，style三部分 ####4.vue路由是怎么做的1浏览器URL中的哈希值（# hash）和 component的对应关系，一个哈希值对应一个组件 ####5.怎么请求数据的12345vue-resource提供了一个用来发送http请求的工具 http 这个工具可以通过 Vue.http访问 也可以通过 this.$http访问 用axios发送请求 ####6.谈谈组件化和模块化的区别12345678910组件化：组件化就是基于可重用的目的，将一个大的软件系统按照分离关注点的形式，拆分成多个独立的组件，主要目的就是减少耦合。一个独立的组件可以是一个软件包、web服务、web资源或者是封装了一些函数的模块。这样，独立出来的组件可以单独维护和升级而不会影响到其他的组件。 模块化：模块化的目的在于将一个程序按照其功能做拆分，分成相互独立的模块， 以便于每个模块只包含与其功能相关的内容，模块之间通过接口调用。将一个大的系统模块化之后，每个模块都可以被高度复用。 区别：模块化的目的是为了重用，模块化后可以方便重复使用和插拨到不同的平台，不同的业务逻辑过程中。 组件化的目的是为了解耦，把系统拆分成多个组件，分离组件边界和责任，便于独立升级和维护。 ####7.Vue的数据双向绑定原理123Vue在初始化实例的时候，会把data中所有的数据，用Object.defineProperty方法全部加给vm对象，这个时候，vm对象中的数据就有了set和get方法，set这个函数会在属性被赋值的时候自动调用，get这个函数会在属性被获取值的时候自动调用，用户获取到的属性的值，其实就是get方法的返回值。也就能实现双向绑定了 ####8.Vue全家桶1vue/vue-router/vuex/vue-resource/vue-cli ####9.Filter过滤器123作用：文本数据格式化 , 也就是: 将数据按照我们指定的一种格式输出过滤器可以用在两个地方：{{}}和 v-bind 表达式两种过滤器：1 全局过滤器 2 局部过滤器 ####10.Vue生命周期1234567891011121314151617181920一个组件从开始到最后消亡所经历的各种状态，就是一个组件的生命周期 beforeCreate() 说明：在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用 注意：此时，无法获取 data中的数据、methods中的方法created() 说明：这是一个常用的生命周期，可以调用methods中的方法、改变data中的数据beforeMounted() 说明：在挂载开始之前被调用,此时无法获取到el中的DOM元素mounted() 说明：此时，vue实例已经挂载到页面中，可以获取到el中的DOM元素，进行DOM操作beforeUpdated() 说明：数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。 注意：此处获取的数据是更新后的数据，但是获取页面中的DOM元素是更新之前的updated() 说明：组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作beforeDestroy() 说明：实例销毁之前调用。在这一步，实例仍然完全可用。 使用场景：实例销毁之前，执行清理任务，比如：清除定时器等destroyed() 说明：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 ####11.Vue项目是怎么搭建的1使用vue-cli快速搭建 ####12.小程序和vue的区别和联系12区别：微信小程序是运行在微信里的APP，vue是一个流行框架联系：微信小程序借鉴了vue的部分语法，但也有一些区别，例如：显示隐藏元素，v-show和hidden；事件处理：v-on和bindtap ####13.Vuex的使用和五个核心12主要用于大型、复杂的项目五个核心：state , getter , mutation , action , module ####14.vue中Tab栏怎么实现12每一个tab标题对应一个tab组件，并且每一个标题都有一个点击事件和传入的参数，在点击的时候tab组件接收参数来控制显示和隐藏也可以用路由实现，适用于全屏的tab ####15.Vue的兼容问题12Vue.js不支持IE8及以下版本，因为Vue.js使用了IE8不能模拟的ECMAScript5特性Vue.js支持所有兼容ECMAScript5的浏览器 ####16.在vue中获取dom元素1在vue中可以通过给标签加ref属性，就可以在js中利用$refs去引用它，从而操作该dom元素 ####17.VueX五大属性，存组件间函数的是什么1Mutations ####18.vue单页面 首屏加载怎么优化12341. 按需加载2. 基于DllPlugin 和 DllReferencePlugin 的 webpack 构建优化3. 异步组件4. 优化组件加载时机 ####19.什么是MVVM。分别描述一下你对MVVM优缺点的理解12345即：Model-View-ViewModel 它是一种基于前端开发的架构模式,其核心是提供对View 和 ViewModel 的双向数据绑定，这使得ViewModel 的状态改变可以自动传递给 View，即所谓的数据双向绑定。 MVVM不仅简化了业务与界面的依赖关系，还优化了数据频繁更新的解决方案，甚至可以说提供了一种有效的解决模式。MVVM用来做服务端是极其不适用的，因为：网络资源成本过高 开发成本过高 20.vue.js的view-model是如何工作的123Vue.js 是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。 ####21.vue中$set什么时候用1生成vue实例后，当再次给数据赋值时，有时候并不会自动更新到视图上去，此时使用 vm.$set实例方法，这也是全局 Vue.set方法的别名 ####22.你在vue中常用的事件有哪些12常用钩子函数：created updated常用绑定事件：click mouseenter mouseover mouseleave ####23.src文件夹中有哪些文件123456assets中是图片，字体等一些静态资源components中是组件filters中是过滤器router中是路由文件App.vue 根组件mian.js ####24.webpack打包的图片有哪些格式的1jpg png gif jpeg ####25.vuex里面怎么监测state的状态变化1在computed中写一个计算属性,返回state中的要被监视的属性,然后在watch中监听这个计算属性的变化 ####26.vue中destroy钩子函数什么时候使用1Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 ####27. vue中的router钩子函数以及导航守卫 ####28. vue中如何获取dom","categories":[{"name":"vue","slug":"vue","permalink":"https://guoweiyanggithub.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://guoweiyanggithub.github.io/tags/vue/"},{"name":"面试题","slug":"面试题","permalink":"https://guoweiyanggithub.github.io/tags/面试题/"}]},{"title":"webpack","slug":"webpack","date":"2019-03-08T03:06:51.000Z","updated":"2019-03-14T03:15:56.779Z","comments":true,"path":"2019/03/08/webpack/","link":"","permalink":"https://guoweiyanggithub.github.io/2019/03/08/webpack/","excerpt":"","text":"webpack 官网 bundle [ˈbʌndl] 捆绑，收集，归拢，把…塞入 121 webpack 将带有依赖项的各个模块打包处理后，变成了独立的浏览器能够识别的文件2 webpack 合并以及解析带有依赖项的模块 概述 webpack的两个特点：1 模块化 2 打包 webpack 是一个现代 JavaScript 应用程序的模块打包器(module bundler)webpack 是一个模块化方案（预编译）webpack获取具有依赖关系的模块，并生成表示这些模块的静态资源 四个核心概念：入口(entry)、输出(output)、加载器loader、插件(plugins) 123456模块化方案: webpack 和 requirejs（通过编写代码的方式将前端的功能，划分成独立的模块）browserify 是与 webpack 相似的模块化打包工具webpack 预编译 (在开发阶段通过webpack进行模块化处理, 最终项目上线, 就不在依赖于 webpack)requirejs 线上的编译( 代码运行是需要依赖与 requirejs 的 ) webpack起源 webpack解决了现存模块打包器的两个痛点： 1 Code Spliting - 代码分离 2 静态资源的模块化处理方案 webpack与模块 前端模块系统的演进 在webpack看来：所有的静态资源都是模块 webpack 模块能够识别以下等形式的模块之间的依赖： JS的模块化规范： ES2015 import export CommonJS require() module.exports AMD define 和 require 非JS等静态资源： css/sass/less 文件中的 @import 图片连接，比如：样式 url(...) 或 HTML 字体 等 webpack文档和资源 webpack 中文网 webpack 1.0 webpack 2.x+ 入门Webpack，看这篇就够了 安装webpack 全局安装：npm i -g webpack 目的：在任何目录中通过CLI使用 webpack 这个命令 本地安装：npm i -D webpack （推荐！！！） 目的：执行当前项目的构建 webpack的基本使用 安装：npm i -D webpack webpack的两种使用方式：1 命令行 2 配置文件（webpack.config.js） 1 运行webpack ./src/main.js -o ./dist/bundle.js进行打包构建，语法是：webpack 入口文件 输出文件 2 注意：需要在页面中引入 输出文件 的路径（此步骤可通过配置webpack去掉） 命令行使用说明 package.json中的scripts中可以存放一些bash命令，这些bash命令可以通过 npm run 命令名称 来执行 注意：npm在执行scripts中的命令的时候，是在电脑系统后台默认开启一个bash，将当前目录下的./node_modules/bin这个文件夹临时加入了系统环境变量 使用方式：npm run dev 123\"scripts\": { \"build\": \"webpack\"} 命令行方式演示 - 案例：隔行变色123456789101112/* src/main.js*/// 1 导入 jQueryimport $ from 'jquery'// 2 获取页面中的li元素const $lis = $('#ulList').find('li')// 3 隔行变色// jQuery中的 filter() 方法用来过滤jquery对象$lis.filter(':odd').css('background-color', '#def')$lis.filter(':even').css('background-color', 'skyblue') 配置文件方式（推荐）1234567891011121314151617181920/* webpack.config.js 运行命令：webpack entry 入口的配置说明： https://doc.webpack-china.org/concepts/entry-points*/var path = require('path')module.exports = { // 入口文件 entry: path.join(__dirname, 'src/js/main.js'), // 输出文件 output: { path: path.join(__dirname, './dist'), // 输出文件的路径 filename: 'bundle.js' // 输出文件的名称 }} webpack-dev-server 安装：npm i -D webpack-dev-server 作用：配合webpack，创建开发环境（启动服务器、监视文件变化、自动编译、刷新浏览器等），提高开发效率 注意：无法直接在终端中执行 webpack-dev-server，需要通过 package.json 的 scripts 实现 使用说明 注意：webpack-dev-server将打包好的文件存储在内存中，提高编译和加载速度，效率更高 注意：输出的文件被放到项目根目录中 命令行中的提示：webpack output is served from / 在index.html页面中直接通过 /bundle.js 来引入内存中的文件 配置说明 - CLI配置 --contentBase ：告诉服务器在哪个目录中提供服务（可以理解为：打开哪个目录中的index.html） --contentBase ./：当前工作目录 --contentBase ./src：当前目录下的src文件夹 --open ：自动打开浏览器 --port ：端口号 --hot ：热更新，只加载修改的文件(按需加载修改的内容)，而非全部加载 12345678/* package.json *//* 运行命令：npm run dev */{ \"scripts\": { \"dev\": \"webpack-dev-server --contentBase ./src --open --port 8888 --hot\" }} 配置说明 - webpack.config.js12345678910111213141516171819const webpack = require('webpack')devServer: { // 服务器的根目录 Tell the server where to serve content from // https://webpack.js.org/configuration/dev-server/#devserver-contentbase contentBase: path.join(__dirname, './'), // 自动打开浏览器 open: true, // 端口号 port: 8888, // --------------- 1 热更新 ----------------- hot: true},plugins: [ // ---------------- 2 启用热更新插件 ---------------- new webpack.HotModuleReplacementPlugin()] html-webpack-plugin 插件 安装：npm i -D html-webpack-plugin 作用：根据模板，自动生成html页面 优势：页面存储在内存中，自动引入bundle.js、css等文件 123456789101112/* webpack.config.js */const htmlWebpackPlugin = require('html-webpack-plugin')// ...plugins: [ new htmlWebpackPlugin({ // 模板页面路径 template: path.join(__dirname, './index.html'), // 在内存中生成页面路径，默认值为：index.html // filename: 'index.html' })] Loaders（加载器） webpack - Loaders webpack - 管理资源示例 webpack enables use of loaders to preprocess files. This allows you to bundle any static resource way beyond JavaScript. webpack只能处理JavaScript资源 webpack通过loaders处理非JavaScript静态资源 CSS打包 1 CSS打包文件（加载） 2 SASS打包文件（编译为CSS） 使用webpack打包CSS 安装：npm i -D style-loader css-loader 注意：use中模块的顺序不能颠倒，加载顺序：从右向左加载 1234567891011121314151617/* index.js */// 导入 css 文件import './css/app.css'/* webpack.config.js */// 配置各种资源文件的loader加载器module: { // 配置匹配规则 rules: [ // test 用来配置匹配文件规则（正则） // use 是一个数组，按照从后往前的顺序执行加载 {test: /\\.css$/, use: ['style-loader', 'css-loader']}, ]} 使用webpack打包sass文件 安装：npm i -D sass-loader node-sass 注意：sass-loader 依赖于 node-sass 模块 123456789101112/* webpack.config.js */// 参考：https://webpack.js.org/loaders/sass-loader/#examples// \"style-loader\" ：creates style nodes from JS strings 创建style标签// \"css-loader\" ：translates CSS into CommonJS 将css转化为CommonJS代码// \"sass-loader\" ：compiles Sass to CSS 将Sass编译为cssmodule:{ rules:[ {test: /\\.(scss|sass)$/, use: ['style-loader', 'css-loader', 'sass-loader']}, ]} 图片和字体打包 安装：npm i -D url-loader file-loader file-loader：加载并重命名文件（图片、字体 等） url-loader：将图片或字体转化为base64编码格式的字符串，嵌入到样式文件中 1234567891011/* webpack.config.js */module: { rules:[ // 打包 图片文件 { test: /\\.(jpg|png|gif|jpeg)$/, use: 'url-loader' }, // 打包 字体文件 { test: /\\.(woff|woff2|eot|ttf|otf)$/, use: 'file-loader' } ]} 图片打包细节 limit参数的作用：（单位为：字节(byte)） 当图片文件大小（字节）小于指定的limit时，图片被转化为base64编码格式 当图片文件大小（字节）大于等于指定的limit时，图片被重命名以url路径形式加载（此时，需要file-loader来加载图片） 图片文件重命名，保证相同文件不会被加载多次。例如：一张图片（a.jpg）拷贝一个副本（b.jpg），同时引入这两张图片，重命名后只会加载一次，因为这两张图片就是同一张 文件重命名以后，会通过MD5加密的方式，来计算这个文件的名称 123456789101112131415161718/* webpack.config.js */module: { rules: [ // {test: /\\.(jpg|png|gif|jpeg)$/, use: 'url-loader?limit=100'}, { test: /\\.(jpg|png|gif|jpeg)$/, use: [ { loader: 'url-loader', options: { limit: 8192 } } ] } ]} 字体文件打包说明 处理方式与图片相同，可以使用：file-loader或url-loader babel babel es2015-loose babel全家桶 安装：npm i -D babel-core babel-loader 安装：npm i -D babel-preset-env 基本使用（两步） 第一步： 12345678/* webpack.config.js */module: { rules: [ // exclude 排除，不需要编译的目录，提高编译速度 {test: /\\.js$/, use: 'babel-loader', exclude: /node_modules/} ]} 第二步：在项目根目录中新建.babelrc配置文件 123456/* .babelrc */// 将来babel-loader运行的时候，会检查这个配置文件，并读取相关的语法和插件配置{ \"presets\": [\"env\"]} babel的说明babel的作用 1 语法转换：将新的ES语法转化为浏览器能识别的语法（babel-preset-*） var fn = () => {} 2 transform-runtime 浏览器兼容：让低版本浏览器兼容最新版ES的API babel-preset-* 作用：将新的ES语法转化为浏览器能识别的ES5代码 比如：babel-preset-es2015就是转化ES2015这个版本的JS语法 ES6语法提案的批准流程 ES2015 也就是 ES6, 下一个版本是ES7, 从 ES6 到 ES7之间经历了 5 个阶段 12345Stage 0 is \"i've got a crazy idea\",stage 1 is \"this idea might not be stupid\",stage 2 is \"let's use polyfills and transpilers to play with it\",stage 3 is \"let's let browsers implement it and see how it goes\",stage 4 is \"now it's javascript\". transform-runtime 作用：实现浏览器对不支持API的兼容（兼容旧环境、填补） transform-runtime 安装：npm i -D babel-plugin-transform-runtime 和 npm i -S babel-runtime 注意：babel-runtime包中的代码会被打包到你的代码中（-S） 12345678/* transform-runtime 的使用步骤： 1 在 .bablerc 中，添加如下配置即可*/\"plugins\": [ \"transform-runtime\"] 总结1234567babel-core babel核心包babel-loader 用来解析js文件babel-preset-* 新ES语法的解析和转换transform-runtime 兼容旧浏览器，到达支持新API目的","categories":[{"name":"webpack","slug":"webpack","permalink":"https://guoweiyanggithub.github.io/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://guoweiyanggithub.github.io/tags/webpack/"},{"name":"babel","slug":"babel","permalink":"https://guoweiyanggithub.github.io/tags/babel/"}]},{"title":"通过npm发布包","slug":"通过npm发布包","date":"2019-03-08T02:59:00.000Z","updated":"2019-03-14T03:16:13.309Z","comments":true,"path":"2019/03/08/通过npm发布包/","link":"","permalink":"https://guoweiyanggithub.github.io/2019/03/08/通过npm发布包/","excerpt":"","text":"npm发布包 1 注册npmjs账号 2 创建项目文件夹 3 创建package.json文件 4 创建index.js，并实现一些基本功能 5 创建README.md文件，描述项目 6 发布：npm publish 12注意：发布前，需要切换到 npm 的仓库地址，命令：nrm use npm注意：发布前，需要先登录npm，执行命令：npm login 制作cli CLI： Command Line Interface 1 创建一个包 2 在包中创建一个js文件, 这个js文件就是使用命令是要执行的文件 3 在packge.json中添加bin配置项, 在bin中添加一个属性, 这个属性就是最终在命令行中使用的命令名称 4 将包发布到npm 5 全局安装这个包 6 此时, 就可以在命令中使用bin中添加到命令了 123456// #! node 作用：使用 node 执行当前文件#! nodeconsole.log('您的第一个CLI工具制作完成')// argv：获取用户传递的参数console.log(process.argv)","categories":[{"name":"npm","slug":"npm","permalink":"https://guoweiyanggithub.github.io/categories/npm/"}],"tags":[{"name":"通过npm发布包","slug":"通过npm发布包","permalink":"https://guoweiyanggithub.github.io/tags/通过npm发布包/"}]},{"title":"mongodb","slug":"mongodb","date":"2019-03-08T02:57:06.000Z","updated":"2019-03-14T03:15:15.549Z","comments":true,"path":"2019/03/08/mongodb/","link":"","permalink":"https://guoweiyanggithub.github.io/2019/03/08/mongodb/","excerpt":"","text":"MongoDB 数据库 mongodb 官网 mongodb 中文 MongoDB 是一个非关系型数据库，属于文档型数据库（NoSQL -> Not Only SQL） 对 JavaScript 兼容较好，和 Node.js 结合最好 Node全栈：MEAN（MongoDB、Express、Angular、Node.js） 关系型数据库和非关系型数据库的对比 关系型：数据库（db） -> 表（table） -> 记录/行（record）-> 字段 文档型：数据库（db） -> 集合（collection） -> 文档（document） -> 字段 123关系型数据库，使用前需要先创建数据库、创建表结构（表中的列的数据类型、大小等）、每张表和其他表之间可能会有主外键关系（表和表之间的引用关系）. 比如: mySqlmongodb 使用时，不需要事先创建表结构，mongodb 中没有表，只有集合，同时集合和集合之间也没有关系。mongodb 中保存的都是一个一个的类似于 json 对象的数据（bson） 安装 1 根据操作系统选择合适的安装程序（32位或64位） 2 直接安装程序 3 配置环境变量，通过命令：mongod --version看是否安装成功 4 注意：MongoDB最新版的安装包已经不再支持32位的windows操作系统了 123456解决mongodb安装时出错 “mongodb 无法启动此程序，因为计算机中丢失 api-ms-win-crt-runtime-l1-1-0.dll”，安装 vc_redist.x64.exehttps://helpx.adobe.com/tw/creative-cloud/kb/error_on_launch.html通过指定其他电脑的ip地址，就可以使用其他电脑中的MongoDB数据库了：var url = 'mongodb://localhost:27017' 启动 1 通过命令：mongod 启动 mongodb数据库服务（不要关闭） 2 重新开启一个cmd，输入命令：mongo 就可以连接到mongod服务了 123451 在 C中创建 data文件夹, 在data文件夹中创建 db文件2 在终端中输入命令: mongod ,就可以启动mongodb数据库服务了创建 c:\\data\\db 的目的: 告诉 mongodb 数据存储到这个文件夹中, 但是, 只能在C盘中启动 mongod如果需要在 D盘 启动, 需要在 D中也创建 data/db 目录 123456# 终端1 -- 启动服务mongod# 终端2 -- 连接到服务# 此时，就可以在 终端 对数据库进行操作了mongo 数据库存储路径的说明 windows32位系统 安装MongoDB 注意：mongod 会在执行命令的磁盘根目录中查找 data/db 目录作为数据库文件存储路径 可以通过命令：mongod --dbpath 路径 修改默认配置 123456# 64位：mongod --dbpath C:\\data\\db# 32位：mongod --dbpath 数据存储路径 --journal --storageEngine=mmapv1mongod --dbpath c:\\data\\db --journal --storageEngine=mmapv1 连接到数据库的说明 mongo命令默认连接 MongoDB 服务：127.0.0.1:27017 可以通过下面的命令指定连接的主机名和端口号： 1mongo --host 127.0.0.1 --port 27017 MongoDB数据存储结构说明数据库 -> 集合（表） -> 文档（行）database 数据库collections 集合 MongoDB终端操作 注意：以下操作都是在执行 mongo 窗口完成 查看所有数据库： show dbs 注意：我们自己创建的数据库，没有数据前，不会显示 切换（创建）数据库： use 数据库名称 说明：数据库存在，use表示切换数据库；数据库不存在，use会自动创建 查看当前正在使用的数据库： db 查看当前数据库的集合： show collections 删除数据库: db.dropDatabase() 12itcast 是数据库users 是集合( 表 ) 插入数据（文档） 语法：db.集合名称.insert({}) 说明: 在 mongodb 中不需要提前创建”表”, 直接通过 db.表名称.inseret() 就可以往表中添加数据了 12345// 插入一条db.users.insert({name: 'jack', age: 18, gender: 'male'})// 插入多条db.users.insertMany([{name: 'tom', age: 19}, {name: 'jerry', age: 20}]) 查询数据 语法：db.集合名称.find() 12345678// 查询所有数据db.users.find()// 美化输出格式：db.集合名称.find().pretty()// 指定条件查询：db.集合名称.find({name: 'jack'}) 修改数据 语法：db.集合名称.updateOne(条件, 更新后的数据) 1234567// 修改name属性为jack的数据，将age改为20// 第一个参数: 表示要修改哪个数据, 会根据指定的name属性, 去查找值为jack的数据// 第二个参数: 表示修改修改后的数据, 会修改 age 属性的值为 20db.users.updateOne({name: 'jack'}, {$set: {age: 20}})// 修改age大于19岁的文档，将name设置为 中年人db.users.updateMany({age: {$gt: 19}},{$set: {name: '中年人'}}) 删除数据 语法：db.集合名称.deleteOne(条件) 123456// 删除 age 为18的数据：// 参数: 删除条件db.users.deleteOne({age: 18})// 删除所有name为jack的文档db.users.deleteMany({ name: 'jack' }) MondoDB 查询语句 操作 格式 示例 SQL语句 等于 {} db.col.find({ name :’jack’}) where name = ‘jack’ 小于 $lt db.col.find({ age: {$lt:18}}) where age < 18 小于或等于 $lte db.col.find({ age: {$lte:18}}) where age 18 大于或等于 $gte db.col.find({ age: {$gte:18}}) where age >= 18 不等于 $ne db.col.find({ age: {$ne:18}}) where age != 18 在 node 中操作 MongoDB 安装：npm i -S mongodb 1234567891011121314151617181920// 导入 mongodb，并获取到客户端对象var MongoClient = require('mongodb').MongoClient// 连接数据库服务地址var url = 'mongodb://localhost:27017'// 连接数据库MongoClient.connect(url, function (err, client) { if (err) { return console.log('链接数据库失败', err) } console.log('数据库链接成功'); // 获取数据库对象 var db = client.db('nodedb') // 关闭数据库链接 client.close()}) 数据增删改查 添加数据： 123456789101112var db = client.db('nodedb')// 添加db.collection('users') // 添加一条数据 .insert({name: 'rose', age: 19}, function (err, data) { console.log(data); }) // 添加多条数据 .insertMany([{ name: 'tom', age: 20 }, { name: 'jerry', age: 21 }], function (err, data) { console.log(data); }) 查询数据： 123456var db = client.db('nodedb')// 查询db.collection('users').find().toArray(function (err, data) { console.log(data)}) 删除数据： 1234567891011var db = client.db('nodedb')db.collection('users') // 删除一条数据： .deleteOne({name: 'rose'}, function (err, result) { console.log(result); }) // 删除多条数据： .deleteMany({age: {$lt: 20}}, function (err, result) { console.log(result); }) 修改数据： 123456var db = client.db('nodedb')db.collection('users') .update({ name: 'tom' }, { $set: { age: 22 } }, function (err, result) { console.log(result); })","categories":[{"name":"mongodb数据库","slug":"mongodb数据库","permalink":"https://guoweiyanggithub.github.io/categories/mongodb数据库/"}],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"https://guoweiyanggithub.github.io/tags/mongodb/"}]},{"title":"nodeJS","slug":"nodeJS","date":"2019-03-08T02:51:42.000Z","updated":"2019-03-14T03:15:21.725Z","comments":true,"path":"2019/03/08/nodeJS/","link":"","permalink":"https://guoweiyanggithub.github.io/2019/03/08/nodeJS/","excerpt":"","text":"官方介绍 NodeJS官网 NodeJS中文网 Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. Node.js’ package ecosystem, npm, is the largest ecosystem of open source libraries in the world. 123456789Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。runtime 运行时（运行环境）PHP代码要想运行需要借助于Apache这个服务器（运行时，运行环境）JavaScript代码想要运行：需要有一个JavaScript的运行时即可 在web端，浏览器就可以看作JS的运行时 在Node端，Node就是JS的运行时 理解Node Node.js 是一个开发平台，就像PHP开发平台、Java开发平台、.Net开发平台、Apple开发平台一样。 开发平台：有对应的编程语言、有语言运行时、有能实现特定功能的API 编程语言：JavaScript 运行时：Chrome V8 JavaScript引擎 特定功能API：文件操作、网络操作 等 问题：在Node中能够操作DOM、BOM吗？？？ 不能！！！ 浏览器和Node中公共的部分是：ECMAScript 特点 非阻塞 异步I/O（input/output） 事件驱动 单线程 一切都在并行执行 —— 除了你的代码（Evetything runs in parallel — except your code.） 跨平台 123456Node 适合做： I/O密集型操作，比如：文件操作 高并发处理Node 不适合做： CPU密集型操作：大量长时间的计算 能做什么 提供服务端编程能力 开发 Web应用程序（网站）、控制台程序（命令行程序、CLI程序）、桌面应用程序（GUI）（借助 node-webkit、electron 等框架实现） 1 操作数据库 2 网站后台开发，为前台提供接口 其他参考资料 JavaScript 标准参考教程（alpha） Node.js背后的V8引擎优化技术 CNODE社区 Web开发本质 1 请求，客户端发起请求 2 处理，服务器处理请求 3 响应，服务器将处理结果发送给客户端 安装Node 下载地址 官网术语解释 LTS 版本：Long-term Support 版本，长期支持版，即稳定版。 Current 版本：Latest Features 版本，最新版本，新特性会在该版本中最先加入。 验证是否安装成功：在终端输入 node -v，如果打印出版本号，即安装成功 nodejs 初体验 1 helloworld.js 第一个node程序 2 文件操作 - 读文件 3 文件操作 - 写文件 4 http操作 - 开启服务 NodeJS 你好 1 创建js文件 helloworld.js 2 写入：console.log('hello nodejs') 3 打开命令窗口 cmd 4 执行命令：node helloworld.js 12345说明： node命令 实际上调用的是 node.exe 这个可执行文件 通过 node.exe 读取执行 helloworld.js 文件中的代码，并执行通过node运行js代码的过程，类似于：浏览器加载 html页面，并执行script标签中的js代码 练习：打印三角形 123456789// process.stdout 标准输出，将内容输出到终端中显示// 特点：不换行for (var i = 0; i < 10; i++) { for (var j = 0; j 属性 --> 高级系统设置 --> 高级 --> 环境变量 环境变量添加的两种方式 MAC 环境变量 1 直接将可执行程序所在目录配置到PATH中 F:\\devFiles\\Git 2 新建（用户）环境变量 FEIQ_HOME，使用 %FEIQ_HOME% 配置到PATH中 变量名：FEIQ_HOME 变量值：F:\\devFiles\\Git（不带分号） 输入命令执行过程 1 首先在当前路径目录中查找和改字符串匹配的可执行文件 2 进入用户 path 环境变量查找 3 进入系统 path 环境变量查找 REPL介绍 REPL 全称: Read-Eval-Print-Loop（交互式解释器） R 读取 - 读取用户输入，解析输入的 Javascript数据结构并存储在内存中 E 执行 - 执行输入的数据结构 P 打印 - 输出结果 L 循环 - 循环操作以上步骤直到用户两次按下 ctrl + C 退出 在REPL中编写程序（类似于浏览器开发人员工具中的控制台功能） 进入：直接在控制台输入 node 命令进入 REPL 环境 退出：按两次 ctrl + C 退出REPL界面 或者 输入 .exit 退出 注意：进入Node的REPL后，只能写JavaScript代码 Buffer和字符编码Node.js 目前支持的字符编码包括： ascii 仅支持 7位 ASCII 数据。如果设置去掉高位的话，这种编码方法是非常快的。 utf8 多字节编码的Unicode字符。许多网页和其他文档格式使用 UTF-8 。 utf16le 2或4个字节，小端编码的Unicode字符。支持代理对（U+10000 to U+10FFFF）。 ucs2 是 utf16le 的别名。 base64 Base64 字符串编码。当从一个字符串创建一个 buffer 时，按照 RFC 4648, Section 5 里的规定，这种编码也将接受正确的“URL和文件名安全字母”。 binary 一种把 buffer 编码成一字节（latin-1）编码字符串的方式。目前不支持 latin-1 字符串。通过 binary 来代替 latin-1 使用 latin-1 编码。 hex 将每个字节编码为两个十六进制字符。 123456// 使用:var buf = Buffer.from('hello world', 'ascii')console.log(buf.toString('hex'))// 默认情况: buf.toString() 相当于buf.toString('utf8') 根据不同请求输出不同响应数据 request.url req.url：获取请求路径 例如：请求http://127.0.0.1:3000/index 获取到的是：/index 例如：请求http://127.0.0.1:3000/ 获取到的是：/ 例如：请求http://127.0.0.1:3000 获取到的是：/ 服务器响应文件 注意：浏览器中输入的URL地址，仅仅是一个标识，不与服务器中的目录一致。也就是说：返回什么内容是由服务端的逻辑决定 123456789101112server.on('request', function(req, res) { var url = req.url if(url === '/') { fs.readFile('./index.html', function(err, data) { if(err) { return res.end('您访问的资源不存在~') } res.end(data) }) }}) 模拟Apache服务器 根据 req.url 读取不同的页面内容，返回给浏览器 MIME类型 MIME(Multipurpose Internet Mail Extensions)多用途Internet邮件扩展类型 是一种表示文档性质和格式的标准化方式 浏览器通常使用MIME类型（而不是文件扩展名）来确定如何处理文档；因此服务器将正确的MIME类型附加到响应对象的头部是非常重要的 MIME 类型 mime模块 作用：获取文件的MIME类型 安装：npm i mime 123456var mime = require('mime')// 获取路径对应的MIME类型mime.getType('txt') // ⇨ 'text/plain'// 根据MIME获取到文件后缀名mime.getExtension('text/plain') // ⇨ 'txt' url模块 说明：用于 URL 处理与解析 注意：通过url拿到的查询参数都是字符串格式 12345678// 导入url模块var url = require('url')// 解析 URL 字符串并返回一个 URL 对象// 第一个参数：表示要解析的URL字符串// 第二个参数：是否将query属性（查询参数）解析为一个对象，如果为：true，则query是一个对象var ret = url.parse('http://localhost:3000/details?id=1&name=jack', true)console.log(ret.query) // { id: '1', name: 'jack' } querystring模块 用于解析与格式化 URL 查询字符串 注意：只在专门处理查询字符串时使用 123456// foo=bar&abc=xyz&abc=123var querystring = require('querystring')// 将查询参数转化为对象// 第一个参数: 要解析的 URL 查询字符串querystring.parse('foo=bar&abc=xyz') // { foo: 'bar', abc: 'xyz' } 服务端重定向 HTTP 状态码说明 301 和 302 说明：服务端可以通过HTTP状态码让浏览器中的页面重定向 123res.writeHead(302, { 'Location': '/'}) POST请求参数的处理 说明：POST请求可以发送大量数据，没有大小限制 12345678910111213// 接受POST参数var postData = []// data事件：用来接受客户端发送过来的POST请求数据req.on('data', function (chunk) { postData.push(chunk)})// end事件：当POST数据接收完毕时，触发req.on('end', function () { var result = Buffer.concat(postData) console.log(result.toString())}) 其他模板引擎 ejs underscore jade/pug art-template 安装：npm i ejs 安装：npm i underscore 安装：npm i pug 安装：npm i art-template 123456789101112// art-template 示例：// 1. 使用模板文件var html = template('模板文件路径', { name: 'rose', food: '西红柿'})console.log(html)// 2. 使用模板字符串var render = template.compile(\"hello: \")var ret = render({ name: 'moe' })console.log(ret) node 中的模块化 一个js文件就是一个模块 每个模块都是一个独立的作用域 模块分类 1 核心模块 由 node 本身提供，不需要单独安装（npm），可直接引入使用 2 第三方模块 由社区或个人提供，需要通过npm安装后使用 3 自定义模块 由我们自己创建，比如：app.js 核心模块 fs：文件操作模块 http：网络操作模块 基本使用：1 先引入 2 再使用 12// 引入模块var fs = require('fs') 第三方模块 第三方模块是由 社区或个人 提供的 比如：mime模块/art-template/jquery… 基本使用：1 先通过npm下载 2 再引入 3 最后使用 用户自定义模块 由开发人员创建的模块（JS文件） 基本使用：1 创建模块 2 引入模块 注意：自定义模块的路径必须以./开头 1234// 加载模块require('./a') // 推荐使用，省略.js后缀！require('./a.js') 模块化规范的使用 1 加载模块：require('fs') 2 导出模块：module.exports 或 exports module.exports 和 exports 的关系 模块中默认导出：module.exports exports 是 module.exports 的引用 注意：给 module.exports 赋值会切断与 exports 之间的联系 1 直接添加属性两者皆可 2 赋值操作时，只能使用 module.exports 12345678console.log( module.exports === exports ) // ==> true// 等价操作module.exports.num = 123exports.num = 123// 赋值操作：不要使用 exports = {}module.exports = {} 第三方模块（以mime包为例） 先基于当前文件模块所属目录找 node_modules 目录 如果找到，则去该目录中找 mime 目录 如果找到 mime 目录，则找该目录中的 package.json 文件 如果找到 package.json 文件，则找该文件中的 main 属性 如果找到 main 属性，则拿到该属性对应的文件路径 如果找到 mime 目录之后 发现没有 package.json 或者 有 package.json 没有 main 属性 或者 有 main 属性，但是指向的路径不存在 则 node 会默认去看一下 mime 目录中有没有 index.js index.node index.json 文件 如果找不到 index 或者找不到 mime 或者找不到 node_modules 则进入上一级目录找 node_moudles 查找规则同上 如果上一级还找不到，继续向上，一直到当前文件所属磁盘根目录 如果最后到磁盘根目录还找不到，最后报错：can not find module xxx CommonJS 规范参考文档 module (模块) CommonJS规范 浅析JS模块规范：AMD，CMD，CommonJS npm - Node包管理工具 node package manager npm官网 npm is the package manager for JavaScript and the world’s largest software registry. Discover packages of reusable code — and assemble them in powerful new ways. 12npm 是JavaScript的包管理工具，并且是全球最大的软件登记处发现可重用代码的包 - 并以强有力的新方式进行组装。 理解：通过npm来快速安装开发中使用的包 只要安装了node.exe，那么就可以使用npm了 npm的基本使用 1 初始化package.json文件：npm init -y 2 安装项目中用到的包：npm install 包名称 --save package.json 概述：包（项目）描述文件，用来管理组织一个包（项目），它是一个纯JSON格式的 包描述文件：描述自己、描述自己对别人的依赖关系 初始化npm配置文件：npm init 或 npm init -y快速生成 作用：不用拷贝项目依赖项，只需要使用package.json，通过npm i就可以安装项目所有依赖项 命令：npm i安装项目所有的依赖项（包括开发依赖） 命令：npm i --production安装项目依赖项（不包括开发依赖） 常用命令 安装包：npm install 包名称，简写：npm i 包名称 安装指定版本的包：npm install 包名称@版本号 全局安装：npm i -g nodemon （-g 是 –global的简写） 项目依赖安装：npm i -S jquery （-S 是 –save的简写） --save或-S的作用: 往 package.json 中的dependencies里面添加包,但是现在已经不需要了, 只要安装包, 就会自动往 dependencies 写配置项 npm i jquery 相当于: npm i -S jquery 相当于: npm install jquery --save 项目开发依赖安装：npm i -D less（仅在开发期间使用，上线的项目中不会用到） -D是：--save-dev的简写 其他操作 查看版本：npm -v 删除包：npm uni 包名称 -S 1234解决包下载错误问题的方式：1 将 C:\\Users\\当前登录用户\\AppData\\Roaming 目录中的 npm-cache 文件夹删除，然后，再重新下载包，一般就不会有问题了2 npm cache clean --force 本地安装和全局安装 全局安装的意义：只是为了可以当做命令行使用而已，即：在任意目录中都可以使用某个命令 npm的常用命令1234561 全局安装( 只要安装一次 ) npm i -g less / npm i less -g2 本地安装( 随着项目走, 一个项目安装一次 ) npm i jquery 表示作为项目依赖安装, 不管开发期间还是线上代码, 都要用到这个包 npm i -D less -D 表示这个包只在开发期间使用, 线上的代码是不会用到这个包的 npm下载加速淘宝镜像和cnpm 淘宝镜像 安装：npm i cnpm -g --registry=https://registry.npm.taobao.org 123# 设置淘宝镜像npm config set registry https://registry.npm.taobao.org --globalnpm config set disturl https://npm.taobao.org/dist --global 前端渲染和后端渲染 前端渲染：前台页面ajax请求，获取后端数据，通过拼接字符串或者模板引擎将数据组装为HTML，并展示给用户 后端渲染：也叫后端直出，由后台拿到数据并且渲染页面，然后，将拼接好的html结构返回给浏览器 前后端合作开发模式 1 前后端混合开发 套模板：前端写好静态页面，后端将静态页面修改为后端可以使用的模板页面，并渲染页面 劣势：后端等前端把页面写好（后端依赖于前端） 2 前后端半混合开发 前端写好页面，一部分由后端渲染，一部分由前端渲染 哪部分适合后端渲染？首页（ 首屏加载时间，衡量网站性能的重要标准，网络请求尽可能少 ） 哪部分适合前端渲染？首页下面的列表页，当滚动到某个位置的时候，才会加载这块内容，所以，这些内容是适合做前端渲染的 3 前后端分离（职责的分离） 前端写好页面，并渲染数据，后端只提供数据接口 也可以使用后端渲染 mock 假数据","categories":[{"name":"nodeJS","slug":"nodeJS","permalink":"https://guoweiyanggithub.github.io/categories/nodeJS/"}],"tags":[{"name":"nodeJS","slug":"nodeJS","permalink":"https://guoweiyanggithub.github.io/tags/nodeJS/"}]},{"title":"手机端常用知识","slug":"手机端常用知识","date":"2019-03-08T02:30:56.000Z","updated":"2019-03-14T03:16:06.461Z","comments":true,"path":"2019/03/08/手机端常用知识/","link":"","permalink":"https://guoweiyanggithub.github.io/2019/03/08/手机端常用知识/","excerpt":"","text":"1234谷歌浏览器 苹果浏览器、 UC浏览器 QQ浏览器 欧朋浏览器 百度手机浏览器 360安全浏览器 搜狗浏览器 猎豹浏览器等国内的手机浏览器都是根据webkit内核修改过来的，国内没有自主研发的内核，国内的操作系统也是基于Android系统修改的。因此在移动端，css3属性只需要加webkit前缀即可。 移动端设备尺寸不一样(尺寸非常多，碎片化很严重) 12Android： 320*480 480*800 540*960 720*1280 1080*1920 2k屏 4k屏iphpne： 640*960 640*1136 750*1334 1242*2208 移动端开发分类 原生app（native app） 混合app（Hybrid app） web应用（webApp） 原生app（native app） 原生app是基于操作系统的开发，比如安卓，ios，windows phone,他们只能在各自的操作系统上运行。 优点： 可以访问操作系统，获取更多的资源（gps，摄像头，传感器，麦克风等） 速度快，性能高，用户体验好 可以离线使用 缺点： 开发成本高 需要安装和更新，更新与发布需要审核。 Web App Web应用使用H5C3开发页面，为浏览器设计的基于web的应用，可以在各种智能设备的手机浏览器上运行。不需要安装即可运行。 优点： 支持设备广泛 开发成本低（使用） 可以随时上线与更新，无需审核 缺点： 用户体验极度依赖网速 要求联网 无法获取手机的资源（gps，摄像头） 混合app（Hybrid App） Hybrid App是指介于web-app、native-app这两者之间的app,它虽然看上去是一个Native App，但只有一个UI WebView，里面访问的是一个Web App。（淘宝、京东、手机百度） Hybird App说白了就是使用了Native app的壳，里面其实还是HTML5页面。 优点： 开发成本和难度更低，兼容多个平台 也可以访问手机的操作系统资源。 更新维护更方便 缺点： 用户体验相比原生app稍差。 性能依赖于网速 总结： 三种开发各有优缺点，具体用什么需要根据实际情况而定，比如预算，app注重功能还是内容等。 屏幕与分辨率 移动设备与PC设备最大的差异在于屏幕，这主要体现在屏幕尺寸和屏幕分辨率两个方面。 屏幕尺寸通常我们所指的屏幕尺寸，实际上指的是屏幕对角线的长度（一般用英寸来度量）如下图所示 1英寸 = 2.54厘米 屏幕分辨率分辨率则一般用像素来度量，表示屏幕水平和垂直方向的像素数，例如1920*1080指的是屏幕垂直方向和水平方向分别有1920和1080个像素点而构成，如下图所示,分辨率越高，越清晰。 像素：指计算机显示设备中的最小单位，即一个像素点的大小。 像素是相对长度单位，在屏幕分辨率越高的设备，像素点越小，屏幕分辨率越低，像素点越大。 像素密度ppi(了解)PPI（Pixels Per Inch）值来表示屏幕每英寸的像素数 利用 勾股定理 我们可以计算得出PPI PPI值的越大说明单位尺寸里所能容纳的像素数量就越多，所能展现画面的品质也就越精细，反之就越粗糙。 结论：当PPI 越大，展示的画质越精细。 设备独立像素 随着技术发展，设备不断更新，出现了不同PPI的屏幕共存的状态,给我们开发带来的问题 做为用户是不会关心这些细节的，他们只是希望在不同PPI的设备上看到的图像内容差不多大小，所以这时我们需要一个新的单位，这个新的单位能够保证图像内容在不同的PPI设备看上去大小应该差不多，这就是独立像素,也叫（设备无关像素），在IOS设备上叫PT，Android设备上叫DP，在css中，叫PX。 123ptdppx: css像素 获取设备的像素比 1window.devicePixelRatio //物理像素与独立像素的比值 2倍图与3倍图（重要） 以后同学在工作的过程中，从UI那拿到的设计图通常都是640的设计图或者是750的设计图. 把更多的像素点压缩至一块屏幕里，从而达到更高的分辨率并提高屏幕显示的细腻程度。 设备像素比devicePixelRatio：即像素的压缩比例 结论 ：在移动端为了在高清屏手机上显示得更加细腻，通常会使用更大的图片，比如2倍图或者3倍图。 【演示：2倍图】 视口viewport（重要）1234567891011121314151617问题：一个电脑上的网站，在手机端访问，效果是什么样的？1. 在手机端，html的大小都是980px，为什么？这主要是历史原因导致的，因为在移动设备刚流行的时候，网站大多都是pc端的，pc端的页面宽度一般都比较大，移动设备的宽度比较小，如果pc端页面直接在移动端显示的话，页面就会错乱。为了解决这个问题，移动端html的大小直接就定死成了980px（因为早起的pc端网站版心就是980px居多）。2. 视口在pc端，html的大小默认是继承了浏览器的宽度，即浏览器多宽，html的大小就是多宽，但是在移动端，多出来了一个视口的概念（乔布斯）,视口说白了就是介于浏览器与html之间的一个东西，视口的宽度默认定死了980px，因此html的宽度默认就是980px，视口的特点是能够根据设备的宽度进行缩放。3. 视口设置。对于现在的移动端页面来说，视口默认为980px肯定不合适，因为设备宽度不够的话，视口会进行缩放，导致页面展示效果不好看。 视口参数设置 12345678910111213141516171819//width 设置视口的宽度//width=device-width 设置视口宽度为设备的宽度（常用）。//initial-scale 设置初始缩放比例//initial-scale=1.0 表示不缩放//user-scalable 设置是否允许用户缩放//user-scalable=no 不允许用户缩放//maximum-scale 设置允许的最大缩放比例//maximum-scale=1.0 可以不设置，因为都禁止用户缩放了。//minimum-scale 设置允许最小缩放比//minimum-scale=1.0 不设置，因为都禁用用户缩放了。//标准写法：//快捷键： meta:vp + tab键 移动端调试问题 模拟器调试 真机调试：使用手机进行访问。 手机设备五花八门，屏幕尺寸都大不一样，尤其是安卓端，给我们的页面预览带来了一些麻烦。在实际工作中，作为开发者不可能有足够的设备让我们去测试（除了测试部门 ），即便有，效率也特别的低，因此开发者一般都是通过浏览器的手机模拟器来模拟不同的设备。 流式布局移动端的特点 手机端的兼容性问题比PC端小很多，因为手机端的浏览器版本比较新 手机端屏幕比较小，能够放的内容比较少。 问题：布局的时候怎么解决屏幕大小不一致的问题？ PC端，固定版心，让所有分辨率的电脑的版心都是一样的，比如京东 移动端：移动端无法设置版心，因为移动端的设备屏幕本身就小，设置版心不合适。因此移动端大多会采用流式布局（百分比布局） 流式布局，也叫百分比布局，是移动端开发中经常使用的布局方式之一。 流式布局的特征： 宽度自适应，高度写死，并不是百分百还原设计图 图标都是固定死大小的，包括字体等也是固定死的。并不是所有的东西都是自适应的。 一些大的图片，设置宽度为百分比自适应即可，随着屏幕大小进行变化 流式布局无法做到所有设备都非常逼真的还原设计图，有些设备显示效果不是特别的好看。但是流式布局是移动端非常常用的一种布局方式，比较简单，需要掌握（携程、京东) 最后一天会学习rem布局，配合less非常的方便，并且能够实现完全的自适应，包括字体以及图标等 经典的流式布局 1234//1. 左侧固定，右侧自适应//2. 右侧固定，左侧自适应//3. 两侧固定，中间自适应（圣杯布局，双飞翼布局）//4. 等分布局 BFC 块级格式化上下文Block Formatting Context: 页面上一个隔离的独立渲染区域 触发成为 BFC 盒子的特点: 触发了 BFC 的盒子, 就成为了页面上的一个隔离的独立容器, 容器里面的子元素不会在布局上影响到外面的元素 应用: 解决塌陷问题, 清除浮动 触发了BFC的普通盒子, 不会与浮动元素重叠 应用: 圣杯布局, 左侧固定右侧自适应 如何触发 BFC float: left; float: right; overflow的值不为visible。 display的值为table, table-cell position的值absolute, fixed …. 响应式 什么是响应式布局 响应式布局（respond layout）是Ethan Marcotte在2010年5月份提出的一个概念，简而言之，就是一个网站能够兼容多个终端（手机、平板、pc电脑、手表） ——而不是为每个终端做一个特定的版本。这个概念是为解决移动互联网浏览而诞生的。 为什么要有响应式布局？ 在移动互联日益成熟的时候，在PC端开发的网页已经无法满足移动设备的要求。 通常的做法是针对移动端单独做一套特定的版本。 如果终端越来越多，那么需要开发的版本就会越来越多（大屏设备的普及） 响应式布局 ：一个网站能够兼容多个终端（节约开发成本） 优点： 面对不同分辨率设备灵活性强 能够快捷解决多设备显示适应问题 缺点： 兼容各种设备工作量大，效率低下 代码累赘，会出现隐藏无用的元素，加载时间加长 其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果 一定程度上改变了网站原有的布局结构，会出现用户混淆的情况 响应式开发现状： 如果已经存在PC的网站了，那么一般不会使用响应式开发，而是针对移动端再开发一套系统（比如京东、淘宝） 在新建站点 上采用响应式开发的越来越多。 在国内，响应式开发还不是特别的流行。但响应式开发是大势所趋，会越来越流行。 响应式开发与移动web开发的比较 开发方式 移动web开发+pc开发 响应式开发 引用场景 一般已经有了PC端网站，只需要端独开发移动端网站即可 针对一些新建网站，并且要求适配移动端 开发 针对性强，开发效率高 兼容各种终端，效率低 适配 只能适配移动端或者PC端，pad上体验比较差 可以适配各种终端 效率 代码简洁，加载快 代码相对复杂，加载慢 1//思考：响应式开发的原理是什么？ 媒体查询 媒体查询（Media Query）是CSS提出来的一个新的属性，通过媒体查询可以查询到screen的宽度，从而指定某个宽度区间的网页布局。 设备分类 分类 宽度范围 大屏设备 >1200px 中屏设备 992px~1200px 小屏设备 768px~992px 超小屏设备 < 768px 媒体查询的使用需求： 1234567 响应式开发的原理：使用媒体查询实现不同终端的布局和样式的切换。 媒体查询语法： 12345678910111213141516171819202122232425262728293031323334/*查询屏幕*/@media screen and 条件 {}/*条件的写法*//*min-width:只要屏幕宽度超过这个值的设备样式就能生效*//*max-width:只要屏幕宽度小于这个值的设备样式就能生效*/@media screen and (min-width: 1200px) { .container { width: 1170px; background-color: red; }}@media screen and (min-width: 992px) and (max-width: 1200px) { .container { width: 970px; background-color: blue; }}@media screen and (min-width: 768px) and (max-width: 992px) { .container { width: 750px; background-color: yellow; }}@media screen and (max-width: 768px) { .container { width: 100%; background-color: green; }} 弊端：现在只有一个div，要做一套响应式布局，就需要如此多的代码，非常的麻烦，因此我们会更多的借助一些响应式的框架，比如bootstrap。 bootstrap框架 Bootstrap，来自 Twitter，是目前很受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JAVASCRIPT 的，它简洁灵活，使得 Web 开发更加快捷。 bootstrap中文网 特点： 组件简洁大方、代码规范精简、界面自定义性强。 Bootstrap是基于HTML5和CSS3开发的，它在jQuery的基础上进行了更为个性化和人性化的完善，形成一套自己独有的网站风格，并兼容大部分jQuery插件。 Bootstrap中包含了丰富的Web组件，根据这些组件，可以快速的搭建一个漂亮、功能完备的网站。 优点： 有自己的生态圈，不断的更新迭代 提供了一套简洁、直观、强悍的组件 标准化的HTML+CSS编码规范 让开发更简单，提高了开发效率。 扩展性强，虽然界面组件样式已经定义好了，我们还可以自定义，修改默认样式。 版本： 2.x.x 停止维护 优点：兼容性好 缺点：代码不够简洁、功能不够完善 3.x.x 目前使用最多 优点：稳定，偏向于开发响应式布局，移动设备优先的WEB项目 缺点：放弃了IE67，对IE8支持但是界面效果不友好 4.x.x 测试阶段 基本模板目录结构说明 123456789101112131415161718192021222324252627282930313233 bootstrap基本模板 你好，世界！ 全局样式normalize.css Normalize.css是一种CSS reset的替代方案。经过@necolas和@jon_neal花了几百个小时来努力研究不同浏览器的默认样式的差异，这个项目终于变成了现在这样。 官网 github网址 normalize的特点： 保护有用的浏览器默认样式而不是完全去掉它们 一般化的样式：为大部分HTML元素提供 修复浏览器自身的bug并保证各浏览器的一致性 优化CSS可用性：用一些小技巧 Normalize.css支持包括手机浏览器在内的超多浏览器，同时对HTML5元素、排版、列表、嵌入的内容、表单和表格都进行了一般化。尽管这个项目基于一般化的原则，但我们还是在合适的地方使用了更实用的默认值。 Normalize.css与CSS reset区别 container容器Bootstrap 需要为页面内容和栅格系统包裹一个 .container 容器。默认带了15px的padding值。 .container 类用于固定宽度并支持响应式布局的容器。 123 ... .container-fluid 类用于 100% 宽度，占据全部视口（viewport）的容器。 123 ... 这两种 容器类不能互相嵌套。 栅格系统栅格系统，也叫网格系统 .row用于抵消.container容器的15px的padding值 可以在.row中嵌套column 栅格系统常用类（总共12列） 类名 例子 解释 .col-xs-xx .col-xs-6 在超小屏幕（及以上）生效 .col-sm-xx .col-sm-6 在小屏幕（及以上）生效 .col-md-xx .col-md-6 在中屏幕（及以上）生效 .col-lg-xx .col-lg-3 在大屏幕及生效，占1/4 .col-lg-xx .col-lg-4 在大屏幕及生效，占1/3 .col-lg-xx .col-lg-5 在大屏幕及生效，占1/2 1234567 1234567 123456 响应式工具1234//1. 大屏显示//2. 中屏不显示//3. 小屏显示//4. 超小屏不显示 推荐使用hidden相关的属性","categories":[{"name":"web前端","slug":"web前端","permalink":"https://guoweiyanggithub.github.io/categories/web前端/"}],"tags":[{"name":"web前端","slug":"web前端","permalink":"https://guoweiyanggithub.github.io/tags/web前端/"},{"name":"手机端","slug":"手机端","permalink":"https://guoweiyanggithub.github.io/tags/手机端/"},{"name":"视口","slug":"视口","permalink":"https://guoweiyanggithub.github.io/tags/视口/"},{"name":"圣杯布局","slug":"圣杯布局","permalink":"https://guoweiyanggithub.github.io/tags/圣杯布局/"},{"name":"响应式","slug":"响应式","permalink":"https://guoweiyanggithub.github.io/tags/响应式/"}]},{"title":"git","slug":"git","date":"2019-03-08T02:28:26.000Z","updated":"2019-03-14T03:12:48.785Z","comments":true,"path":"2019/03/08/git/","link":"","permalink":"https://guoweiyanggithub.github.io/2019/03/08/git/","excerpt":"","text":"为什么要有版本控制系统? 在开发过程中，经常需要对一个文件进行修改甚至删除，但是我们又希望能够保存这个文件的历史记录，如果通过备份，那么管理起来会非常的复杂。 在多人开发时，如果需要多人合作开发一个页面，那么修改以及合并也会非常的棘手。容易出现冲突。 什么是版本控制系统？版本控制系统（Version Control System）:是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。版本控制系统不仅可以应用于软件源代码的文本文件，而且可以对任何类型的文件进行版本控制。 常见的版本控制系统有：svn、cvs、git 【使用webstorm演示版本控制系统】 版本控制系统分类参考文章：关于版本控制的介绍 本地版本控制系统 本地版本控制系统就是在一台机器上，记录版本的不同变化，保证内容不会丢失 缺点：如果多人开发，每个人都在不同的系统和电脑上开发，没办法协同工作。 集中式版本控制系統 svn/cvs都是集中式的版本控制系统 需要一个中央服务器来管理代码的的版本和备份 所有的用户电脑都是从中央服务器获取代码或者是将本地的代码提交到中央服务器 依赖与网络环境，如果连不上中央服务器，就无法提交和获取代码。 如果中央服务器宕机，所有人都无法工作。 分布式版本控制系统 git是分布式的版本控制系统。 需要一台服务器作为代码仓库 每个用户电脑都是一个服务器（代码仓库），并且和代码仓库是镜像的，用户修改和获取代码都是提交到自己的服务器当中。 不需要网络就可以进行工作。 当连接网络时，用户可以选择将自己的服务器与代码仓库进行同步。 gitgit介绍 Git是一款免费、开源的分布式 版本控制系统 ，用于敏捷高效地处理任何或小或大的项目。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 git安装下载地址 1. 不要安装在中文目录 2. 不要使用桌面管理软件 安装很简单，一直下一步即可。在任意的目录下右键，能够出现下图，表示安装成功了。 git用法方式主要有两种， git gui，即图形化界面的方式 git bash，命令行的方式 给window用户的忠告：git的命令必须使用linux风格的shell来运行Git命令，不能使用window风格的shell运行git命令 在任意文件夹中，都可以使用右键，通过git bash here打开命令行窗口，此时的路径就是当前目录。 窗口上右键，通过options–>Text–>select可以调整字体的大小。 bash入门bash是许多linux系统默认的shell(命令行工具)。 cmd和powershell是window系统默认的shell(命令行工具)。 二者的功能都一样，通过命令行来操作计算机的功能。 为什么要学习bash 必须使用linux风格的shell来运行git命令 工作过程中，项目都是部署在linux系统中，了解一些常用的bash命令也是有必要的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# cd 改变目录 （change directory）cd #进入文件夹cd .. #进入上一层目录cd ~ #进入用户根目录# tab 自动补全，当我们输命令或者目录很长时，可以使用tab键进行自动补全。# 按两次tab，会把所有符合要求的内容都列出来。# pwd 打印当前目录的路径 （print work directory）pwd# ls 展示当前目录列表（list）ls # 展示当前目录ls -a # 展示全部内容，包括隐藏文件ls -l # 以列表的形式展示内容ls -al # 以列表的形式展示所有的内容，包括隐藏文件。ls --help # 查看ls所有的参数。ls -l # 展示目录下的文件，如果没有写目录，默认展示当前目录。# clear reset清屏clear # 清除屏幕内容，滚动条，保留了历史reset # 重置，历史记录没了。# mkdir 创建一个文件夹 （make directory）mkdir css # 创建一个css的文件夹mkdir css img js # 创建了三个文件夹# rmdir 删除一个空的文件夹（没啥用）rmdir img # 删除文件夹# touch 创建文件touch index.html #创建了一个index.html文件touch css/index.css # 在css目录下创建idnex.css文件# rm 删除一个文件或者文件夹rm index.html # 删除index.html文件rm js # 删除空的js文件夹rm -r css # 递归删除一个文件夹# mv 移动文件（move）mv index.html js # 将html文件移动到js文件夹中mv index.html index2.html # 将index.html重命名为index2.html# cp 复制文件（cp）cp index.html index2.html # 复制index.html文件，命名为index2.htmlcp -r css css02 # 如果复制的是文件夹，需要使用-r参数, -r参数可以放在最后面，也会复制文件夹内的文件或文件夹# cat 查看文件全部内容cat index.html# less 查看文件部分内容，按q键退出查看less index.html 练习： 在桌面新建一个 test文件夹 在test文件夹中打开git命令窗口 创建 css js 三个文件夹 新建index.html文件，在css文件中新建index.css文件， 在中新建index.png文件，在js文件中新建index.js 把index.html重命名为index2.html 把index.css文件挪到js文件中 git初体验在第一次使用的时候，需要配置你的用户邮箱和用户名称，这两条配置是很重要的，每次提交git代码都会引用这两条信息，记录了谁提交了代码，会永久的记录在历史记录中。 123456789# git config user.name 你的目标用户名# git config user.email 你的目标邮箱名# 使用--global参数，配置全局的用户名和邮箱，只需要配置一次即可。git config --global user.name huccgit config --global user.email 111111@qq.com# 查看配置信息git config --list 初始化git仓库git init 查看当前git仓库的状态git status 将文件添加到git的暂存区git add 文件名 将文件由暂存区提交到仓库区git commit -m '提交说明' 查看提交日子git log 123456789101112131415161718# 要对某个项目使用git进行管理，需要使用git init命令初始化git仓库# 会在当前目录生成一个隐藏文件夹 .git 不要去修改这个文件夹下的任意东西。git init# 查看git的状态 ,如果此时新建一个文件，那么这个文件是没有被追踪的，说白了git还没有管理这个新建的文件git status # 告诉git开始对index.html文件进行追踪， git会在暂存区中存储这个文件git add index.html# 让文件由暂存区提交到仓库区。此时文件才真正的被git管理了。# # 如果提交日志乱码，右键-->options-->Text-->将编码改成utf-8git commit -m '第一次提交'# 查看提交日志git log git的工作原理 git命令详解git add(重点) 作用：让git追踪一个新的文件，并且将文件由 工作区 添加到 暂存区，暂存文件 命令：git add 文件名/目录名 例如： git add index.html git add --all 或者 git add -A 获取git add .（简写） 添加所有文件 git add a.txt b.txt 同时添加两个文件 git add *.js 添加当前目录下的所有js文件 git add css/添加css目录下所有的文件 git checkout 文件名 作用：暂存区的内容恢复到工作区。 git checkout 1.txt 将暂存区中1.txt文件恢复到工作区 git commit（重点） 作用：将文件由 暂存区 添加到 仓库区，生成版本号（历史记录，以后可以回退到某一个版本号） git commit -m \"提交说明\" git status 作用：查看文件的状态 命令：git status 命令：git stauts -s 简化日志输出格式 git log 作用：查看提交日志 git log 只能查看当前head以及以前的日志 git log --oneline 简洁的日志信息 git reflog 查看所有的提交变更日志 git reset 作用：版本回退，将代码恢复到已经提交的某一个版本中。 git reset --hard 版本号 将代码回退到某个指定的版本(版本号只要有前几位即可) git reset --hard head~1将版本回退到上一次提交 ~1:上一次提交 ~2:上上次提交 ~0:当前提交 git的三个区工作区、暂存区、本地仓库区 工作区：我们书写代码的地方，工作的目录就叫工作区。 暂存区：使用add命令，在.git目录中的一个索引文件，记录修改的文件 本地仓库区：将保存在暂存区域的内容永久转储到 Git 仓库中，生成版本号。生成版本号之后，就可以任何的回退到某一个具体的版本。 git忽视文件 在仓库中，有些文件是不想被git管理的，比如数据的配置密码、写代码的一些思路等。git可以通过配置从而达到忽视掉一些文件，这样这些文件就可以不用提交了。 在仓库的根目录创建一个.gitignore的文件，文件名是固定的。 将不需要被git管理的文件路径添加到.gitignore中 12345678910111213141516# 忽视idea.txt文件idea.txt# 忽视.gitignore文件.gitignore# 忽视css下的index.js文件css/index.js# 忽视css下的所有的js文件css/*.js# 忽视css下的所有文件css/*.*# 忽视css文件夹css git分支操作分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。 如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！ 为什么要有分支？ 如果你要开发一个新的功能，需要2周时间，第一周你只能写50%代码，如果此时立即提交，代码没写完，不完整的代码会影响到别人无法工作。如果等代码写完再提交，代码很容易丢失，风险很大。 有了分支，你就可以创建一个属于自己的分支，别人看不到，也不影响别人，你在自己的分支上工作，提交到自己的分支上，等到功能开发完毕，一次性的合并到原来的分支。这样既安全，又不影响他人工作。 在工作过程中，经常会碰到多任务并行开发 的情况，使用分支就能很好的避免任务之间的影响。 其他版本工具比如svn，cvs中也有分支这个概念，但是这些工具中的分支操作非常的慢，形同摆设。 分支操作的命令 在git中，分支实质上仅仅是一个指针，每次代码提交后，这个分支指针就会向后移动，保证一直指向最后一次提交的的版本。 创建分支 git branch 分支名称创建分支，分支中的代码，在创建时与当前分支的内容完全相同。 git在第一次提交时，就有了一个叫master的主分支。 查看分支 git branch可以查看所有的分支， 在当前分支的前面会有一个* 切换分支 git checkout 分支名称切换分支 在当前分支的任何操作，都不会影响到其他的分支，除非进行了分支合并。 切换分支之前，必须保证代码已经提交了 创建并切换分支 git checkout -b 分支名称 创建并切换分支 切换分支会做两件事情 把head指针指向当前的分支 将工作区的文件变成当前分支最新的内容。 删除分支 git branch -d 分支名称 可以删除分支 注意：不能在当前分支删除当前分支，需要切换到其他分支才能删除。 注意：master分支是可以删除的，但是不推荐那么做。 合并分支 git merge 分支名称 将其他分支的内容合并到当前分支。 在master分支中执行git merge dev 将dev分支中的代码合并到master分支 分支合并 git合并冲突 对于同一个文件，如果有多个分支需要合并时，容易出现冲突。 合并分支时，如果出现冲突，只能手动处理，再次提交，一般的作法，把自己的代码放到冲突代码的后面即可。 远程仓库所有的程序员都可以通过远程仓库来进行版本的共享，达到所有人的代码一致的效果。 远程仓库相关的命令git push 作用：将本地仓库中代码提交到远程仓库 git push 仓库地址 master 在代码提交到远程仓库，注意master分支必须写，不能省略 例子：git push git@github.com:hucongcong/test.git master 如果第一次使用，需要填写github的用户名和密码 git pull 作用：将远程的代码下载到本地 git pull 代码地址 将远程的代码中master分支下载到本地 通常在push前，需要先pull一次。 git clone 作用：克隆远程仓库的代码到本地 `git clone [远程仓库地址] git clone git://github.com/schacon/test.git会在本地新建一个test文件夹，在test中包含了一个.git目录，用于保存所有的版本记录，同时test文件中还有最新的代码，你可以直接进行后续的开发和使用。 git克隆默认会使用远程仓库的项目名字，也可以自己指定。需要是使用以下命令：git clone [远程仓库地址] [本地项目名] git remote每次push和pull操作都需要带上远程仓库的地址，非常的麻烦，我们可以给仓库地址设置一个别名 git remote add 仓库别名 仓库地址 使用仓库别名替代仓库地址。仓库别名相当于一个js变量，仓库地址就是对应的值。 git remote add hucc git@github.com:hucongcong/test.git 设置了一个hucc的仓库别名，以后push和pull都可以不用仓库地址，而用hucc git remote remove hucc 删除hucc这个仓库别名。 git remote 查看所有的仓库别名 如果使用了git clone命令从远程仓库获取下来的，那么这个本地仓库会自动添加一个 origin的远程地址，指向的就是克隆的远程地址。 githubgit与github没有直接的关系。 git是一个版本控制工具。 github是一个代码托管平台，是git的一个远程代码仓库。 将来工作时，公司会有自己的代码仓库。 github官网 开源中国-git 121. gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。2. github免费，代码所有人都能看到，但是只有你自己能修改。付费的可以隐藏。 在github上创建一个项目，获取到仓库的地址。然后就可以将本地的代码推送到远程的服务器上。 SSH免密码登陆git支持多种数据传输协议： https协议：https://github.com/hucongcong/jquery.git ssh协议：`git@github.com:hucongcong/jquery.git` 每次push或者pull代码，如果使用https协议，那么都需要输入用户名和密码进行身份的确认，非常麻烦。 github为了账户的安全，需要对每一次push请求都要验证用户的身份，只有合法的用户才可以push 使用ssh协议，配置ssh免密码，可以做到免密码往github推送代码 SSH免密码登录配置注意：这些命令需要在bash中敲 1 创建SSH Key：ssh-keygen -t rsa 2 在文件路径 C:\\用户\\当前用户名\\ 找到 .ssh 文件夹 3 文件夹中有两个文件： 私钥：id_rsa 公钥：id_rsa.pub 4 在 github -> settings -> SSH and GPG keys页面中，新创建SSH key 5 粘贴 公钥 id_rsa.pub 内容到对应文本框中 5 在github中新建仓库或者使用现在仓库，拿到`git@github.com:用户名/仓库名.git` 6 此后，再次SSH方式与github“通信”，不用输入密码确认身份了 github pages介绍GitHub Pages 本用于介绍托管在 GitHub 的项目， 不过，由于他的空间免费稳定，用来做搭建一个博客再好不过了。 缺点：只能放静态页面，也就说github pages只能解析html、css、js，无法解析后端语言。 [用户名.github.io] 将来访问路径 博客搭建步骤： 在本地工作目录使用git初始化 git init 创建自己的博客项目 将创建好的博客添加到暂存区 git add [文件路径] 本地提交： git commit -m \"第一个博客\" 在github上创建一个项目，项目名用户名.github.io 固定的 提交到github：git push github仓库地址 master 查看github中对应的仓库中，是不是提交到了 访问：用户名.github.io","categories":[{"name":"版本控制","slug":"版本控制","permalink":"https://guoweiyanggithub.github.io/categories/版本控制/"}],"tags":[{"name":"版本控制","slug":"版本控制","permalink":"https://guoweiyanggithub.github.io/tags/版本控制/"},{"name":"git","slug":"git","permalink":"https://guoweiyanggithub.github.io/tags/git/"}]},{"title":"canvas","slug":"canvas","date":"2019-03-08T02:25:37.000Z","updated":"2019-03-15T06:43:22.083Z","comments":true,"path":"2019/03/08/canvas/","link":"","permalink":"https://guoweiyanggithub.github.io/2019/03/08/canvas/","excerpt":"","text":"什么是Canvas canvas 是 HTML5 提供的一个用于展示绘图效果的标签 1canvas 提供了一个空白的图形区域，可以使用特定的JavaScript API来绘画图形（canvas 2D或WebGL） 关于Canvas的一些说明 canvas 是一个矩形区域的画布，可以用 JS 在上面绘画。 canvas 标签使用 JS 在网页上绘制图像，本身不具备绘图功能。 canvas 拥有多种绘制路径、矩形、圆形、文字以及添加图像的方法。 canvas的标准： 标准 目前来说，标准还在完善中。 canvas主要应用的领域（了解） 1、游戏：canvas 在基于Web的图像显示方面比 Flash 更加立体、更加精巧，canvas游戏在流畅度和跨平台方面更牛。 2、可视化数据（数据图表化），比如: 百度的ECharts、d3.js、three.js highcharts 3、banner广告：Flash曾经辉煌的时代，智能手机还未曾出现。现在以及未来的智能机时代，HTML5技术能够在banner广告上发挥巨大作用，用Canvas实现动态的广告效果再合适不过。 4、未来 模拟器：无论从视觉效果还是核心功能方面来说，模拟器产品可以完全由JavaScript来实现。 图形编辑器：Photoshop图形编辑器将能够100%基于Web实现。 课程目标 学会使用基本的 canvas API, 使用 canvas 可以完成简单的绘图 实现数据的可视化 Canvas标签介绍 作用：展示绘图的内容，但不能进行绘图 1 canvas的兼容性1234 IE9及其以上版本的浏览器，才支持canvas标签 提示：您的浏览器不支持canvas，请升级浏览器 设置宽高注意点 1 可以使用 html属性/DOM属性 width 和 height来设置 2 不要：使用CSS样式来设置宽高 1234使用 属性设置宽高，实际上相当于增加了 canvas画布的像素默认宽高： 300*150，表示：水平方向有300个像素，垂直方向有150个像素使用属性设置宽高，是增加或减少了canvas画布的像素；而使用css样式，不会增加像素点，只是将每个像素点扩大了！ 绘图 使用JavaScript中提供的绘图API来绘制 绘图的基本步骤 1 拿到canvas画布 2 通过canvas拿到绘图上下文（一系列的API集合） 3 使用API绘制需要的图形 12345678// 1 找到canvasvar cas = document.getElementById(\"canvasId\");// 2 拿到canvas绘图上下文var ctx = cas.getContext(\"2d\");// 3 使用上下文中的API绘制图形ctx.moveTo(100, 100); // 将画笔移动到 100,100 的位置ctx.lineTo(200, 100); // 从 100,100 到 200,100 画一条线段ctx.stroke(); // 描边 注意点： 12345678getContext(\"2d\"), 参数`2d`是指获取到绘制平面图形的上下文;如果想绘制立体图形，需要传入参数：\"webgl\"2d上下文类型：CanvasRenderingContext2D获得 webgl 上下文：（了解, 部分浏览器默认不支持）var cas = document.createElement(\"canvas\");console.log(cas.getContext(\"webgl\")); canvas的基本使用canvas中的坐标系 canvas坐标系，从最左上角0,0开始。x向右增大， y向下增大 联想：CSS中的盒模型 绘制直线的常用API 步骤：先绘制路径再描边（在画布中展示） moveTo -设置绘制起点 语法：ctx.moveTo(x, y); 解释：设置上下文绘制路径的起点。相当于移动画笔到某个位置 参数：x,y 都是相对于 canvas盒子的坐标。 注意：绘制线段前必须先设置起点，不然绘制无效。 lineTo -绘制直线 语法：ctx.lineTo(x, y); 解释：从x,y的位置绘制一条直线到起点或者上一个线头点。 参数：x,y 线头点坐标。 stroke -描边 语法：ctx.stroke(); 解释：根据路径绘制线。路径只是草稿，真正绘制线必须执行stroke fill -填充 语法：ctx.fill(); 解释：填充，是将闭合的路径的内容填充具体的颜色, 默认黑色。 如果所有的描点没有构成封闭结构，也会自动构成一个封闭图形 线宽 语法：ctx.lineWidth 解释：设置或返回当前的线条宽度，沿着起始坐标往上下两边扩展 描边和填充的样式说明 fillStyle : 设置或返回用于填充绘画的颜色 strokeStyle: 设置或返回用于描边的颜色 以上两个值都可以接受：颜色名、16进制数据、rgb值，甚至rgba.一般先进行设置样式然后进行绘制。 1234ctx.strokeStyle = \"red\";ctx.strokeStyle = \"#ccc\";ctx.strokeStyle = \"rgb(255,0,0)\";ctx.strokeStyle = \"rgba(255,0,0,6)\"; 非零环绕原则 注意：交叉路径的填充问题，“非零环绕原则”，顺逆时针穿插次数决定是否填充。 12345678910以下是非0环绕原则的原理：（了解即可，非常少会用到复杂的路径）“非零环绕规则”是这么来判断有自我交叉情况的路径的：对于路径中的任意给定区域，从该区域内部画一条足够长的线段，使此线段的终点完全落在路径范围之外。接下来，将计数器初始化为0，然后，每当这条线段与路径上的直线或曲线相交时，就改变计数器的值。如果是与路径的顺时针部分相交，则加1，如果是与路径的逆时针部分相交，则减1。若计数器的最终值不是0，那么此区域就在路径里面，在调用fill()方法时，浏览器就会对其进行填充。如果最终值是0，那么此区域就不在路径内部，浏览器也就不会对其进行填充了 路径开始和闭合 开始路径：ctx.beginPath(); 闭合路径：ctx.closePath(); 解释：如果复杂路径绘制，必须使用路径开始和结束。闭合路径会自动把最后的线头和开始的线头连在一起。 beginPath: 核心的作用开启新路径每次执行此方法，表示重新绘制一个路径, 后面的绘制跟beginPath之前的绘制的路径就无关了。 beginPath注意点: canvas 是基于状态的绘图 状态：包含当前与当前绘制相关的属性，如：颜色、线宽等 新的状态会 “继承” 原先的状态, 虽然旧路径被清除了, 但是状态会保留下来, 线宽, 颜色等还是设置过的状态 其他绘制状态（了解即可）绘制线的其他属性 lineCap 设置线条端点(线头、线冒)样式 butt ： 默认。向线条的每个末端添加平直的边缘。 round ： 向线条的每个末端添加圆形线帽。 square： 向线条的每个末端添加正方形线帽。 lineJoin 设置拐角类型 bevel: 创建斜角。 round: 创建圆角。 miter: 默认。创建尖角 miterLimit 设置或返回最大斜接长度 斜接长度指的是在两条线交汇处内角和外角之间的距离。 一般用默认值：10就可以了。除非需要特别长的尖角时，使用此属性。 绘制虚线 设置： setLineDash(数组) 读取： getLineDash() 一些说明 getLineDash() 与 setLineDash() 方法使用数组描述实线与虚线的长度. 绘制矩形快速创建矩形rect()方法 语法：ctx.rect(x, y, width, height); 解释：x, y是矩形左上角坐标， width和height都是以像素计 rect方法只是规划了矩形的路径，并没有填充和描边, 所以最后还是要调用 fill 或者 stroke 方法绘制 ​ 快速创建描边矩形和填充矩形 语法：ctx.strokeRect(x, y, width, height); 注意此方法直接进行stroke绘制, 不会产生路径 语法：ctx.fillRect(x, y, width, height); 此方法直接进行 fill 填充绘制, 不会产生路径 ​ 清除矩形(clearRect) 语法：ctx.clearRect(x, y, width, hegiht); 解释：清除某个矩形内的绘制的内容，相当于橡皮擦。 ​ 清除整个画布 1 ctx.clearRect(0, 0, cv.width, cv.height); 2 cv.width = cv.width; ​ 练习 练习：让矩形运动的简单动画 ​ 绘制圆弧arc 方法 概述：arc() 方法创建弧/曲线（用于创建圆或部分圆）。 语法：ctx.arc(x, y, r, sAngle, eAngle, counterclockwise); 解释： x,y：圆心坐标。 r：半径大小。 sAngle:绘制开始的角度。 eAngel:结束的角度，注意是弧度。π counterclockwise：是否是逆时针。true是逆时针，false：顺时针 弧度和角度 弧度和角度的转换公式： rad = deg /180 * Math.PI; 在Math提供的方法中 Math.sin、Math.cos等都使用的单位也是弧度 ​ 封装角度和弧度的转换函数123456function toRadian(angle) { return angle / 180 * Math.PI;}function toAngle(radian) { return radian / Math.PI * 180;} 零度角 圆心水平到最右边点是0度，顺时针方向弧度（角度为正）增大。 练习： 绘制圆弧，圆心在画布中间，从-60度到120度 ​ 绘制圆弧和起始点的问题 问题说明： 1如果在绘制圆弧的时候 如果已经移动了画笔，那么画笔的坐标点与绘制圆弧的起始点画一条连线！ 解决方式： beginPath ​ 绘制扇形 步骤：先moveTo到圆心，再绘制圆弧，最后closePath 如果是 fill 填充的扇形图，那么不需要 closePath 就会自动填充 计算圆弧上点的坐标123计算圆弧上点的坐标的公式:x = x0 + r * Math.cos(a);y = y0 + r * Math.sin(a); sin在 1 2象限是正 3 4象限是负 sin在角度为：0-180度之间为正，-90-0度和180-270度之间为负 cos在 1 4象限是正 2 3象限是负 cos在角度为：0-90度和-90-0度之间为正，90-270度之间为负 练习 练习：动画绘制整个圆 练习：绘制饼型图（三等分） 练习：绘制普通的饼型图 1234567891011121314151617var data = [{ \"value\": .2, \"color\": \"red\", \"title\": \"应届生\"},{ \"value\": .3, \"color\": \"blue\", \"title\": \"社会招生\"},{ \"value\": .4, \"color\": \"green\", \"title\": \"老学员推荐\"},{ \"value\": .1, \"color\": \"pink\", \"title\": \"公开课\"}]; 绘制文字常用绘制文字方法 ctx.fillText() 在画布上绘制“被填充的”文本 参数：文字, x坐标, y坐标 ctx.strokeText() 在画布上绘制文本（无填充） 12ctx.fillText(str,100,94); ctx.strokeText(str1,100,294); 常用绘制文字属性(了解) font 设置或返回文本内容的当前字体属性（与 CSS font 属性相同） 1ctx.font = '18px \"微软雅黑\"'; textAlign 设置或返回文本内容的当前对齐方式 记忆: left right center start : 默认。文本在指定的位置开始。 end : 文本在指定的位置结束。 center: 文本的中心被放置在指定的位置。 left : 文本左对齐。 right : 文本右对齐。 1ctx.textAlign = 'left'; textBaseline 设置或返回在绘制文本时使用的当前文本基线 记忆: top middle bottom 默认: alphabetic (基线对齐) alphabetic ： 默认。文本基线是普通的字母基线。 top ： 文本基线是 em 方框的顶端。 hanging ： 文本基线是悬挂基线。 middle ： 文本基线是 em 方框的正中。 ideographic： 文本基线是em基线。 bottom ： 文本基线是 em 方框的底端。 1例如： ctx.textBaseline = 'top'; textBaseline的介绍 绘制图片（drawImage)绘制图片用法1 -基本使用 context.drawImage(img, x, y); 参数： img : 图片dom对象 x,y 绘制图片到画布中坐标 ​ 绘制图片用法2 -设置高度和宽度 context.drawImage(img, x, y, width, height); width：绘制到canvas中展示的宽度 123如果指定宽高，最好成比例，不然图片会被拉伸等比公式： height = imgHeight / imgWidth * width; 设置高 = 原高度 / 原宽度 * 设置宽; 绘制图片用法3 -图片裁剪 context.drawImage(img, imgX, imgY, sWidth, sHeight, x, y, width, height); 参数： imgX, imgY：被剪裁图片的起始位置, 图片中的x,y坐标 sWidth：裁剪宽度 sHeight: 裁剪高度 x, y : 要绘制到画布上的位置 width ：要绘制到画布上的宽度 height：要绘制到画布上的高度 ​ 用JavaScript创建img对象 第一种方式： var img = document.createElement(“img”); 第二种方式： 123456var img = new Image(); //这个就是 img标签的dom对象img.src = \"/arc.gif\";img.alt = \"文本信息\";img.onload = function() { //图片加载完成后，执行此方法} 绘制图片的步骤 1 创建图片对象 2 等待图片加载完成 3 开始绘制图片 加载图片的问题 需要使用 onload事件 等待图片加载完成之后，再绘制！ ​ 练习 练习1: 绘制整个图片 练习2: 绘制图片的一部分 练习3: 绘制序列帧动画 ​ 变换 （重点）所有的变换都是针对坐标系的，旋转的是坐标系，移动的是坐标系，放缩 的是坐标系，坐标系了改不了，绘制的所有图像都会随之改变 平移 ctx.translate(x,y) 参数说明： x： 整个坐标轴位移到 原来水平坐标（x）上的值 y： 整个坐标轴位移到 原来垂直坐标（y）上的值 发生位移后，相当于把画布的0,0坐标 更换到新的x,y的位置，所有绘制的新元素都被影响。 位移画布一般配合缩放和旋转等。 ​ 缩放 scale() 方法缩放当前绘图，更大或更小 语法：context.scale(scalewidth,scaleheight) scalewidth : 缩放当前绘图的宽度 (1=100%, 0.5=50%, 2=200%) scaleheight : 缩放当前绘图的高度 (1=100%, 0.5=50%, 2=200%) 注意：缩放的是整个画布，缩放后，继续绘制的图形会被放大或缩小。 ​ 旋转 context.rotate(radian); 旋转当前的坐标轴 注意参数是弧度（PI） ​ 练习 在画布左右两侧分别绘制两个圆 绘制两个正方形（宽度：100 和 50） 绘制旋转的矩形 ​ 环境前面提到 Canvas 是含有状态的, 也就是说需要修改颜色, 直线样式等, 这些状态都会保留下来 但是有时候, 如果需要回到默认状态中绘制另外的形状, 那么只有再将修改过的样式再更改回来. 如果在该状态中修改的属性较多, 那么每次在回到之前状态时, 就有很多的代码, 就很麻烦 123456789Canvas 中引入了状态的保持机制. 使用 CanvasRenderingContext2D.save() 方法可以保存当前状态. 如果需要恢复到已经保存的状态, 只需要调用 CanvasRenderingContext2D.restore() 方法即可.状态保持的机制是基于状态栈实现的. 也就是说 save 一次就存储一个状态. restore 一次就将刚刚存入的恢复. 如果 save 两次, 就需要 restore 两次, 才可以恢复到最先的状态.一般在封装绘图的时候都会采用开始绘制之前, save 一次, 然后 开启一个新路径 beginPath, 然后绘制结束后 restore, 这样保持当前状态不会对其他绘图代码构成影响. 绘制环境保存和还原 ctx.save() 保存当前环境的状态 ctx.restore() 返回之前保存过的路径状态和属性 ​ 画布保存base64编码内容(了解) 把 canvas绘制的内容 输出成base64内容。 语法：canvas.toDataURL(type, encoderOptions); 例如：canvas.toDataURL(“image/png”,1); 参数： type，设置输出的类型，比如 image/png image/jpeg等 encoderOptions： 0-1之间的数字，用于标识输出图片的质量，1表示无损压缩(可选) 12345678var canvas = document.getElementById(\"canvas\");var dataURL = canvas.toDataURL();console.log(dataURL);// \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNby// blAAAADElEQVQImWNgoBMAAABpAAFEI8ARAAAAAElFTkSuQmCC\"var img = document.querySelector(\"#img-demo\");//拿到图片的dom对象img.src = canvas.toDataURL(\"image/png\"); //将画布的内容给图片标签显示","categories":[{"name":"web前端","slug":"web前端","permalink":"https://guoweiyanggithub.github.io/categories/web前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://guoweiyanggithub.github.io/tags/javascript/"},{"name":"web前端","slug":"web前端","permalink":"https://guoweiyanggithub.github.io/tags/web前端/"},{"name":"canvas","slug":"canvas","permalink":"https://guoweiyanggithub.github.io/tags/canvas/"}]},{"title":"ajax","slug":"ajax","date":"2019-03-08T02:18:24.000Z","updated":"2019-03-14T03:12:11.689Z","comments":true,"path":"2019/03/08/ajax/","link":"","permalink":"https://guoweiyanggithub.github.io/2019/03/08/ajax/","excerpt":"","text":"前后端分离 我们使用php动态渲染页面时，有很多比较麻烦的地方。 在前端写好页面以后，需要后台进行修改，意味这后端程序员也需要懂前端的知识，其实渲染的工作应该交给前端来做。 前端没有写好页面的话，后端无法开始工作，需要等待前端的页面完成之后才能开始工作，拖延项目的进度。 在客户端设备多元化的情况下，后台渲染的页面无法满足所有用户的需求 前后端代码混合在一个文件中，项目修改和维护成本高 ​ 常见数据传输格式XML 可拓展的标记语言 XML是一种标记语言，很类似HTML，其宗旨是用来传输数据，具有自我描述性（固定的格式的数据）。 语法规则 必须有一个根元素 不可有空格、不可以数字或.开头、大小写敏感 不可交叉嵌套 属性双引号（浏览器自动修正成双引号了） 特殊符号要使用实体（转义字符） 注释和HTML一样 虽然可以描述和传输复杂数据，但是其解析过于复杂并且体积较大，所以实现开发已经很少使用了。 其解析方式类似于DOM 1234567891011121314151617 鹏鹏 弯 1 飙车 &lt;&lt;老司机的自我修养&gt;&gt; 春哥 男 38 修发动机 C语言从入门到放弃 JSON 即 JavaScript Object Notation，另一种轻量级的文本数据交换格式，独立于语言。 语法规则1、数据在名称/值对中2、数据由逗号分隔(最后一个健/值对不能带逗号)3、花括号保存对象，方括号保存数组4、使用双引号 JSON解析 JSON数据在不同语言进行传输时，类型为字符串，不同的语言各自也都对应有解析方法，需要解析完成后才能读取 Javascript 解析方法 JSON对象 JSON.parse()、JSON.stringify()；​ PHP解析方法 json_encode() 、json_decode()总结： JSON体积小、解析方便且高效，在实际开发成为首选。 AJAX技术 即 Asynchronous Javascript And XML，AJAX 不是一门的新的语言，而是对现有持术的综合利用。 本质:是在HTTP协议的基础上通过js的XMLHttpRequest对象与服务器进行通信。 作用：可以在页面不刷新的情况下，请求服务器，局部更新页面的数据； 异步与同步 指某段程序执行时不会阻塞其它程序执行，其表现形式为程序的执行顺序不依赖程序本身的书写顺序，相反则为同步。 同步：同一时刻只能做一件事，上一步完成才能开始下一步 异步：同时做多件事，效率更高,做一件事情时，不影响另一件事情的进行。 XMLHttpRequest可以以异步方式的处理程序。 XMLHttpRequest 浏览器内建对象，用于在后台与服务器通信(交换数据) ， 由此我们便可实现对网页的部分更新，而不是刷新整个页面。 发送get请求XMLHttpRequest以异步的方式发送HTTP请求，因此在发送请求时，一样需要遵循HTTP协议。 12345678910111213//使用XMLHttpRequest发送get请求的步骤//1. 创建一个XMLHttpRequest对象var xhr = new XMLHttpRequest();//2. 设置请求行//第一个参数:请求方式 get/post//第二个参数:请求的地址 需要在url后面拼上参数列表xhr.open(\"get\", \"08.php?name=hucc\");//3. 设置请求头xhr.setReqeustHeader('content-type','text/html');//浏览器会给我们默认添加基本的请求头,get请求时无需设置//4. 设置请求体//get请求的请求体为空,因为参数列表拼接到url后面了xhr.send(null); get请求,设置请求行时,需要把参数列表拼接到url后面 get请求不用设置请求头 get请求的请求体为null 发送post请求1234567var xhr = new XMLHttpRequest;//1. 设置请求行 post请求的参数列表在请求体中xhr.open(\"post\", \"09.php\");//2. 设置请求头, post请求必须设置content-type,不然后端无法获取到数据xhr.setRequestHeader(\"content-type\", \"application/x-www-form-urlencoded\");//3. 设置请求体xhr.send(\"name=hucc&age=18\"); post请求,设置请求行时,参数列表不能拼接到url后面 post必须设置请求头中的content-type为application/x-www-form-urlencoded post请求需要将参数列表设置到请求体中. 获取响应HTTP响应分为3个部分，状态行、响应头、响应体。 123456789101112//给xhr注册一个onreadystatechange事件，当xhr的状态发生状态发生改变时，会触发这个事件。xhr.onreadystatechange = function () { if(xhr.readyState == 4){ //1. 获取状态行 console.log(\"状态行:\"+xhr.status); //2. 获取响应头 console.log(\"所有的相应头:\"+xhr.getAllResponseHeaders()); console.log(\"指定相应头:\"+xhr.getResponseHeader(\"content-type\")); //3. 获取响应体 console.log(xhr.responseText); }} readyState readyState:记录了XMLHttpRequest对象的当前状态 12345//0：请求未初始化（还没有调用 open()）。//1：请求已经建立，但是还没有发送（还没有调用 send()）。//2：请求已发送，正在处理中//3：请求在处理中；通常响应中已有部分数据可用了，但是服务器还没有完成响应的生成。//4：响应已完成；您可以获取并使用服务器的响应了。(我们只需要关注状态4即可) 案例【判断用户名是否存在】 【成绩查询案例】 【聊天机器人案例】 兼容性处理12345678var xhr = null;if(XMLHttpRequest){ //现代浏览器 xhr = new XMLHttpRequest();}else{ //IE5.5支持 xmlHttp=new ActiveXObject(\"Microsoft.XMLHTTP\");} 封装ajax工具函数 每次发送ajax请求，其实步骤都是一样的，重复了大量代码，我们完全可以封装成一个工具函数。 123456//1. 创建xhr对象//2. 设置请求行//3. 设置请求头//3. 设置请求体//4. 监听响应状态//5. 获取响应内容 参数提取 参数名 参数类型 描述 传值 默认值 type string 请求方式 get/post 只要不传post，就是get url string 请求地址 接口地址 如果不传地址，不发送请求 data object 请求数据 {key:valu} 需要把这个对象拼接成参数的格式 uname=hucc&upass=12345 callback function 渲染数据的函数 函数 空 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var $={ ajax:function(obj){ //获取用户的参数 var type=obj.type||'get'; //默认请求方式是get var url=obj.url||location.href; //默认请求当前页面 var callback=obj.callback; //1-js中使用对最方便接受的参数是对象，但是传递给服务器的格式 name=zs&age=18 var data=this.setParam(obj.data); //name=zs&age=18 // console.log(data); //封装ajax公共代码部分 //1-创建XMLHttpRequest对象 var xhr=new XMLHttpRequest(); //模拟http协议 //如果是get请求在url后面拼接参数 if(type=='get'){ url=url+'?'+data; data=null; } //1-请求行 xhr.open(type,url); //2-请求头 post 必须设置请求头 if(type=='post'){ xhr.setRequestHeader('content-type','application/x-www-form-urlencoded'); } //3-请求主体 xhr.send(data); //监听服务器的响应 xhr.onreadystatechange=function(){ if(xhr.readyState==4 &&xhr.status==200){ var r=xhr.responseText;//获取响应主体 //r中就是服务器返回核心数据 需要渲染 callback&&callback(r); } } }, //将对象转成 name=zs&age=18 setParam:function(obj){ if(typeof obj =='object'){ var str=''; for(var k in obj){ str+=k+'='+obj[k]+'&'; } str=str.substr(0,str.length-1); //参数一：开始索引 参数二：截取长度 } return str;//返回转换后的字符串 }}; jQuery中的ajax方法 jQuery为我们提供了更强大的Ajax封装 $.ajax参数列表 参数名称 描述 取值 示例 url 接口地址 url:”02.php” type 请求方式 get/post type:”get” timeout 超时时间 单位毫秒 timeout:5000 dataType 服务器返回的格式 json/xml/text(默认) dataType:”json” data 发送的请求数据 对象 data:{name:”zs”, age:18} beforeSend 调用前的回调函数 function(){} beforeSend:function(){ alert(1) } success 成功的回调函数 function (data) {} success:function (data) {} error 失败的回调函数 function (error) {} error:function(data) {} complete 完成后的回调函数 function () {} complete:function () {} 使用示例： 123456789101112131415161718192021$.ajax({ type:\"get\",//请求类型 url:\"02.php\",//请求地址 data:{name:\"zs\", age:18},//请求数据 dataType:\"json\",//希望接受的数据类型 timeout:5000,//设置超时时间 beforeSend:function () { //alert(\"发送前调用\"); }, success:function (data) { //alert(\"成功时调用\"); console.log(data); }, error:function (error) { //alert(\"失败时调用\"); console.log(error); }, complete:function () { //alert(\"请求完成时调用\"); }}); 【案例：登录案例.html】 其他api(了解)12345//$.post(url, callback, [dataType]);只发送post请求//$.get(url, callback, [dataType]);//$.getJSON(url, callback);//$.getScript(url,callback);//载入服务器端的js文件//$(\"div\").load(url);//载入一个服务器端的html页面。 接口化开发请求地址即所谓的接口，通常我们所说的接口化开发，其实是指一个接口对应一个功能， 并且严格约束了请求参数 和响应结果 的格式，这样前后端在开发过程中，可以减少不必要的讨论， 从而并行开发，可以极大的提升开发效率，另外一个好处，当网站进行改版后，服务端接口进行调整时，并不影响到前端的功能。 获取短信验证码接口需求文档(产品) 12345//总需求：点击发送按钮，向服务端发送请求//需求1：格式校验 // 手机号码格式必须正确（11位数字）, 提示\"请输入正确的手机号码\"//需求2：点击发送时，按钮显示为\"发送中\",并且不能重复提交请求//需求3：接受服务器返回验证码并显示 注册接口表单序列化 jquery提供了一个serialize()方法序列化表单，说白就是将表单中带有name属性的所有参数拼成一个格式为name=value&name1=value1这样的字符串。方便我们获取表单的数据。 123//serialize将表单参数序列化成一个字符串。必须指定name属性//name=hucc&pass=123456&repass=123456&mobile=18511249258&code=1234$('form').serialize(); jquery的ajax方法，data参数能够直接识别表单序列化的数据data:$('form').serialize() 12345678$.post({ url:\"register.php\", data:$('form').serialize(), dataType:'json', success:function (info) { console.log(info); }}); 需求文档 123456789101112//注册功能//总需求：点击注册按钮，向服务端发送请求//需求1:表单校验 //1.1 用户名不能为空，否则提示\"请输入用户名\" //1.2 密码不能为空，否则提示\"请输入密码\" //1.3 确认密码必须与密码一直，否则提示\"确认密码与密码不一致\" //1.4 手机号码不能为空，否则提示\"请输入手机号码\"; //1.5 手机号码格式必须正确，否则提示\"手机号格式错误\" //1.6 短信验证码必须是4位的数字，否则提示\"验证码格式错误\"//需求2：点击注册按钮时，按钮显示为\"注册中...\",并且不能重复提交请求//需求3：根据不同响应结果，处理响应 //3.1显示注册结果 模板引擎 是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。 为什么要使用模板引擎我们通过ajax获取到数据后，需要把数据渲染到页面，在学习模板引擎前，我们的做法是大量的拼接字符串，对于结构简单的页面，这么做还行，但是如果页面结构很复杂，使用拼串的话代码可阅读性非常的差，而且非常容易出错，后期代码维护也是相当的麻烦。 【演示：使用拼串进行渲染的缺点.html】 作用：代替前面渲染数据是拼接字符串操作 常见的模板引擎BaiduTemplate：http://tangram.baidu.com/BaiduTemplate/velocity.js：https://github.com/shepherdwind/velocity.js/ArtTemplate：https://github.com/aui/artTemplate artTemplate是使用最广泛，效率最高的模板引擎，需要大家掌握。 artTemplate的使用github地址 中文api地址 artTemplate入门1.引入模板引擎的js文件 1 2.准备模板 123456789 姓名：{{ username }} 年龄：{{ age }} 技能：{{ skill }} 描述：{{desc }} 3.准备数据 1234567//3. 准备数据,数据是后台获取的，可以随时变化var json = { userName:\"隔壁老王\", age:18, skill:\"查水表\", desc:\"年轻气壮\"} 4.将模板与数据进行绑定 12345//第一个参数：模板的id//第二个参数：数据//返回值：根据模板生成的字符串。var html = template(\"myTmp\", json);console.log(html); 5.将数据显示到页面 12var div = document.querySelector(\"div\");div.innerHTML = html; 注意：传递给模板引擎的数据必须是对象 artTemplate语法if语法 12345{{if gender='男'}} {{else}} {{/if}} each语法 123456789101112{{each data v i}} {{v.content}} {{/each}} 12//如果返回的数据是个数组，必须使用对象进行包裹，因为在{{}}中只写书写对象的属性。var html = template(\"navTmp\", {data:info}); 瀑布流案例封装jQuery瀑布流插件123456789//特点分析：//1. 页面中每个图片模块使用绝对定位，所以每个图片的位置，都是动态计算出来的；//2. 每列直接会有间隙， 列数=容器的宽度/（一列的宽度+间隙）//思路分析：//1. 获取所有的图片模块，算出列数//2. 初始化一个数组，用户存储每一列的高度 [0,0,0,0,0]//3. 查找数组的最小列，每次都把图片定位到最小列的位置//4. 更新数组最小列的高度（加上定位过来的图片的高度） 代码参考： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//向jQuery的原型中添加方法 $.fn.waterFall=function(option){ var data=option.gap||20; //1-获取页面中所有item 逐一进行定位 var items=$(this).children(); // 获取第一个item的宽度 225 var width=items.width(); //列数 var count=Math.floor($(this).width()/(width+data.gap)); //数组记录列高 var column=[]; //遍历给所有的 item进行定位 // index 索引值，ele当前遍历元素 items.each(function(index,ele){ //第一行 // top：0 left:index*(width+gap); if(index","categories":[{"name":"web前端","slug":"web前端","permalink":"https://guoweiyanggithub.github.io/categories/web前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://guoweiyanggithub.github.io/tags/javascript/"},{"name":"ajax","slug":"ajax","permalink":"https://guoweiyanggithub.github.io/tags/ajax/"}]},{"title":"phpstudy搭建与使用","slug":"phpstudy搭建与使用","date":"2019-03-08T02:11:00.000Z","updated":"2019-03-14T03:09:04.446Z","comments":true,"path":"2019/03/08/phpstudy搭建与使用/","link":"","permalink":"https://guoweiyanggithub.github.io/2019/03/08/phpstudy搭建与使用/","excerpt":"","text":"服务器服务器软件 使计算机具备提供某种服务能力的应用软件，称为服务器软件，通过安装相应的服务软件，然后进行配置后就可以使计算具备了提供某种服务的能力。 按服务类型可分为：文件服务器、数据库服务器、邮件服务器、Web服务器等； 按操作系统可分为：Linux服务器、Windows服务器等； 按应用软件可分为 Apache服务器、Nginx 服务器、IIS服务器、Tomcat服务器、weblogic服务器、WebSphere服务器、boss服务器、 Node服务器等； HTTP服务器即(web服务器)网站服务器，主要提供文档(文本、图片、视频、音频)浏览服务，一般安装Apache、Nginx服务器软件。 HTTP服务器可以结合某一编程语言处理业务逻辑，由此进行的开发，通常称之为服务端开发。 常见的运行在服务端的编程语言包括 php、java、.net、Python、Ruby、Perl等。 服务器总结 服务器说白了就是计算机，通过安装了某些软件，就可以提供某些特定的服务器 专业的服务器与计算机的区别 稳定性：服务器要求7*24不间断运行。 性能：服务器能够同时响应更多客户端的请求。 价格：服务器价格通常比普通计算机贵很多。 客户端 具有向服务器索取服务能力的终端，叫做客户端。 客户端：电脑、平板、手机安装了客户端软件，就可以称为客户端 客户端：安装客户端软件，索取服务的计算机 服务器：安装服务器软件，提供服务的计算机 客户端软件对于前端工程师而言，主要接触到的客户端软件就是浏览器，当然也可能会涉及大一些app开发。 以浏览器为宿主环境，结合 HTML、CSS、Javascript等技术，而进行的一系列开发，通常称之为前端开发。 软件架构 软件架构可以分为BS架构与CS架构 C/S架构Client/Server架构，即客户端/服务器架构。需要安装对应的客户端软件，才能获取服务器的服务。 常见的CS架构： QQ、LOL、微信等 特点： 需要安装才是使用 性能高效，使用更加稳定和流畅 需要更新 需要兼容操作系统。 B/S架构Broswer/Server架构，即浏览器/服务器架构。随着Internet的兴起，无需安装专门客户端软件，通过浏览器去请求服务器； 不需要安装，只需要浏览器即可。 相比CS架构，性能相对较差，没有那么流畅和稳定。 不需要更新 不用兼容操作系统。但是需要兼容浏览器。 动态网站与静态网站 静态网站：使用浏览器端语言进行编程，网站由静态代码（HTML.CSS,JS）组成。用户请求服务上已经存在的页面，不需要进行业务逻辑的处理。 动态网站 ：网页通过服务器的程序动态生成。用户可以和服务器进行交互（可以根据用户输入的不同信息，返回不同的运行结果），可以处理复杂的业务逻辑。 总结 动态网站的 `动`指的是网站`数据的动` 而不是 `视觉上的动`; 网络基础ip地址所谓IP地址就是给每个连接在互联网上的主机分配的一个32位地址。(就像每个人的身份证号码一样) 通过ip就可以找到具体的某一台计算机。 例 192.168.1.110 弊端：没有规律，不方便记忆和推广 查看本机IP地址 ping、ipconfig、ifconfig（linux） 1ping 192.168.1.110 //查看和某个同学的电脑是否连通 两种特殊的IP地址： 127.0.0.1作为本地测试的IP地址。本机测试时，客户端与服务器都安装在本地计算机上，数据无需任何网络传输。 192.168开头为局域网的地址。 域名由于IP地址基于数字，不方便记忆，于是便用域名来代替IP地址，域名是一个IP地址的“好记的名字” 查看域名对应的IP地址 ping 1ping jd.com //可以获取到京东的ip 特殊的域名 `localhost`，意思为本地主机。这是一个保留域名，主要用于本地测试，对应IP地址为`127.0.0.1`。 DNS服务器DNS（Domain Name System）因特网上作为域名和IP地址相互映射的一个分布式数据库， 能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。 简单的说就是用于记录IP地址和域名之间的对应关系。 查找优先级 本机hosts文件、DNS服务器 ipconfig /flushdns 刷新DNS 端口端口号是计算机与外界通讯交流的出入口，每个端口对应不同的服务。 现实生活中，银行不同的窗口办理不同的业务。 查看端口占用情况 netstat -an 常见端口号 80、8080、3306、21 ftp 本地hosts Hosts是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。 12//hosts文件的地址：C:\\Windows\\System32\\drivers\\etc//在浏览器中输入taobao.com的执行过程。 12345//hosts文件内容127.0.0.1 localhost127.0.0.1 localhost127.0.0.1 study.com127.0.0.1 www.study.com 搭建HTTP服务器phpStudy介绍 phpStudy是一个PHP调试环境的程序集成包。该程序包集成最新的Apache+PHP+MySQL,安装非常的简单 phpStudy的安装安装phpStudy，解压双击安装(非中文路径)，其它默认安装。 推荐就安装在默认的目录下，一定不能有中文，否则肯定启动不起来。 phpStudy的错误解决如果phpStudy启动发生错误，参数下列几点。 一是防火墙拦截， 二是80端口已经被别的程序占用，如IIS，迅雷等； 三是没有安装VC9运行库,php和apache都是VC9编译。 解决以上三个问题，99%能一次性安装成功 为了减少出错安装路径不得有汉字，如有防火墙开启，会提示是否信任httpd、mysqld运行，请选择全部允许。 关闭IIS服务器如果发现服务器启动不成功，很大原因是端口被占用了，因为windows默认会有一个iis服务器，只需要把iis服务器给禁用了即可。 1//控制面板-->程序-->程序与功能-->启用或关闭windows功能 提示缺少vc9 库文件在提供的资料库中找到phpStudy运行库， 根据自己电脑操作系统的位数安装对应的vc9运行库即可。 关闭防火墙如果希望系统自己的服务器能够被别人访问。需要关闭防火墙。 1//控制面板--->系统和安全--->Windows 防火墙--->启动或者关闭windows防火墙 phpStudy的配置修改网站目录与默认首页 默认首页一般不用修改，业界规范就是index.html作为默认的首页。 修改网站目录时，网站目录一定不能中文，不然apache启动会失败。 虚拟主机配置在一台web服务器上，我们可以通过配置虚拟主机，然后分别设定根目录，实现对多个网站的管理。 具体步骤如下： 1.找到http.conf文件 找到470行，去掉#号注释 12# Virtual hostsInclude conf/extra/httpd-vhosts.conf 2.找到httpd-vhosts.conf文件 在目录：D:\\phpStudy\\Apache\\conf\\extra下找到httpd-vhosts.conf文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 默认的虚拟主机 DocumentRoot \"C:\\www\\study\" Options +Indexes +FollowSymLinks +ExecCGI AllowOverride All Order allow,deny Allow from all Require all granted # Add any other Virtual Hosts below ServerAdmin webmaster@dummy-host.example.com #根目录 DocumentRoot \"C:\\www\\show\" #域名 ServerName show.com #完整域名 ServerAlias www.show.com ErrorLog \"logs/dummy-host.example.com-error.log\" CustomLog \"logs/dummy-host.example.com-access.log\" common ServerAdmin webmaster@dummy-host.example.com #根目录 DocumentRoot \"C:\\www\\api\" #域名 ServerName api.com #完整域名 ServerAlias www.api.com ErrorLog \"logs/dummy-host.example.com-error.log\" CustomLog \"logs/dummy-host.example.com-access.log\" common ServerAdmin webmaster@dummy-host.example.com #根目录 DocumentRoot \"C:\\www\\study\" #域名 ServerName study.com #完整域名 ServerAlias www.study.com ErrorLog \"logs/dummy-host.example.com-error.log\" CustomLog \"logs/dummy-host.example.com-access.log\" common PHP基础PHP简介 开源（open source）软件，跨平台，常用操作系统稳定执行。Windows / Linux。做WEB开发的经典组合 WAMP,LAMP基本都是开源软件。 入门简单,用户只需要关注应用，开发成本低。 支持的大多数主流数据库。MySQL，oracle,Redis等 文件以.php后缀结尾，所有程序包含在避免使用中文目录和中文文件名 php页面无法直接打开需要运行在服务器环境当中 注意：学习php的目的是为了更好的学习前端技能，因为需要了解一些后台的知识，千万不要本末倒置，我们的课程重心在前端。 php初体验 webstorm对于php的支持并不友好，没有高亮显示，但是也支持代码提示，功能比较微弱，如果需要专业的提示和高亮，建议使用vsCode。 vsCode下载地址 1234 输入中文乱码问题：如果使用echo输出中文，会乱码。 在php的语法中，末尾必须加分号，不然就报错了（最后一行可以不加分号） 12345678 1//思考：浏览器访问php文件时，过程是怎么样的？ 变量 php是一门弱类型语法，变量的类型可以随意改变。变量其实就是存储数据的容器 变量的命名规则 12345//1. 不需要关键字进行声明，变量在第一次赋值的时候被创建。//2. 必须以$符号开始//3. $后面的命名规则与js的变量命名规则一致。$name = \"春哥\";echo $name; 变量操作删除变量 1unset($var); 销毁指定的变量 判断变量是否设置值 1bool isset($var) 检测变量是否设置，并且不是 NULL。 变量未设置或者设置为null,返回false（认为变量没有设置）。其余情况全部为true。一般用来判断变量是否设置，因为变量未设置，无法直接使用。(变量先赋值，在使用！） 判断变量是否为空 1bool empty($var) 判断变量是否为空。PHP中认为变量的值为：\"\"、0、\"0\"、NULL、FALSE、[]时，变量虽然赋值了，但是无实际的意义。为空。 数据类型简单数据类型字符串 12$str = \"春哥\";echo $str; 整数 12$num = 100;echo $num; 浮点型 12$float = 11.11;echo $float; 布尔类型 123456$flag = true;//当布尔类型值为true时，输出1echo $flag;$flag = false;//当布尔类型为false时，输出空字符串echo $flag; 字符串连接符 1234//1. 在php中，+号只有算数的功能，并不能拼串//2. 在php中，拼串使用.$name = \"春哥\";echo \"大家好，我是\" . $name . \"，今年18岁\"; php中的单引号与双引号 12345678910111213141516//1. 字符串的定义可以使用单引号，也可以使用双引号$name = \"春哥\";$desc = '很帅';//2. 双引号可以解析变量//3. 单引号的性能会高于双引号（了解）$name = \"春哥\";//春哥echo $name;$desc = '很帅';echo $desc;//很帅$str = '$name 很帅';//$name 很帅echo $str;$str = \"$name 很帅\";//春哥 很帅echo $str; 数组 在php中，数组分为两种，索引数组和关联数组 计算数组长度的方法： count(数组名); 索引数组（类似与JS中的数组） 123$arr = array(\"张飞\",\"赵云\",\"马超\");echo $arr;//echo只能打印基本数据类型echo $arr[0];//张飞 关联数组（类似与JS中的对象） 123//属性名必须用引号引起来$arr = array(\"name\"=>\"zhangsan\", \"age\"=>18);echo $arr[\"name\"]; 输出语句 12345//1. echo 输出简单数据类型//2. print_r 输出数据结构，一般用于输出复杂类型。print_r($arr);//print_r是一个函数，不要忘记小括号//3. var_dump 输出完整的数据结构，包括类型，一般用于精准调试var_dump($arr); 二维数组 数组中的每个元素又是一个数组二维数组的存取元素，需要两次访问，依次确定行和列$arr[x][y]; 123456789101112131415161718192021222324252627282930313233//索引数组 $arr=[ [1,2,3], [4,5,6], [7,8,9] ]; //取值 echo $arr[2][2]; //存储一个人信息 $info=[ \"name\"=>\"zs\", \"age\"=>100 ]; //存储一个班信息 $infos=[ [ \"name\"=>\"zs\", \"age\"=>100 ], [ \"name\"=>\"ls\", \"age\"=>100 ], [ \"name\"=>\"ww\", \"age\"=>100 ] ];//取值 echo $infos[1][\"name\"]; 对象(了解) 在php以及其他高级语言中，都有类的概念，表示一类对象，跟js中构造函数类似。 对象我们学习过程中用不到，了解即可。无需深究 123456789101112//定义一个类（类似js的构造函数）class Person { public $name = \"小明\"; public $age = 12; private $sex = \"男\";}$zs = new Person;print_r($zs);//打印对象的结构信息echo $zs->name;//对象中取值用 ->echo $zs->age;echo $zs->sex;//私有属性，无法获取 语句判断语句基本上来说，所有语言的if..else语法都是一样 123456$age = 17;if ($age >= 18) { echo \"终于可以看电影了,嘿嘿嘿\";} else { echo \"哎，还是回家学习吧\";} 循环语句遍历索引数组 123456$arr = array(\"张三\", \"李四\", \"王五\", \"赵六\", \"田七\", \"王八\");//获取数组的长度： count($arr)for($i = 0; $i < count($arr); $i++) { echo $arr[$i]; echo \"\";} 遍历关联数组 123456789//遍历关联数组$arr = array( \"name\"=>\"zs\", \"age\"=>18, \"sex\"=>20);foreach($arr as $key => $value) { echo $key . \"=\" . $value . \"\";} 函数123456789101112 常量 常量的定义 脚本执行周期内，值不会发生改变的量。常量不可以修改及删除。定义为常量可以节省存储空间。英文为：`constant` 语法 1define(常量名，常量值); 123define('VERSION','1.2.0'); //常量默认全部字母大写define('PI',3.1415926);echo 'PI:',PI; //使用时直接使用常量名 常量默认区分大小写。 按照开发惯例，常量名推荐全部字母大写。 常量不可以重复定义及修改数据。 常量值为标量数据类型（整型、浮点型、布尔类型、字符串）。 PHP内置函数数学函数 max(),min() 分别返回一组数的最大值及最小值； abs() 返回绝对值。 floor() 向下取整。 ceil() 向上取整。 round() 四舍五入。 rand() 返回随机数，可以取到两端的值。 日期函数 time() 返回当前的 时间戳(1970到现在的时间的秒数) date(format,time) 格式化一个本地时间或日期 格式：Y(年) m(月) d(日) H(时) i(分) s秒 12$time=time();//获取时间戳echo date('Y-m-d H:i:s',$time); //格式化时间戳 字符串函数 str_replace(查找的值，替换的值，执行替换操作的字符) 字符串替换 trim(字符串); 去除字符串首尾处的空白字符 explode(分割符，执行分割的字符串); 使用一个字符串分割另一个字符串 implode(连接符，执行连接的数组); 将一个一维数组的值拼接为字符串 substr( 字符串，起始索引，截取长度 ); 返回字符串的子串 strchr(字符串，标识字符); 从左向右查找指定的字符，并返回该字符后全部字符 strrchr(字符串，标识字符); 从右向左查找指定的字符，并返回该字符后全部字符串 表单处理 表单（form）：表单用于收集用户输入信息，并将数据提交给服务器。是一种常见的与服务端数据交互的一种方式 1234//1. action：指定表单的提交地址//2. method:指定表单的提交方式，get/post，默认get//3. input的数据想要提交到后台，必须指定name属性，后台通过name属性获取值//4. 想要提交表单，不能使用input:button 必须使用input:submit php获取表单数据 12//$_GET是PHP系统提供的一个超全局变量，是一个数组，里面存放了表单通过get方式提交的数据。//$_POST是PHP系统提供的一个超全局变量，是一个数组，里面存放了表单通过post方式提交的数据。 get与post的区别 12345678//1. get方式 //1.1 数据会拼接在url地址的后面?username=hcc&password=123456 //1.2 地址栏有长度限制，因此get方式提交数据大小不会超过4k//2. post方式 //2.1 数据不会在url中显示，相比get方式，post更安全 //2.2 提交的数据没有大小限制//根据HTTP规范，GET用于信息获取，POST表示可能修改变服务器上的资源的请求 文件上传html要求 1231. 文件上传的提交方式必须是post方式2. 需要给form指定enctype=\"multipart/form-data\"3. 指定name属性，后台才能获取到 php相关 文件上传时，通过$_FILES才能获取到，这是一个二维数组。 12345678array (size=1) 'myfile' => array (size=5) 'name' => string '_20130614_17445.jpg' (length=22) //文件名 'type' => string 'image/jpeg' (length=10) //文件类型 'tmp_name' => string 'C:\\wamp\\tmp\\php40F4.tmp' (length=23) //文件保存临时位置 'error' => int 0 //错误码 （0表示没有错误） 'size' => int 103350 //文件大小(字节) 上传文件时，文件会临时保存在服务器上，如果文件最终没有保存，那么临时文件会被删除，保证服务器安全。 sleep(10)可以让代码延迟10秒钟才执行。 move_uploaded_file($path, $newPath);可以保存临时图片 1234567891011121314151617181920 //服务器保存图片的思路：//1-判断 文件不为空 并且 上传文件没有出现错误 的情况下进行保存 //2-获取临时文件文件路径 //3-随机生成一个文件名 //3-进行保存 //error==0 表示文件上传成功 if( !empty($_FILES['myfile']) && $_FILES['myfile']['error']==0 ){ //获取临时文件名 $ftmp=$_FILES['myfile']['tmp_name']; //文件名字随机生成，但是后缀名不能改变 //1-获取文件原来的后缀名拓展名 $fname=$_FILES['myfile']['name']; //aa.png //2-截取后缀名 $ext=strrchr($fname,'.'); //3-生成新的文件名 $newName=time().rand(1000,9999).$ext; //4-保存文件 move_uploaded_file($ftmp,'./upload/'.$newName); } 推荐表单样式 12345678910111213141516171819202122232425262728293031*{ margin: 0; padding: 0;}body{ background:rgb(135, 171, 230);}h1,h2,h3,h4,h5,h6{ text-align: center;}form{ width: 400px; margin:50px auto; padding:20px; border: 1px solid #eee; border-radius: 10px; background:#fff;}input[type='text'],input[type='select'],input[type='password'],input[type='submit'],input[type='password'],input[type='file'],select{ width: 100%; display: block; height: 24px; margin-bottom:15px; border-radius: 3px; border:1px solid #aaa;}input[type='submit']{ height: 40px; background:rgb(209, 92, 92); border:none; color:#fff; font-size: 24px;}input[type='radio'],input[type='checkbox']{ height: 20px; width:20px; margin:10px;}input[type='file']{border:none; } vscode快捷键 ctrl+k+w 关闭全部窗口 Ctrl+Shift+N 打开新窗口 Alt+ ↑ / ↓ 当前行上/下移 Shift+Alt + ↓ / ↑ 向上/下 复制一行 Ctrl+Shift+K 删除行 Ctrl+Enter 光标移动到下一行 Ctrl+Shift+\\ 跳转到当前匹配的符号 Ctrl+] / [ 展开折叠块 Shift+Alt+I 多行选中 Shift+Alt+鼠标选择 Ctrl + K F关闭文件夹 Ctrl+Shift+V Open Markdown preview Ctrl+K Ctrl+W 关闭所有 Ctrl+k s 保存所有 shift+F11 切换 zen模式 include文件引入介绍 不同的页面中有相同的代码部分，可以将其分离为单个文件。需要调用时，引入对应的文件即可调用。提高代码的复用率。 语法1include | include_once \"文件的路径\" include与rinclude_once区别 都是语言结构，不是函数。 include 可以重复引入文件 include_once 只引入一次，防止多次引入文件 页面动态渲染 PHP本身支持与HTML混编 混编的文件后缀必须为.php，Apache才会调用PHP解析 PHP与HTML混编时，服务器中的PHP引擎 只会执行php标签内部的PHP代码，非PHP的代码(PHP标签外部的内容)直接忽略，最后会将PHP的执行结果和非PHP代码 一起返回给浏览器,由浏览器进行解析 ​ 12345678百度一下 二维数组 数组中的每个给元素，又是一个数组 12345678910111213141516171819202122232425 //二维数组的形式 $arr=[ [2,3,4,5,6], [2,3,4,5,6], [2,3,4,5,6], [2,3,4,5,6] ];//二维关联数组 $info=[ [ \"name\"=>\"zs\", \"age\"=>18, \"sex\"=>\"男\" ], [ \"name\"=>\"ls\", \"age\"=>18, \"sex\"=>\"女\" ], [ \"name\"=>\"ww\", \"age\"=>19, \"sex\"=>\"男\" ] ] PHP数据读写到文件(数据持久化)程序运行过程中，数据是存储在内存中，程序结束数据会销毁，如果希望可以永久存储，可以将数据存储在硬盘上（存储在文件中）； 将数据有内存 存储到硬盘的过程，称为数据的持久化； file_get_contents(path) 把整个文件读入一个字符串中。 file_put_contents(path,$str) 函数把一个字符串写入文件中。 json_encode($data); 将PHP变量转成JSON格式字符串。 json_decode($str,true); 接受一个 JSON 编码的字符串并且把它转换为 PHP 变量。 参数1:要转换字符串参数2：该参数为 TRUE 时，将返回 array 而非 object 表单处理 表单（form）：表单用于收集用户输入信息，并将数据提交给服务器。是一种常见的与服务端数据交互的一种方式 1234//1. action：指定表单的提交地址//2. method:指定表单的提交方式，get/post，默认get//3. input的数据想要提交到后台，必须指定name属性，后台通过name属性获取值//4. 想要提交表单，不能使用input:button 必须使用input:submit php获取表单数据 12//$_GET是PHP系统提供的一个超全局变量，是一个数组，里面存放了表单通过get方式提交的数据。//$_POST是PHP系统提供的一个超全局变量，是一个数组，里面存放了表单通过post方式提交的数据。 get与post的区别 12345678//1. get方式 //1.1 数据会拼接在url地址的后面?username=hcc&password=123456 //1.2 地址栏有长度限制，因此get方式提交数据大小不会超过4k//2. post方式 //2.1 数据不会在url中显示，相比get方式，post更安全 //2.2 提交的数据没有大小限制//根据HTTP规范，GET用于信息获取，POST表示可能修改变服务器上的资源的请求 文件上传html要求 1231. 文件上传的提交方式必须是post方式2. 需要给form指定enctype=\"multipart/form-data\"3. 指定name属性，后台才能获取到 php相关 文件上传时，通过$_FILES才能获取到，这是一个二维数组。 12345678array (size=1) 'myfile' => array (size=5) 'name' => string '_20130614_17445.jpg' (length=22) //文件名 'type' => string 'image/jpeg' (length=10) //文件类型 'tmp_name' => string 'C:\\wamp\\tmp\\php40F4.tmp' (length=23) //文件保存临时位置 'error' => int 0 //错误码 （0表示没有错误） 'size' => int 103350 //文件大小(字节) ​ 上传文件时，文件会临时保存在服务器上，如果文件最终没有保存，那么临时文件会被删除，保证服务器安全。 sleep(10)可以让代码延迟10秒钟才执行。 move_uploaded_file($path, $newPath);可以保存临时图片 1234567891011121314151617181920 //服务器保存图片的思路：//1-判断 文件不为空 并且 上传文件没有出现错误 的情况下进行保存 //2-获取临时文件文件路径 //3-随机生成一个文件名 //3-进行保存 //error==0 表示文件上传成功 if( !empty($_FILES['myfile']) && $_FILES['myfile']['error']==0 ){ //获取临时文件名 $ftmp=$_FILES['myfile']['tmp_name']; //文件名字随机生成，但是后缀名不能改变 //1-获取文件原来的后缀名拓展名 $fname=$_FILES['myfile']['name']; //aa.png //2-截取后缀名 $ext=strrchr($fname,'.'); //3-生成新的文件名 $newName=time().rand(1000,9999).$ext; //4-保存文件 move_uploaded_file($ftmp,'./upload/'.$newName); } 表单标签的使用常见的输入类型：文本域（type=text）、单选按钮(type=radio)、多选按钮（复选项 type=checkbox）、下拉菜单(select>option)、多行文本(textarea); 单选项的数据接收 input标记的type =radio，单选按钮。 各个选项均需要指定name及value值。 name值相同，value值不同。 可以使用checked设置默认选项 html结构 1234567 性别： 男 女 弯 复选框的数据接收 input的type =checkbox,可以同时选择多个选项。 name命名形式必须为：name[]，最终数据才能以数组的格式，将各个选项的值同时提交，否则只能提交最后一个勾选的属性值。不同的选项值，以数组元素的形式提交。 html结构 123456789101112131415 兴趣： 敲代码 吃饭 打豆豆 下拉列表接收选项比较多的情况：籍贯、类型。 select >option实现的是单选项，下拉菜单。 name属性必选。value值为必选。 selected 默认选中项 html结构如下： 12345678910 城市： 上海市 北京市 天津市 西红柿 数据回显时的默认选中 当表单提交到当前页面时，希望可以看到之前用户选中的项 123456789101112131415161718192021222324252627282930313233343536 Document 城市： 上海市 北京市 天津市 西红柿 学生信息管理系统基本功能 学生注册功能添加 展示学生信息功能 删除学生信息 实现思路注册功能 1. 获取前端表单传递数据 2. 获取前端传递图片，并保存在服务器中 3. 将表单的数据和上传图片的地址 保存在数据库中 4. 页面跳转到列表页 注意： 我们目前没有学习数据库，使用txt记事本来模拟，实现思路： 1. 存储一个人的信息使用一维数组 2. 存储一个班的信息要使用二维数组 3. 数组是一个变量，页面关闭后，数据会销毁，下次打开页面后，数据不存在了 4. 为了数据能永久存储，把数据存储到txt文件中 5. 对学生数据的增删改查，先把二维数组从文件中取出来，操作二维数组即可，操作完成后把数组存到文件中 展示功能 1.获取txt记事本中的学生数据字符串，转成二维数组 2.动态遍历渲染在页面中删除功能 1.获取要删除学生id, 2.从data.txt中取出字符串形式学生数据 3.将字符串数据转成二维数组 4.根据id，从二维数组中删除指定索引的元素 5.把二维数组转成字符串 6.把字符串中的数据 存储到data.txt中 HTTP协议协议： 协议，就是事先的一种约定、规则、规范、标准。（入学协议） 常见协议 HTTP、HTTPS 超文本传输协议 FTP 文件传输协议 SMTP 简单邮件传输协议 HTTP协议 即超文本传输协议，网站是基于HTTP协议的，例如网站的图片、CSS、JS等都是基于HTTP协议进行传输的。 HTTP协议是由从客户机到服务器的请求(Request)和从服务器到客户机的响应(Response)进行了约束和规范。 即HTTP协议主要由请求和响应构成。 常用请求方法 POST、GET、PUT、DELETE 请求 (request)：请求行、请求头、请求主体。 响应 (response)：状态行、响应头、响应主体。 请求报文和响应报文请求/请求报文 请求由客户端发起，其规范格式为：请求行、请求头、请求主体。 响应/响应报文 响应由服务器发出，其规范格式为：状态行、响应头、响应主体。 get请求的请求报文详解 12345678910111213141516171819202122232425//--------------------------请求行--------------------------------// GET 请求方式// /day02/01.php?username=hucc&password=123456 请求路径+参数（注意点）// HTTP/1.1 HTTP的版本号GET /day02/01.php?username=hucc&password=123456 HTTP/1.1//--------------------------请求头--------------------------------// Host:主机地址Host: www.study.com// HTTP1.1版本默认开启，建立过连接后，TCP连接不会断开，下次连接可以继续使用（底层，不用管）Connection: keep-alive//chrome浏览器自己增加的，不用管Upgrade-Insecure-Requests: 1//浏览器的代理字符串（版本信息）User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.96 Safari/537.36//浏览器端可以接受的类型。Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,`*/*`;q=0.8//从哪个页面发出的请求Referer: http://www.study.com/day02/01-login.html//检查浏览器支持的压缩方式Accept-Encoding: gzip, deflate, sdch//浏览器支持的语言，优先中文。Accept-Language: zh-CN,zh;q=0.8,en;q=0.6//----------------------------请求体-------------------------------------//get请求没有请求体，因为要传递的数据已经拼接到了请求头中 POST请求的请求报文 123456789101112131415161718192021//-----------------------请求行---------------------------------------------POST /day02/01.php HTTP/1.1//-----------------------请求头--------------------------------------------Host: www.study.comConnection: keep-alive//传递的参数的长度。Content-Length: 29Cache-Control: max-age=0Origin: http://www.study.comUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.96 Safari/537.36//内容类型：表单数据，如果是post请求，必须指定这个属性。Content-Type: application/x-www-form-urlencodedAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,`*/*`;q=0.8Referer: http://www.study.com/day02/01-login.htmlAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.8,en;q=0.6//------------------------请求体------------------------------------------username=hucc&password=123456 GET请求与POST请求的对比 GET请求没有请求体，因为GET请求的参数拼接到地址栏中了/day02/01.php?username=hucc&password=123456 POST请求有请求体，就是传递的参数。 POST请求需要指定content-type属性。content-type:application/x-www-form-urlencoded 响应与响应报文12345678910111213141516171819//---------------------状态行（响应行）-------------------------------//HTTP/1.1 HTTP版本//200 响应的状态 //200表示成功 //302页面重定向 //304表示文档未修改 //404表示找不到资源 //500表示服务端错误HTTP/1.1 200 OK//----------------------响应头-----------------------------------------------Date: Thu, 22 Jun 2017 16:51:22 GMT //服务器的时间Server: Apache/2.4.23 (Win32) OpenSSL/1.0.2j PHP/5.4.45 //服务器的版本信息X-Powered-By: PHP/5.4.45 //后台编程语言信息Content-Length: 18 //服务器的响应主体长度//内容类型，告诉浏览器该如何解析响应结果Content-Type: text/html;charset=utf-8//-----------------------响应体------------------------------------------------用户登录成功 通常来说，我们不会用抓包工具来查看请求和响应，太麻烦了，可以直接使用谷歌浏览器来查看请求报文和响应报文。 谷歌浏览器会对报文进行一定的格式化，看起来虽然不是原生的报文，但是使用起来更加的方便简洁。 Mysql数据库技术初识数据库概念数据库基本概念 专门用来存储、管理数据的仓库（空间），按照数据结构来组织、存储和管理，可以实现高效存储及读取的数据解决方案。英文：Database,DB。数据是程序核心实际项目中，一般将项目相关的数据全部存储在单个数据库中。数据库有专门的、高效的数据管理系统（DBMS），可以应对数据量较大、关系较为复杂的情况。 关系型数据库 当前使用范围最广的数据库。按照关系模型（数据之间存在联系）组织的数据库。数据存储在硬盘文件中。 订单：订单编号，商品名称，价格，数量，配送地址 订单编号 商品名称 价格 数量 配送地址 100123 华为mate10 4999 2 北京市京顺路99号 100124 花裙子 499 1 北京市清华大学1号楼 关系模型是采用二维表格（行、列）及其之间的联系。 相对于其他模型，更贴合现实世界，更便于理解。 关系型数据库 数据存储在硬盘上 非关系型 数据库 数据存储在内存中 数据库的组织架构： 数据表（table） 表是以行和列的形式组织起来的数据的集合。项目一般需要不同的数据表，将数据分布存储在不同的数据表中。 数据库的数据存放在数据表中 如：订单表，用户表，商品表，配送地址表， 记录-行（row，record） 一行有意义的信息的集合 字段-列(column，field) 某一列的值的名称 通过行列交叉确定具体数据 关系型数据库产品—MySQL介绍瑞典AB公司开发，现为Oracle公司所有。2010年04月22 发布了MySQL 5.5。 数据库官网地址：https://dev.mysql.com 英文手册地址：https://dev.mysql.com/doc/refman/5.5/en/ 中文参考论坛：http://www.mysqlpub.com/ SQL-操作数据库语言（了解）SQL：structured Query Language 结构化查询语言。 SQL语句，相当于客户端发送的命令（与数据库服务器进行交互）。 概念 关系型数据库所使用通用语言。为一个ISO标准。 w3c .sql 数据库脚本语言的后缀。 分类 主要是执行 数据操作的基本逻辑有：增删改查 操作 数据库操作方式 数据库的相关设置： （打开数据库命令行，修改数据库密码等） 命令行演示 show databases; use database; show tables; crud（结合图形界面演示） 图形界面客户端 乱码： 编码 —>解码 的格式不一致造成 创建连接 创建数据库 删除数据库 创建表 编辑表 删除表 数据增删改查操作##数据库表的操作###数据库的数据类型字段类型初步介绍 整型 存储如年龄，产品数量，编号等。 int（0-21亿） 小数类型 float ,decimal eg.重量，工资，奖金，价格等 使用decimal类型，实现小数的精确存储,一般用来存储与钱有关的数字。3.333333331 字符串型 varchar(M)，char(M) M为该字段可以存储的最多字符数，如varchar(10)。M参数不可以省略。 varchar一般用来存储长度变化比较大的字符串，如文章标题，商品名称， char存储长度比较固定的字符串，如手机号，身份证号，序列号，邮编。 此外可以使用text类型，存储较长的字符串，无需指定字符串的具体长度。 日期时间型 datetime,date(年月日)，time（时分秒）。年月日时分秒，也可以使用PHP获取时间戳整型数字存储。 字段约束 字段数据的属性（特征） not null 不为空 限制字段值不能为空 default 默认值 设置字段的默认值，在没有录入时自动使用默认值填充。 primary key 主键 ：唯一标识，不能重复，不能为空 设置字段为主键，主键字段的值不能重复，不能为空。而且一个数据表中只能设置一个字段为主键，作为每行记录的唯一身份信息（索引）。stu_id int primary key auto_increment 自动增长 设置字段为自动增长，默认从1开始自动分配编号。自增长字段必须为一个key（索引，数据结构，便于快速查找数据，相当于书的目录），一般与primary key结合使用。 类型必须为整型。 unique key 不能重复 唯一键，设置字段的值为唯一的，可以设置多个字段为唯一键。唯一键字段的值可以为空。 学号设置为主键，要求唯一的，不能为空的，用来标识学生信息， 姓名，不能重名，设置唯一键，该字段的值唯一的 、不重复的、可以为空的 创建数据表 注意 创建表时，每个表必须有一个主键 保存表结构： 向新建的表中添加数据： SQL SQL基本概述 注释用 – 语句结束加分号(;)增 删 改 查 插入数据insert 12-- insert into 表名 (字段列表) values (值列表)insert into book (name,author,category,price) values ('天龙八部','金庸','文学',20) 修改数据update 12-- update 表名 set 字段名称1=值1,字段名称2=值2,... where 条件update book set name='笑傲江湖',price='30' where id=10 删除数据delete 12-- delete from 表名 where 条件delete from book where id=10 查询数据select 12-- select * from 表名 where 条件select * from book where author='金庸' and price>20 SQL高级 where子句 ​查询时，不添加where条件返回数据表所有行。需要添加限定条件，只返回需要的行。 select 字段列表 from table where子句； Like 模糊匹配 % 通配符 12-- 查找姓张的人select * from table where name like '张%'; in 语法：一次查询多个符合条件的数据 1select 字段列表 from tb where 字段 in (value1,value2,value3); Count() 获取返回数据的总条数 12-- 查询满足条件数据的总条数 select count(*) from table where 条件 limit 子句 返回查找结果中的前n行1select 字段列表 from table limit 截取的起始索引，截取的长度 连接查询1select 字段列表 from A join B on A.字段 = B.字段 [where子句]; 查询学生基本信息以及班级信息： 注意各个子句之间的顺序。1select 字段列表 from table where 子句 创建学生表 ：编号 、姓名、年龄、性别 123456789101112131415161718192021222324-- ------------------------------ Table structure for stu1-- ----------------------------DROP TABLE IF EXISTS `stu1`;CREATE TABLE `stu1` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(50) NOT NULL, `age` int(11) DEFAULT NULL, `sex` varchar(10) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=MyISAM AUTO_INCREMENT=11 DEFAULT CHARSET=utf8;-- ------------------------------ Records of stu1-- ----------------------------INSERT INTO `stu1` VALUES ('1', '张三', '18', '男');INSERT INTO `stu1` VALUES ('2', '李四', '19', '女');INSERT INTO `stu1` VALUES ('3', '王五', '22', '男');INSERT INTO `stu1` VALUES ('5', '赵六', '18', '女');INSERT INTO `stu1` VALUES ('6', '田七', '15', '男');INSERT INTO `stu1` VALUES ('7', '王八', '16', '女');INSERT INTO `stu1` VALUES ('8', '李狗蛋', '18', '男');INSERT INTO `stu1` VALUES ('9', '李元芳', '20', '男');INSERT INTO `stu1` VALUES ('10', '张飞', '16', '男'); PHP代码操作数据连接数据库基本步骤1-连接数据库2-准备sql语句3-执行sql语句4-获取执行的结果并分析5-释放并关闭数据库 操作数据库常用API mysqli_connect(IP,用户名，密码，数据库名) 连接数据库 mysqli_query($link,$sql) 执SQL语句 mysqi_error($link); 返回最近调用函数的错误描述 mysql_close($link) 关闭连接 mysqli_fetch_assoc($res) 以关联数组的形式范湖数据 mysqli_num_rows(resource $res); 返回结果集的行数 sql操作注意事项： 使用PHP发送SQL语句前，可以先打印SQL语句，检查语句的正确性。 使用变量拼接SQL语句时，字段为字符串类型，需要在变量的两侧使用单、双引号包裹。可以将所有的字段外面都使用双引号包含。 12345678910111213141516171819202122232425262728293031323334353637383940//常用方法 //mysqli_connect('ip地址','用户名','密码','数据库名称'); //如果成功返回 数据库连接 //如果失败返回 false //die('文本'); 终止程序的执行 //mysqli_query(数据库连接,要执行的sql语句); //成功 返回 true //失败 返回 false //mysqli_close(数据库连接); 关闭数据库的连接 //mysqli_error(数据库的连接)； 输出数据库最近一次执行错误信息 //@ 抑制错误 //1-连接数据库 @$link= mysqli_connect('127.0.0.1','root','','test1');// 如果出错 给用户提示 if(!$link){ //如果数据库连接失败，后面代码直接结束 die('数据库连接失败！'); }//2-操作数据 //2-1 准备好sql语句（删除） $id=14; //双引号可以解析变量 $sql=\"delete from stu1 where icd=$id\"; //2-2 让数据库执行sql语句 if(mysqli_query($link,$sql)){ echo '删除成功！'; }else{ echo ''; //输出数据库最近一次执行错误 echo mysqli_error($link); } //关闭数据库连接 mysqli_close($link); 非查询(增删改)和查询语句（select）的区别通过mysqli_query()函数，来执行sql语句，操作数据库 执行的是非查询sql语句时，mysqli_query()执行成功返回true,失败返回false 作为标识 而执行查询的sql语句是，mysqli_query()执行成功，返回查询数据的结果集（二维数组），失败返回false，我们拿到数据库中返回的数据进行渲染处理;查询数据逻辑如下 123456789101112131415161718192021222324252627282930313233343536//操作数据的基本步骤：//1-连接数据库 //2-准备sql语句//3-操作数据（对数据库进行增删改查）//4-获取执行结果 //5-关闭数据连接 //1-连接数据库 @$link=mysqli_connect('127.0.0.1','root','','test1'); if(!$link){ die('数据库连接失败!'); } //进行查询炒作 $sql=\"select * from stu1\"; //执行sql // 如果 mysqi_query 执行的是查询语句 // 查询成功 返回的 查询到的数据的结果集 // 查询失败 返回 false $res=mysqli_query($link,$sql);//如果获取到数据 把数据保存到php中，然后传给前端//当查询结果不为false并且数据行数大于0行 进行保存//mysqli_num_rows($res);//获取结果集的行数 if(!$res || mysqli_num_rows($res)==0 ){ die('未获取到数据！'); } //对数据进行保存 //获取结果集中的数据 // mysqli_fetch_assoc($res); 返回的是一个关联数组 一次取一条数据while($row=mysqli_fetch_assoc($res)){ $arr[]=$row; //把每次获取的一行的关联数组的数据 放到$arr数组}mysqli_close($link); 数据库工具函数的封装 为了提高代码的复用性，把数据增删改的操作封装成一个方法 封装公共代码部分，变换的部分提取成参数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//定义常量 存储数据库基本信息define('HOST','127.0.0.1');define('UNAME','root');define('PWD','');define('DB','test1');//非查询功能function my_exec($sql){ //1-连接数据库 @$link=mysqli_connect(HOST,UNAME,PWD,DB); //判断 if(!$link){ die('数据库连接失败！'); } //2-执行sql语句，判断执行结果 if(!mysqli_query($link,$sql)){ //如果失败输出错误信息 echo '操作失败！'.mysqli_error($link); } //3-关闭连接 mysqli_close($link);}//查询功能function my_query($sql){ //1-连接数据库 @$link=mysqli_connect(HOST,UNAME,PWD,DB); //判断连接 if(!$link){ echo '数据库连接失败！'; return false; } //执行查询 $res=mysqli_query($link,$sql); //判断是否有数据 if(!$res || mysqli_num_rows($res)==0 ){ echo '未获取到数据！'; //关闭连接 mysqli_close($link); return false; } //保存数据 二维数组的形式 //获取结果集中所有的数据 while($row=mysqli_fetch_assoc($res)){ $arr[]=$row; } //关闭连接 mysqli_close($link); //返回数据库的数据 return $arr; } SQL高级 where子句 ​查询时，不添加where条件返回数据表所有行。需要添加限定条件，只返回需要的行。 select 字段列表 from table where子句； Like 模糊匹配 % 通配符 12-- 查找姓张的人select * from table where name like '张%'; in 语法：一次查询多个符合条件的数据 1select 字段列表 from tb where 字段 in (value1,value2,value3); Count() 获取返回数据的总条数 12-- 查询满足条件数据的总条数 select count(*) from table where 条件 limit 子句 返回查找结果中的前n行1select 字段列表 from table limit 截取的起始索引，截取的长度 连接查询（多个表联合查询）1select 字段列表 from A join B on A.字段 = B.字段 [where子句]; 查询学生基本信息以及班级信息： 注意各个子句之间的顺序。1select 字段列表 from table [join] [where] [limit] PHP操作数据库连接数据库基本步骤1-连接数据库2-准备sql语句3-执行sql语句4-获取执行的结果并分析5-释放并关闭数据库 操作数据库常用API mysqli_connect(IP,用户名，密码，数据库名) 连接数据库 mysqli_query($link,$sql) 执SQL语句 mysqi_error($link); 返回最近调用函数的错误描述 mysql_close($link) 关闭连接 mysqli_fetch_assoc($res) 以关联数组的形式范湖数据 mysqli_num_rows(resource $res); 返回结果集的行数 sql操作注意事项： 使用PHP发送SQL语句前，可以先打印SQL语句，检查语句的正确性。 使用变量拼接SQL语句时，字段为字符串类型，需要在变量的两侧使用单、双引号包裹。可以将所有的字段外面都使用双引号包含。 12345678910111213141516171819202122232425262728293031323334353637383940//常用方法 //mysqli_connect('ip地址','用户名','密码','数据库名称'); //如果成功返回 数据库连接 //如果失败返回 false //die('文本'); 终止程序的执行 //mysqli_query(数据库连接,要执行的sql语句); //成功 返回 true //失败 返回 false //mysqli_close(数据库连接); 关闭数据库的连接 //mysqli_error(数据库的连接)； 输出数据库最近一次执行错误信息 //@ 抑制错误 //1-连接数据库 @$link= mysqli_connect('127.0.0.1','root','','test1');// 如果出错 给用户提示 if(!$link){ //如果数据库连接失败，后面代码直接结束 die('数据库连接失败！'); }//2-操作数据 //2-1 准备好sql语句（删除） $id=14; //双引号可以解析变量 $sql=\"delete from stu1 where icd=$id\"; //2-2 让数据库执行sql语句 if(mysqli_query($link,$sql)){ echo '删除成功！'; }else{ echo ''; //输出数据库最近一次执行错误 echo mysqli_error($link); } //关闭数据库连接 mysqli_close($link); 非查询(增删改)和查询语句（select）的区别通过mysqli_query()函数，来执行sql语句，操作数据库 执行的是非查询sql语句时，mysqli_query()执行成功返回true,失败返回false 作为标识 而执行查询的sql语句是，mysqli_query()执行成功，返回查询数据的结果集（二维数组），失败返回false，我们拿到数据库中返回的数据进行渲染处理;查询数据逻辑如下 12345678910111213141516171819202122232425262728293031323334353637//操作数据的基本步骤：//1-连接数据库 //2-准备sql语句//3-操作数据（对数据库进行增删改查）//4-获取执行结果 //5-关闭数据连接 //1-连接数据库 @$link=mysqli_connect('127.0.0.1','root','','test1'); if(!$link){ die('数据库连接失败!'); } //进行查询炒作 $sql=\"select * from stu1\"; //执行sql // 如果 mysqi_query 执行的是查询语句 // 查询成功 返回的 查询到的数据的结果集 // 查询失败 返回 false $res=mysqli_query($link,$sql);//如果获取到数据 把数据保存到php中，然后传给前端//当查询结果不为false并且数据行数大于0行 进行保存//mysqli_num_rows($res);//获取结果集的行数 if(!$res || mysqli_num_rows($res)==0 ){ die('未获取到数据！'); } //对数据进行保存 //获取结果集中的数据 // mysqli_fetch_assoc($res); 返回的是一个关联数组 一次取一条数据while($row=mysqli_fetch_assoc($res)){ $arr[]=$row; //把每次获取的一行的关联数组的数据 放到$arr数组}mysqli_close($link); 数据库工具函数的封装 为了提高代码的复用性，把数据增删改的操作封装成一个方法 封装公共代码部分，变换的部分提取成参 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//定义常量 存储数据库基本信息define('HOST','127.0.0.1');define('UNAME','root');define('PWD','');define('DB','test1');//非查询功能function my_exec($sql){ //1-连接数据库 @$link=mysqli_connect(HOST,UNAME,PWD,DB); //判断 if(!$link){ die('数据库连接失败！'); } //2-执行sql语句，判断执行结果 if(!mysqli_query($link,$sql)){ //如果失败输出错误信息 echo '操作失败！'.mysqli_error($link); } //3-关闭连接 mysqli_close($link);}//查询功能function my_query($sql){ //1-连接数据库 @$link=mysqli_connect(HOST,UNAME,PWD,DB); //判断连接 if(!$link){ echo '数据库连接失败！'; return false; } //执行查询 $res=mysqli_query($link,$sql); //判断是否有数据 if(!$res || mysqli_num_rows($res)==0 ){ echo '未获取到数据！'; //关闭连接 mysqli_close($link); return false; } //保存数据 二维数组的形式 //获取结果集中所有的数据 while($row=mysqli_fetch_assoc($res)){ $arr[]=$row; } //关闭连接 mysqli_close($link); //返回数据库的数据 return $arr; } COOKIE 和 SESSION会话技术会话：浏览器与服务器之间的数据交流。 会话的目的：在同一台浏览器对服务器的多次请求中，通过数据持久化存储技术，以实现连续的业务逻辑 HTTP协议特点：无状态、无记忆的 多次请求之间，无任何的联系 即同一用户请求同一网站的不同页面，服务器无法识别是否是同一用户发起的请求。因此，用户无法进行连续的业务逻辑。 如：登录，在A页面登录，请求B页面，提示登录。 按照数据持久化的位置进行区分 cookie:在浏览器端持久化数据的容器 session在服务器端持久化数据的容器 cookie 在浏览器端持久化数据的容器 可以使用js对cookie进行操作 cookie 允许服务器脚本（PHP脚本）在浏览器端存储数据 cookie特点：在cookie中数据设置后，浏览器再次请求服务器指定页面时，会自动携带cookie中的数据到服务器，在服务器中可以获取cookie中的数据； 浏览器查看cookie数据 js操作cookie（了解）123456789101112131415// 设置cookie document.cookie = 'name=zs'; document.cookie = 'pwd=123'; // 获取cookie中的值 var cookies = document.cookie; var arr = cookies.split('; '); //注意这里是 '; ' 有空格的 if(arr){ for (var i = 0; i < arr.length; i++) { var data = arr[i].split('='); if(data[0] == 'name'){ console.log(data[1]); } } } jquery.cookie.js插件 操作cookie123456//向页面中引入插件js文件，基于jquery的 $.cookie('weight',100,{expires:7});//设置 expires 过期时间$.cookie('name');//获取$.cookie('name',null);//删除 $.cookie(键,值,{expires:过期天数})$.cookie(键) //获取 PHP操作cookie(服务器端操作cookie)12345678//设置cookiesetcookie('名称','值'); setcookie('名称','值'，'有效期');//删除cookie 将过期时间设置为之前的时间即可setcookie('名称',''，time()-1000); //获取cookie //$_COOKIE是PHP的超全局变量，内部存放有浏览器传过来的cookie数据，$_COOKIE只能用于获取数据$_COOKIE['名称']; 注意点： cookie中的数据 可以被同一个网站的页面所共享 不同浏览器的cookie 不能共享 cookie的数据存储在浏览器中，每次请求服务器，在请求报文中携带cookie的数据，发送给服务器 服务器无法直接操作cookie，通过在服务器端设置响应头的的方式，通知浏览器对cookie进行设置， cookie中的数据有效期，不设置即浏览器关闭，会话结束，数据销毁 cookie存储容量小，约4kb session 在服务器端存储数据的容器 session容器是一个数组的形式，通过超全局变量$_SESSION 进行取值和设置 session在使用前，必须先开启session机制 session中的数据可以被当前网站所共享 session的基本操作开启sessiion机制(使用session前必须调用此方法)1session_start(); //开启session会话或者重用已经创建的会话。 session_start();的作用： 在服务器中随机生成一个sessionID 创建一个session会话文件，用于存储数据（文件名和session的相同，同一个会话只会创建一次） 在响应头中设置cookie,在cookie中存放本次会话的sessionID 设置和获取session中的数据(通过超全局变量$_SESSION进行操作) 12345678910//设置$_SESSION['键']='值'; //删除unset($_SESSION['键']); //清空session$_SESSION=[]; //直接删除session会话文件，PHP脚本将无法读取session数据session_destroy() //获取session的idsession_id(); COOKE 和SESSION的应用–登录状态保持登录模块的基本思路： 如果用户登录成功，在服务器中记录用户的登录状态 执行session_start(), 生产session文件，在session文件中，记录当前用户的信息 通过响应头部，给浏览器的cookie设置sessionID 12345if($name=='zs'&&$pwd=='666'){ //登录成功 session_start(); $_SESSION['username']=$name;} ​ 后续访问其他页面（购物车，个人中心），浏览器会自动发送cookie中存放的sessionID到服务器 服务器会浏览器传递根据sessionID,找到对应的session文件，查看其中是否存放有当前用户的信息 是： 用户已登录 ，正常浏览 否：用户未登录，跳转到登录页 1234567session_start();if(!empty($_SESSION['username'])){ //正常浏览}else{ header('location:./04-login.html'); die();//后面代码不执行} 流程图如下： 常见数据传输格式XML XML是一种标记语言，很类似HTML，其宗旨是用来传输数据，具有自我描述性（固定的格式的数据）。 语法规则 必须有一个根元素 不可有空格、不可以数字或.开头、大小写敏感 不可交叉嵌套 属性双引号（浏览器自动修正成双引号了） 特殊符号要使用实体 注释和HTML一样 虽然可以描述和传输复杂数据，但是其解析过于复杂并且体积较大，所以实现开发已经很少使用了。 其解析方式类似于DOM 1234567891011121314151617 鹏鹏 弯 18 飙车 &lt;&lt;老司机的自我修养&gt;&gt; 春哥 男 38 修发动机 C语言从入门到放弃 JSON 即 JavaScript Object Notation，另一种轻量级的文本数据交换格式，独立于语言。 语法规则1、数据在名称/值对中2、数据由逗号分隔(最后一个健/值对不能带逗号)3、花括号保存对象方括号保存数组4、使用双引号 JSON解析 JSON数据在不同语言进行传输时，类型为字符串，不同的语言各自也都对应有解析方法，需要解析完成后才能读取 Javascript 解析方法 ​JSON对象 JSON.parse()、JSON.stringify()；​JSON兼容处理json2.js PHP解析方法 ​json_encode() 、json_decode()总结： JSON体积小、解析方便且高效，在实际开发成为首选。","categories":[{"name":"php","slug":"php","permalink":"https://guoweiyanggithub.github.io/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"https://guoweiyanggithub.github.io/tags/php/"},{"name":"phpstudy","slug":"phpstudy","permalink":"https://guoweiyanggithub.github.io/tags/phpstudy/"}]},{"title":"js高级","slug":"js高级","date":"2019-03-08T02:06:46.000Z","updated":"2019-03-14T03:15:06.964Z","comments":true,"path":"2019/03/08/js高级/","link":"","permalink":"https://guoweiyanggithub.github.io/2019/03/08/js高级/","excerpt":"","text":"学习目标: 理解面向对象开发思想 掌握 JavaScript 面向对象开发相关模式 typora-copy-images-to mediaJavaScript 高级 回顾 由于 JavaScript 高级还是针对 JavaScript 语言本身的一个进阶学习，所以在开始之前我们先对以前所学过的 JavaScript 相关知识点做一个复习总结。 JavaScript 是什么 解析执行：轻量级解释型的 语言特点：动态，头等函数 (First-class Function) 又称函数是 JavaScript 中的一等公民 执行环境：在宿主环境（host environment）下运行，浏览器是最常见的 JavaScript 宿主环境 但是在很多非浏览器环境中也使用 JavaScript ，例如 node.js MDN-JavaScript JavaScript 的组成#####ECMAScript - 语法规范 变量、数据类型、类型转换、操作符(介绍in,delete) in 运算符 作用：判断指定属性是否存在于指定的对象中，存在返回：true 12345var obj = { age: 18};var hasAge = 'age' in obj;console.log(hasAge); delete运算符 作用:删除一个对象的属性,删除成功返回true 12345var obj = { age: 18};var hasAge = delete obj.age;console.log(hasAge); 流程控制：顺序结构, 分支结构(if, switch), 循环结构(while, do…while, for, for..in) 数组的常用方法: join 数组转字符串 arr.join(‘-‘); concat 数组合并,返回一个新的数组 slice() 复制一个新的数组 array.slice(begin, end); 包含头不包含尾 原数组不改变 splice 替换数组中的指定内容, array.splice(start, deleteCount, [items[,items…]); 原数组被改变 indexOf 查找数组中的指定项 array.lastIndexOf(search, [fromIndex]); forEach 用于遍历 every 数组中每一个项都符合条件才返回true some 数组中有一项符合条件就返回true filter 过滤数组 函数 函数的三要素:函数名, 参数,返回值 申明函数和函数表达式 在es5中只有函数可以构成一个局部作用域 ​ 对象、属性、方法、简单类型和复杂类型的区别 常用的内置对象：Math、Date、Array 基本包装类型 String、Number、Boolean Web APIs BOM onload页面加载事件，window顶级对象 定时器 offset client scroll DOM 获取页面元素，注册事件 属性操作，样式操作 节点, 节点的属性, 节点的方法 动态创建元素 事件：注册事件的方式、事件的三个阶段、事件对象 #####JavaScript 执行过程 JavaScript 运行分为两个阶段： 预解析 全局预解析（所有变量和函数声明都会提前；同名的函数和变量函数的优先级高） 函数内部预解析（所有的变量、函数和形参都会参与预解析） 函数 形参 普通变量 执行 先预解析全局作用域，然后执行全局作用域中的代码，在执行全局代码的过程中遇到函数调用就会先进行函数预解析，然后再执行函数内代码。 JavaScript 面向对象编程面向对象介绍什么是对象 Everything is object （万物皆对象） 对象到底是什么，我们可以从两次层次来理解。 (1) 对象是单个事物的抽象。 一本书、一辆汽车、一个人都可以是对象，一个数据库、一张网页、一个与远程服务器的连接也可以是对象。当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。 (2) 对象是一个容器，封装了属性（property）和方法（method）。 属性是对象的状态，方法是对象的行为（完成某种任务）。比如，我们可以把动物抽象为animal对象，使用“属性”记录具体是那一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。 在实际开发中，对象是一个抽象的概念，可以将其简单理解为：数据集或功能集。 ECMAScript-262 把对象定义为：无序属性的集合，其属性可以包含基本值、对象或者函数。严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。 什么是面向对象 面向对象不是新的东西，它只是过程式代码的一种高度封装，目的在于提高代码的开发效率和可维 护性。 面向对象编程 —— Object Oriented Programming，简称 OOP ，是一种编程开发思想。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。 在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目。 面向对象与面向过程： 面向过程就是亲力亲为，事无巨细，面面俱到，步步紧跟，有条不紊 面向对象就是找一个对象，指挥得结果 面向对象将执行者转变成指挥者 面向对象不是面向过程的替代，而是面向过程的封装 面向对象的特性： 封装性 继承性 [多态性]抽象 程序中面向对象的基本体现自定义的对象数据类型就是面向对象中的类（ Class ）的概念。 我们以一个例子来说明面向过程和面向对象在程序流程上的不同之处。 假设我们要处理学生的成绩表，为了表示一个学生的成绩，面向过程的程序可以用一个对象表示： 12var std1 = { name: 'Michael', score: 98 }var std2 = { name: 'Bob', score: 81 } 而处理学生成绩可以通过函数实现，比如打印学生的成绩： 123function printScore (student) { console.log('姓名：' + student.name + ' ' + '成绩：' + student.score)} 如果采用面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是 Student 这种数据类型应该被视为一个对象，这个对象拥有 name 和 score 这两个属性（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个 printScore 消息，让对象自己把自己的数据打印出来。 抽象数据行为模板（Class）： 1234567function Student(name, score) { this.name = name; this.score = score; this.printScore = function() { console.log('姓名：' + this.name + ' ' + '成绩：' + this.score); }} 根据模板创建具体实例对象（Instance）： 12var std1 = new Student('Michael', 98)var std2 = new Student('Bob', 81) 实例对象具有自己的具体行为（给对象发消息）： 12std1.printScore() // => 姓名：Michael 成绩：98std2.printScore() // => 姓名：Bob 成绩 81 ###创建对象 简单方式我们可以直接通过 new Object() 创建： 1234567var person = new Object()person.name = 'Jack'person.age = 18person.sayName = function () { console.log(this.name)} 每次创建通过 new Object() 比较麻烦，所以可以通过它的简写形式对象字面量来创建： 1234567var person = { name: 'Jack', age: 18, sayName: function () { console.log(this.name) }} 对于上面的写法固然没有问题，但是假如我们要生成两个 person 实例对象呢？ 123456789101112131415var person1 = { name: 'Jack', age: 18, sayName: function () { console.log(this.name) }}var person2 = { name: 'Mike', age: 16, sayName: function () { console.log(this.name) }} 通过上面的代码我们不难看出，这样写的代码太过冗余，重复性太高。 简单方式的改进：工厂函数我们可以写一个函数，解决代码重复问题： 123456789function createPerson (name, age) { return { name: name, age: age, sayName: function () { console.log(this.name); } }} 然后生成实例对象： 12var p1 = createPerson('Jack', 18)var p2 = createPerson('Mike', 18) 更优雅的方式：构造函数一种更优雅的工厂函数就是下面这样，构造函数： 12345678910111213function Person (name, age) { this.name = name this.age = age this.sayName = function () { console.log(this.name) }}var p1 = new Person('Jack', 18)p1.sayName() // => Jackvar p2 = new Person('Mike', 23)p2.sayName() // => Mike 构造函数中new关键字做了4件事:以这种方式调用构造函数会经历以下 4 个步骤： 创建一个新对象 让 this 就指向了这个新对象 执行构造函数中的代码 返回新对象 构造函数的问题使用构造函数带来的最大的好处就是创建对象更方便了，但是其本身也存在一个浪费内存的问题： 1234567891011function Person (name, age) { this.name = name this.age = age this.type = 'human' this.sayHello = function () { console.log('hello ' + this.name) }}var p1 = new Person('Tom', 18)var p2 = new Person('Jack', 16) 在该示例中，从表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type 和 sayHello 都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存，如果实例对象很多，会造成极大的内存浪费。 原型更好的解决方案： prototypeJavaScript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的所拥有。 这也就意味着，我们可以把所有对象实例需要共享的属性和方法直接定义在 prototype 对象上。 1234567891011121314151617function Person (name, age) { this.name = name this.age = age}console.log(Person.prototype)Person.prototype.type = 'human'Person.prototype.sayName = function () { console.log(this.name)}var p1 = new Person(...)var p2 = new Person(...)console.log(p1.sayName === p2.sayName) // => true 这时所有实例的 type 属性和 sayName() 方法，其实都是同一个内存地址，指向 prototype 对象，因此就提高了运行效率。 构造函数、实例、原型三者之间的关系任何函数都具有一个 prototype 属性，该属性是一个对象。 123456function F () {}console.log(F.prototype) // => objectF.prototype.sayHi = function () { console.log('hi!')} 构造函数的 prototype 对象默认都有一个 constructor 属性，指向 prototype 对象所在函数。 1console.log(F.prototype.constructor === F) // => true 通过构造函数得到的实例对象内部会包含一个指向构造函数的 prototype 对象的指针 __proto__。 12var instance = new F()console.log(instance.__proto__ === F.prototype) // => true __proto__ 是非标准属性。 实例对象可以直接访问原型对象成员。 1instance.sayHi() // => hi! 总结： 任何函数都具有一个 prototype 属性，该属性是一个对象 构造函数的 prototype 对象默认都有一个 constructor 属性，指向 prototype 对象所在函数 通过构造函数得到的实例对象内部会包含一个指向构造函数的 prototype 对象的指针 __proto__ 所有实例都直接或间接继承了原型对象的成员 属性成员的搜索原则：原型链了解了 构造函数-实例-原型对象 三者之间的关系后，接下来我们来解释一下为什么实例对象可以访问原型对象中的成员。 先在自己身上找，找到即返回 自己身上找不到，则沿着原型链向上查找，找到即返回 如果一直到原型链的末端还没有找到，则返回 undefined 实例对象读写原型对象成员读取： 先在自己身上找，找到即返回 自己身上找不到，则沿着原型链向上查找，找到即返回 如果一直到原型链的末端还没有找到，则返回 undefined 更简单的原型语法我们注意到，前面例子中每添加一个属性和方法就要敲一遍 Person.prototype 。为减少不必要的输入，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象： 1234567891011function Person (name, age) { this.name = name this.age = age}Person.prototype = { type: 'human', sayHello: function () { console.log('我叫' + this.name + '，我今年' + this.age + '岁了') }} 在该示例中，我们将 Person.prototype 重置到了一个新的对象。这样做的好处就是为 Person.prototype 添加成员简单了，但是也会带来一个问题，那就是原型对象丢失了 constructor 成员。 所以，我们为了保持 constructor 的指向正确，建议的写法是： 123456789101112function Person (name, age) { this.name = name this.age = age}Person.prototype = { constructor: Person, // => 手动将 constructor 指向正确的构造函数 type: 'human', sayHello: function () { console.log('我叫' + this.name + '，我今年' + this.age + '岁了') }} 原生对象的原型 所有函数都有 prototype 属性对象。 Object.prototype Function.prototype Array.prototype String.prototype Number.prototype Date.prototype … 练习：为数组对象和字符串对象扩展原型方法。 原型对象使用建议 私有成员（一般就是属性）放到构造函数中 共享成员（一般就是函数）放到原型对象中 如果重置了 prototype 记得修正 constructor 的指向 函数进阶函数的定义方式 函数声明 函数表达式 new Function 函数声明123function foo () {} 函数表达式123var foo = function () {} 函数声明与函数表达式的区别 函数声明必须有名字 函数声明会函数提升，在预解析阶段就已创建，声明前后都可以调用 函数表达式类似于变量赋值 函数表达式可以没有名字，例如匿名函数 函数表达式没有变量提升，在执行阶段创建，必须在表达式执行之后才可以调用 下面是一个根据条件定义函数的例子： 123456789if (true) { function f () { console.log(1) }} else { function f () { console.log(2) }} 以上代码执行结果在不同浏览器中结果不一致。 不过我们可以使用函数表达式解决上面的问题： 1234567891011var fif (true) { f = function () { console.log(1) }} else { f = function () { console.log(2) }} 函数的调用方式 普通函数 构造函数 对象方法 函数内 this 指向的不同场景函数的调用方式决定了 this 指向的不同： 调用方式 非严格模式 备注 普通函数调用 window 严格模式下是 undefined 构造函数调用 实例对象 原型方法中 this 也是实例对象 对象方法调用 该方法所属对象 紧挨着的对象 事件绑定方法 绑定事件对象 定时器函数 window 这就是对函数内部 this 指向的基本整理，写代码写多了自然而然就熟悉了。 函数也是对象 所有函数都是 Function 的实例 call、apply、bind那了解了函数 this 指向的不同场景之后，我们知道有些情况下我们为了使用某种特定环境的 this 引用，这时候时候我们就需要采用一些特殊手段来处理了，例如我们经常在定时器外部备份 this 引用，然后在定时器函数内部使用外部 this 的引用。然而实际上对于这种做法我们的 JavaScript 为我们专门提供了一些函数方法用来帮我们更优雅的处理函数内部 this 指向问题。这就是接下来我们要学习的 call、apply、bind 三个函数方法。 callcall() 方法调用一个函数, 其具有一个指定的 this 值和分别地提供的参数(参数的列表)。 注意：该方法的作用和 apply() 方法类似，只有一个区别，就是 call() 方法接受的是若干个参数的列表，而 apply() 方法接受的是一个包含多个参数的数组。 语法： 1fun.call(thisArg[, arg1[, arg2[, ...]]]) 参数： thisArg 在 fun 函数运行时指定的 this 值 如果指定了 null 或者 undefined 则内部 this 指向 window arg1, arg2, ... 指定的参数列表 applyapply() 方法调用一个函数, 其具有一个指定的 this 值，以及作为一个数组（或类似数组的对象）提供的参数。 注意：该方法的作用和 call() 方法类似，只有一个区别，就是 call() 方法接受的是若干个参数的列表，而 apply() 方法接受的是一个包含多个参数的数组。 语法： 1fun.apply(thisArg, [argsArray]) 参数： thisArg argsArray apply() 与 call() 非常相似，不同之处在于提供参数的方式。apply() 使用参数数组而不是一组参数列表。例如： 1fun.apply(this, ['eat', 'bananas']) bindbind() 函数会创建一个新函数（称为绑定函数），新函数与被调函数（绑定函数的目标函数）具有相同的函数体（在 ECMAScript 5 规范中内置的call属性）。当目标函数被调用时 this 值绑定到 bind() 的第一个参数，该参数不能被重写。 语法： 1fun.bind(thisArg[, arg1[, arg2[, ...]]]) 参数： thisArg 当绑定函数被调用时，该参数会作为原函数运行时的 this 指向。当使用new 操作符调用绑定函数时，该参数无效。 arg1, arg2, … 当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。 返回值： 返回由指定的this值和初始化参数改造的原函数拷贝。 小结 call 和 apply 特性一样 都是用来调用函数，而且是立即调用 但是可以在调用函数的同时，通过第一个参数指定函数内部 this 的指向 call 调用的时候，参数必须以参数列表的形式进行传递，也就是以逗号分隔的方式依次传递即可 apply 调用的时候，参数必须是一个数组，然后在执行的时候，会将数组内部的元素一个一个拿出来，与形参一一对应进行传递 如果第一个参数指定了 null 或者 undefined 则内部 this 指向 window bind 可以用来指定内部 this 的指向，然后生成一个改变了 this 指向的新的函数 它和 call、apply 最大的区别是：bind 不会调用 ​ 函数的其它成员 arguments 实参集合 caller 函数的调用者 length 形参的个数 name 函数的名称 12345678910111213function fn(x, y, z) { console.log(fn.length) // => 形参的个数 console.log(arguments) // 伪数组实参参数集合 console.log(arguments.callee === fn) // 函数本身 console.log(fn.caller) // 函数的调用者 console.log(fn.name) // => 函数的名字}function f() { fn(10, 20, 30)}f() 函数的静态成员和实例成员12345678910//一般在构造函数中,加载实例对象的上的属性/方法叫做实例成员function Person(name, age){ this.name = name; this.age = age; this.sayName = function(){} }//由于函数也是对象,直接给函数添加的属性/方法,叫做静态成员Person.type = 1;Person.go = function(){console.log('走')} 高阶函数 函数可以作为参数 函数可以作为返回值 作为参数12345678910function eat (callback) { setTimeout(function () { console.log('吃完了') callback() }, 1000)}eat(function () { console.log('去唱歌')}) 作为返回值1234567891011function genFun (type) { return function (obj) { return Object.prototype.toString.call(obj) === type }}var isArray = genFun('[object Array]')var isObject = genFun('[object Object]')console.log(isArray([])) // => trueconsole.log(isArray({})) // => true 函数闭包1234567891011121314151617function fn () { var count = 0 return { getCount: function () { console.log(count) }, setCount: function () { count++ } }}var fns = fn()fns.getCount() // => 0fns.setCount()fns.getCount() // => 1 作用域、作用域链、预解析 全局作用域 函数作用域 没有块级作用域 12345678910{ var foo = 'bar'}console.log(foo)if (true) { var a = 123}console.log(a) 作用域链示例代码： 123456789101112131415161718var a = 10function fn () { var b = 20 function fn1 () { var c = 30 console.log(a + b + c) } function fn2 () { var d = 40 console.log(c + d) } fn1() fn2()} 内层作用域可以访问外层作用域，反之不行 什么是闭包Closures (闭包)是使用被作用域封闭的变量，函数，闭包等执行的一个函数的作用域。通常我们用和其相应的函数来指代这些作用域。(可以访问独立数据的函数) 闭包是一个函数和函数所声明的词法环境的结合 闭包的思考题思考题 1： 1234567891011var name = \"The Window\";var object = { name: \"My Object\", getNameFunc: function () { return function () { return this.name; }; }};console.log(object.getNameFunc()()) 思考题 2： 1234567891011var name = \"The Window\"; var object = { name: \"My Object\", getNameFunc: function () { var that = this; return function () { return that.name; }; }};console.log(object.getNameFunc()()) #### 正则表达式 了解正则表达式基本语法 能够使用JavaScript的正则对象 正则表达式简介什么是正则表达式正则表达式：用于匹配规律规则的表达式，正则表达式最初是科学家对人类神经系统的工作原理的早期研究，现在在编程语言中有广泛的应用。正则表通常被用来检索、替换那些符合某个模式(规则)的文本。正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 正则表达式的作用 给定的字符串是否符合正则表达式的过滤逻辑(匹配) 可以通过正则表达式，从字符串中获取我们想要的特定部分(提取) 强大的字符串替换能力(替换) 正则表达式的特点 灵活性、逻辑性和功能性非常的强 可以迅速地用极简单的方式达到字符串的复杂控制 对于刚接触的人来说，比较晦涩难懂 正则表达式的测试 在线测试正则 工具中使用正则表达式 sublime/vscode/word 演示替换所有的数字 正则表达式的组成 普通字符 特殊字符(元字符)：正则表达式中有特殊意义的字符 示例演示： \\d 匹配数字 ab\\d 匹配 ab1、ab2 元字符串通过测试工具演示下面元字符的使用 常用元字符串 元字符 说明 \\d 匹配数字 \\D 匹配任意非数字的字符 \\w 匹配字母或数字或下划线 \\W 匹配任意不是字母，数字，下划线 \\s 匹配任意的空白符 \\S 匹配任意不是空白符的字符 . 匹配除换行符以外的任意单个字符 ^ 表示匹配行首的文本(以谁开始) $ 表示匹配行尾的文本(以谁结束) 限定符 限定符 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 其它1234567[] 字符串用中括号括起来，表示匹配其中的任一字符，相当于或的意思[^] 匹配除中括号以内的内容\\ 转义符| 或者，选择两者中的一个。注意|将左右两边分为两部分，而不管左右两边有多长多乱() 从两个直接量中选择一个，分组 eg：gr(a|e)y匹配gray和grey[\\u4e00-\\u9fa5] 匹配汉字 案例验证手机号： 1^\\d{11}$ 验证邮编： 1^\\d{6}$ 验证日期 2012-5-01 1^\\d{4}-\\d{1,2}-\\d{1,2}$ 验证邮箱 xxx@itcast.cn： 1^\\w+@\\w+\\.\\w+$ 验证IP地址 192.168.1.10 1^\\d{1,3}\\(.\\d{1,3}){3}$ JavaScript 中使用正则表达式创建正则对象方式1： 12var reg = new Regex('\\\\d', 'i');var reg = new Regex('\\\\d', 'gi'); 方式2： 12var reg = /\\d/i;var reg = /\\d/gi; 参数 标志 说明 i 忽略大小写 g 全局匹配 gi 全局匹配+忽略大小写 正则匹配1234// 匹配日期var dateStr = '2015-10-10';var reg = /^\\d{4}-\\d{1,2}-\\d{1,2}$/console.log(reg.test(dateStr)); 正则提取123456789101112131415161718192021222324252627// 1. 提取工资var str = \"张三：1000，李四：5000，王五：8000。\";var array = str.match(/\\d+/g);console.log(array);// 2. 提取email地址var str = \"123123@xx.com,fangfang@valuedopinions.cn 286669312@qq.com 2、emailenglish@emailenglish.englishtown.com 286669312@qq.com...\";var array = str.match(/\\w+@\\w+\\.\\w+(\\.\\w+)?/g);console.log(array);// 3. 分组提取 // 3. 提取日期中的年部分 2015-5-10var dateStr = '2016-1-5';// 正则表达式中的()作为分组来使用，获取分组匹配到的结果用Regex.$1 $2 $3....来获取var reg = /(\\d{4})-\\d{1,2}-\\d{1,2}/;if (reg.test(dateStr)) { console.log(RegExp.$1);}// 4. 提取邮件中的每一部分var reg = /(\\w+)@(\\w+)\\.(\\w+)(\\.\\w+)?/;var str = \"123123@xx.com\";if (reg.test(str)) { console.log(RegExp.$1); console.log(RegExp.$2); console.log(RegExp.$3);} 正则替换123456789// 1. 替换所有空白var str = \" 123AD asadf asadfasf adf \";str = str.replace(/\\s/g,\"xx\");console.log(str);// 2. 替换所有,|，var str = \"abc,efg,123，abc,123，a\";str = str.replace(/,|，/g, \".\");console.log(str); 案例：表单验证12345QQ号：邮箱：手机：生日：姓名： 12345678910111213141516171819202122232425262728293031323334353637383940//获取文本框var txtQQ = document.getElementById(\"txtQQ\");var txtEMail = document.getElementById(\"txtEMail\");var txtPhone = document.getElementById(\"txtPhone\");var txtBirthday = document.getElementById(\"txtBirthday\");var txtName = document.getElementById(\"txtName\");//txtQQ.onblur = function () { //获取当前文本框对应的span var span = this.nextElementSibling; var reg = /^\\d{5,12}$/; //判断验证是否成功 if(!reg.test(this.value) ){ //验证不成功 span.innerText = \"请输入正确的QQ号\"; span.style.color = \"red\"; }else{ //验证成功 span.innerText = \"\"; span.style.color = \"\"; }};//txtEMailtxtEMail.onblur = function () { //获取当前文本框对应的span var span = this.nextElementSibling; var reg = /^\\w+@\\w+\\.\\w+(\\.\\w+)?$/; //判断验证是否成功 if(!reg.test(this.value) ){ //验证不成功 span.innerText = \"请输入正确的EMail地址\"; span.style.color = \"red\"; }else{ //验证成功 span.innerText = \"\"; span.style.color = \"\"; }}; 表单验证部分，封装成函数： 12345678910111213141516171819var regBirthday = /^\\d{4}-\\d{1,2}-\\d{1,2}$/;addCheck(txtBirthday, regBirthday, \"请输入正确的出生日期\");//给文本框添加验证function addCheck(element, reg, tip) { element.onblur = function () { //获取当前文本框对应的span var span = this.nextElementSibling; //判断验证是否成功 if(!reg.test(this.value) ){ //验证不成功 span.innerText = tip; span.style.color = \"red\"; }else{ //验证成功 span.innerText = \"\"; span.style.color = \"\"; } };} 通过给元素增加自定义验证属性对表单进行验证： 1234567 QQ号： 邮箱： 手机： 生日： 姓名： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 所有的验证规则var rules = [ { name: 'qq', reg: /^\\d{5,12}$/, tip: \"请输入正确的QQ\" }, { name: 'email', reg: /^\\w+@\\w+\\.\\w+(\\.\\w+)?$/, tip: \"请输入正确的邮箱地址\" }, { name: 'phone', reg: /^\\d{11}$/, tip: \"请输入正确的手机号码\" }, { name: 'date', reg: /^\\d{4}-\\d{1,2}-\\d{1,2}$/, tip: \"请输入正确的出生日期\" }, { name: 'cn', reg: /^[\\u4e00-\\u9fa5]{2,4}$/, tip: \"请输入正确的姓名\" }];addCheck('frm');//给文本框添加验证function addCheck(formId) { var i = 0, len = 0, frm =document.getElementById(formId); len = frm.children.length; for (; i < len; i++) { var element = frm.children[i]; // 表单元素中有name属性的元素添加验证 if (element.name) { element.onblur = function () { // 使用dataset获取data-自定义属性的值 var ruleName = this.dataset.rule; var rule =getRuleByRuleName(rules, ruleName); var span = this.nextElementSibling; //判断验证是否成功 if(!rule.reg.test(this.value) ){ //验证不成功 span.innerText = rule.tip; span.style.color = \"red\"; }else{ //验证成功 span.innerText = \"\"; span.style.color = \"\"; } } } }}// 根据规则的名称获取规则对象function getRuleByRuleName(rules, ruleName) { var i = 0, len = rules.length; var rule = null; for (; i < len; i++) { if (rules[i].name == ruleName) { rule = rules[i]; break; } } return rule;} ##","categories":[{"name":"web前端","slug":"web前端","permalink":"https://guoweiyanggithub.github.io/categories/web前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://guoweiyanggithub.github.io/tags/javascript/"},{"name":"web前端","slug":"web前端","permalink":"https://guoweiyanggithub.github.io/tags/web前端/"},{"name":"js高级","slug":"js高级","permalink":"https://guoweiyanggithub.github.io/tags/js高级/"}]},{"title":"js基础-dom与bom","slug":"js基础-dom与bom","date":"2019-03-08T02:03:27.000Z","updated":"2019-03-14T03:13:18.318Z","comments":true,"path":"2019/03/08/js基础-dom与bom/","link":"","permalink":"https://guoweiyanggithub.github.io/2019/03/08/js基础-dom与bom/","excerpt":"","text":"Web APIWeb API介绍API的概念API（Application Programming Interface,应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。 任何开发语言都有自己的API API的特征输入和输出(I/O) var max = Math.max(1, 2, 3); API的使用方法(console.log(‘adf’)) Web API的概念浏览器提供的一套操作浏览器功能和页面元素的API(BOM和DOM) 此处的Web API特指浏览器提供的API(一组方法) 掌握常见浏览器提供的API的调用方式MDN-Web API ECMAScript - JavaScript的核心定义了JavaScript 的语法规范 JavaScript的核心，描述了语言的基本语法和数据类型，ECMAScript是一套标准，定义了一种语言的标准与具体实现无关 BOM - 浏览器对象模型一套操作浏览器功能的API 通过BOM可以操作浏览器窗口，比如：弹出框、控制浏览器跳转、获取分辨率等 DOM - 文档对象模型一套操作页面元素的API DOM可以把HTML看做是文档树，通过DOM提供的API可以对树上的节点进行操作 DOMDOM的概念文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标记语言的标准编程接口。它是一种与平台和语言无关的应用程序接口(API),它可以动态地访问程序和脚本，更新其内容、结构和www文档的风格(目前，HTML和XML文档是通过说明部分定义的)。文档可以进一步被处理，处理的结果可以加入到当前的页面。DOM是一种基于树的API文档，它要求在处理过程中整个文档都表示在存储器中。 文档：一个网页可以称为文档 节点：网页中的所有内容都是节点（标签、属性、文本、注释等） 元素：网页中的标签 属性：标签的属性 DOM经常进行的操作 获取元素 对元素进行操作(设置其属性或调用其方法) 动态创建元素 事件(什么时机做相应的操作) 获取页面元素 $为什么要获取页面元素例如：我们想要操作页面上的某部分(显示/隐藏，动画)，需要先获取到该部分对应的元素，才进行后续操作 根据id获取元素*1234var div = document.getElementById('main');console.log(div);// 获取到的数据类型 HTMLDivElement，对象都是有类型的 注意：由于id名具有唯一性，部分浏览器支持直接使用id名访问元素，但不是标准方式，不推荐使用。 根据标签名获取元素*12345var divs = document.getElementsByTagName('div');for (var i = 0; i < divs.length; i++) { var div = divs[i]; console.log(div);} 根据name获取元素12345var inputs = document.getElementsByName('hobby');for (var i = 0; i < inputs.length; i++) { var input = inputs[i]; console.log(input);} 根据类名获取元素12345var mains = document.getElementsByClassName('main');for (var i = 0; i < mains.length; i++) { var main = mains[i]; console.log(main);} 根据选择器获取元素12345678var text = document.querySelector('#text');console.log(text);var boxes = document.querySelectorAll('.box');for (var i = 0; i < boxes.length; i++) { var box = boxes[i]; console.log(box);} 总结 1234567document.getElementById()document/element.getElementsByTagName()document.getElementsByName() 兼容问题:不同的浏览器实现不同document/element.getElementsByClassName() 兼容问题: ie9+document/element.querySelector() 兼容问题: ie8+document/element.querySelectorAll() 兼容问题: ie8+ 事件事件：触发-响应机制 事件三要素 事件源:触发(被)事件的元素 事件名称: click 点击事件 事件处理程序:事件触发后要执行的代码(函数形式) 事件的基本使用1234var box = document.getElementById('box');box.onclick = function() { console.log('代码会在box被点击后执行'); }; 属性操作非表单元素的属性href、title、id、src、className 123456var link = document.getElementById('link');console.log(link.href);console.log(link.title);var pic = document.getElementById('pic');console.log(pic.src); innerHTML和innerText 12345var box = document.getElementById('box');box.innerHTML = '我是文本我会生成为标签';console.log(box.innerHTML);box.innerText = '我是文本我不会生成为标签';console.log(box.innerText); innerHTML和innerText的区别:前者可以识别标签,后者不可以 innerText的兼容性处理(早期的火狐浏览器不支持innerText,使用textContent替代) 表单元素属性 value 用于大部分表单元素的内容获取(option除外) type 可以获取input标签的类型(输入框或复选框等) disabled 禁用属性 checked 复选框选中属性 selected 下拉菜单选中属性 自定义属性操作 getAttribute() 获取标签行内属性 setAttribute() 设置标签行内属性 removeAttribute() 移除标签行内属性 与element.属性的区别: 上述三个方法用于获取任意的行内属性。 样式操作 使用style方式设置的样式显示在标签行内 1234var box = document.getElementById('box');box.style.width = '100px';box.style.height = '100px';box.style.backgroundColor = 'red'; 注意 通过样式属性设置宽高、位置的属性类型是字符串，需要加上px 类名操作 修改标签的className属性相当于直接修改标签的类名12var box = document.getElementById('box');box.className = 'show'; 创建元素的三种方式document.write()1document.write('新设置的内容标签也可以生成'); innerHTML12var box = document.getElementById('box');box.innerHTML = '新内容新标签'; document.createElement()12var div = document.createElement('div');document.body.appendChild(div); 性能问题 innerHTML方法由于会对字符串进行解析，需要避免在循环内多次使用。 可以借助字符串或数组的方式进行替换，再设置给innerHTML 优化后与document.createElement性能相近 节点操作节点属性 nodeType 节点的类型 1 元素节点 2 属性节点 3 文本节点 nodeName 节点的名称(标签名称) nodeValue 节点值 元素节点的nodeValue始终是null 节点层级12345678var box = document.getElementById('box');console.log(box.parentNode);console.log(box.childNodes);console.log(box.children);console.log(box.nextSibling);console.log(box.previousSibling);console.log(box.firstChild);console.log(box.lastChild); 注意 childNodes和children的区别，childNodes获取的是子节点，children获取的是子元素(在早期浏览器中会返回注释节点) nextSibling和previousSibling获取的是节点，获取元素对应的属性是nextElementSibling和previousElementSibling获取的是元素 nextElementSibling和previousElementSibling有兼容性问题，IE9以后才支持 总结 1234567891011节点操作，方法 appendChild() insertBefore() removeChild() replaceChild()节点层次，属性 parentNode childNodes children nextSibling/previousSibling firstChild/lastChild 事件详解注册/移除事件的三种方式123456789101112131415161718var box = document.getElementById('box');//第一种:box.onclick = function () { console.log('点击后执行');};box.onclick = null;//第二种:box.addEventListener('click', eventCode, false);box.removeEventListener('click', eventCode, false);//第三种:box.attachEvent('onclick', eventCode);box.detachEvent('onclick', eventCode);function eventCode() { console.log('点击后执行');} 兼容代码12345678910111213141516171819function addEventListener(element, type, fn) { if (element.addEventListener) { element.addEventListener(type, fn, false); } else if (element.attachEvent){ element.attachEvent('on' + type,fn); } else { element['on' + type] = fn; }}function removeEventListener(element, type, fn) { if (element.removeEventListener) { element.removeEventListener(type, fn, false); } else if (element.detachEvent) { element.detachEvent('on' + type, fn); } else { element['on' + type] = null; }} 事件的三个阶段 捕获阶段 当前目标阶段 冒泡阶段 事件对象.eventPhase属性 查看事件触发时所处的阶段 事件对象的属性和方法 event.type 获取事件类型 clientX/clientY 所有浏览器都支持，鼠标在可视窗口位置 pageX/pageY IE8以前不支持，鼠标在当前页面位置 event.target || event.srcElement 用于获取触发事件的元素 event.preventDefault() 取消默认行为 案例 跟着鼠标飞的天使 鼠标点哪图片飞到哪里 获取鼠标在div内的坐标 阻止事件传播的方式 标准方式 event.stopPropagation(); IE低版本 event.cancelBubble = true; 标准中已废弃 常用的鼠标和键盘事件 onmouseup 鼠标按键放开时触发 onmousedown 鼠标按键按下触发 onmousemove 鼠标移动触发 onkeyup 键盘按键按下触发 onkeydown 键盘按键抬起触发 BOMBOM的概念BOM(Browser Object Model) 是指浏览器对象模型，浏览器对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。BOM由多个对象组成，其中代表浏览器窗口的Window对象是BOM的顶层对象，其他对象都是该对象的子对象。 我们在浏览器中的一些操作都可以使用BOM的方式进行编程处理， 比如：刷新浏览器、后退、前进、在浏览器中输入URL等 BOM的顶级对象windowwindow是浏览器的顶级对象，当调用window下的属性和方法时，可以省略window注意：window下一个特殊的属性 window.name 对话框 alert() prompt() confirm() name 和top 的特殊性: name 和 top 是window 对象本身存在的属性 name 是字符串,给那么赋值为其他类型,也会转换成字符创 top 是只读的属性 页面加载事件 onload 1234window.onload = function () { // 当页面加载完成执行 // 当页面完全加载所有内容（包括图像、脚本文件、CSS 文件等）执行} onunload 123window.onunload = function () { // 当用户退出页面时执行} 定时器setTimeout()和clearTimeout()在指定的毫秒数到达之后执行指定的函数，只执行一次 1234567// 创建一个定时器，1000毫秒后执行，返回定时器的标示var timerId = setTimeout(function () { console.log('Hello World');}, 1000);// 取消定时器的执行clearTimeout(timerId); setInterval()和clearInterval()定时调用的函数，可以按照给定的时间(单位毫秒)周期调用函数 12345678// 创建一个定时器，每隔1秒调用一次var timerId = setInterval(function () { var date = new Date(); console.log(date.toLocaleTimeString());}, 1000);// 取消定时器的执行clearInterval(timerId); location对象location对象是window对象下的一个属性，使用的时候可以省略window对象 location可以获取或者设置浏览器地址栏的URL location有哪些成员？ 使用chrome的控制台查看 查MDN MDN 成员 assign()/reload()/replace() hash/host/hostname/search/href…… URL统一资源定位符 (Uniform Resource Locator, URL) URL的组成 1234567891011121314scheme://host:port/path?query#fragmenthttp://www.itheima.com:80/a/b/index.html?name=zs&age=18#bottomscheme:通信协议 常用的http,ftp,maito等host:主机 服务器(计算机)域名系统 (DNS) 主机名或 IP 地址。port:端口号 整数，可选，省略时使用方案的默认端口，如http的默认端口为80。path:路径 由零或多个'/'符号隔开的字符串，一般用来表示主机上的一个目录或文件地址。query:查询 可选，用于给动态网页传递参数，可有多个参数，用'&'符号隔开，每个参数的名和值用'='符号隔开。例如：name=zsfragment:信息片断 字符串，锚点. history对象 back() forward() go() navigator对象 userAgent 特效偏移量 offsetParent用于获取定位的父级元素 offsetParent和parentNode的区别? 123456var box = document.getElementById('box');console.log(box.offsetParent);console.log(box.offsetLeft);console.log(box.offsetTop);console.log(box.offsetWidth);console.log(box.offsetHeight); 客户区大小12345var box = document.getElementById('box');console.log(box.clientLeft);console.log(box.clientTop);console.log(box.clientWidth);console.log(box.clientHeight); 滚动偏移12345var box = document.getElementById('box');console.log(box.scrollLeft)console.log(box.scrollTop)console.log(box.scrollWidth)console.log(box.scrollHeight)","categories":[{"name":"web前端","slug":"web前端","permalink":"https://guoweiyanggithub.github.io/categories/web前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://guoweiyanggithub.github.io/tags/javascript/"},{"name":"web前端","slug":"web前端","permalink":"https://guoweiyanggithub.github.io/tags/web前端/"},{"name":"DOM与BOM","slug":"DOM与BOM","permalink":"https://guoweiyanggithub.github.io/tags/DOM与BOM/"}]},{"title":"js基础五","slug":"js基础五","date":"2019-03-08T02:00:44.000Z","updated":"2019-03-14T03:14:35.533Z","comments":true,"path":"2019/03/08/js基础五/","link":"","permalink":"https://guoweiyanggithub.github.io/2019/03/08/js基础五/","excerpt":"","text":"内置对象 JS内置对象就是指Javascript自带的一些对象，供开发者使用，这些对象提供了一些常用的的功能。 常见的内置对象有Math、String、Array、Date等 内置对象有很多，我们主要是记下这些内置对象的用法即可。但是同学们也不可能一下子记住这么多的方法，因此当同学们忘了某个方法该如何使用的时候，可以通过以下方式查看。 跳转到定义ctrl+左键 火狐开发者网站MDN W3School网站 离线文档 笔记 Math对象 Math对象中封装很多与数学相关的属性和方法。 属性PI Math.PI 最大值/最小值 12Math.max();Math.min(); 取整 123Math.ceil();//天花板，向上取整Math.floor();//地板，向下取整Math.round();//四舍五入，如果是.5，则取更大的那个数 随机数 1Math.random();//返回一个[0,1)之间的数，能取到0，取不到1 绝对值 1Math.abs();//求绝对值 次幂和平方 12Math.pow(num, power);//求num的power次方Math.sqrt(num);//对num开平方 Date对象 Date对象用来处理日期和时间 创建一个日期对象 123var date = new Date();//使用构造函数创建一个当前时间的对象var date = new Date(\"2017-03-22\");//创建一个指定时间的日期对象var date = new Date(\"2017-03-22 00:52:34\");//创建一个指定时间的日期对象 日期格式化(了解) 123456date.toString();//默认的日期格式date.toLocalString();//本地风格的日期格式（兼容性）date.toDateString();date.toLocalDateString();date.toTimeString();date.toLocalTimeString(); 获取日期的指定部分 12345678910111213141516getMilliseconds();//获取毫秒值getSeconds();//获取秒getMinutes();//获取分钟getHours();//获取小时getDay();//获取星期，0-6 0：星期天getDate();//获取日，即当月的第几天getMonth();//返回月份，注意从0开始计算，这个地方坑爹，0-11getFullYear();//返回4位的年份 如 2016getYear(); //将返回的实际年份减去1900年。例如：2016年返回116 //Coordinated Universal Time,协调世界时,又叫世界标准时间。可以理解为0度经线所在有时区。 getUTCYear(); //返回标准时间对应的年份 getUTCHour(); //返回标准时间对应的小时//思考：//封装一个函数，返回当前的时间，格式是：yyyy-MM-dd HH:mm:ss 时间戳 123var date = +new Date();//1970年01月01日00时00分00秒起至现在的总毫秒数 //思考 //如何统计一段代码的执行时间？ Array对象 数组对象在javascript中非常的常用 数组判断 12345678//语法：Array.isArray(obj)//作用：用来判断一个对象是否是一个数组var a = 100;var b = true;var c = [1,2,3,4,5,6];console.log(Array.isArray(a)); //falseconsole.log(Array.isArray(b)); //falseconsole.log(Array.isArray(c)); //true 数组转换 123456//语法：array.join(separator)//作用：将数组的值拼接成字符串var arr = [1,2,3,4,5];arr.join();//不传参数，默认按【,】进行拼接arr.join(\"-\");//按【-】进行拼接 数组的增删操作 1234567891011121314array.push();//从后面添加元素，返回新数组的lengtharray.pop();//从数组的后面删除元素，返回删除的那个元素array.unshift();//从数组的前面的添加元素，返回新数组的长度array.shift();//从数组的最前面删除元素，返回删除的那个元素//练习1var arr = [\"刘备\"];//添加数据后变成：[\"赵云\",\"马超\",\"刘备\",\"关羽\",\"张飞\"]//删除数据后变成：[\"关羽\",\"张飞\"]//练习2var arr = [\"赵云\",\"马超\",\"刘备\",\"关羽\",\"张飞\"];//把数组的最后一个元素变成数组的第0个元素//把数组的第0个元素变成数组的最后一个元素 数组的翻转与排序 12345678array.reverse();//翻转数组array.sort();//数组的排序，默认按照字母顺序排序//sort方法可以传递一个函数作为参数，这个参数用来控制数组如何进行排序arr.sort(function(a, b){ //如果返回值>0,则交换位置 return a - b;}); 1234//练习：//将[3, 6, 1, 5, 10, 2,11]从小到大排列//将字符串数组按照字符长度从小到大排列//将学生数组按照年龄从小到大排列 数组的拼接与截取 12345678910//concat：数组合并，不会影响原来的数组，会返回一个新数组。 var newArray = array.concat(array2); //slice:数组切分，复制数组的一部分到一个新数组，并返回这个数组 //原来的数组不受影响，包含begin，不包含end var newArray = array.slice(begin, end); //splice:数组拼接，以新元素来替换旧元素，以此来修改数组的内容，常用语删除数组的某些项 //start:开始位置 deleteCount:删除的个数 items:替换的内容 array.splice(start, deleteCount, [items]); 1234//练习：var arr = [4, 6, 7, 8, 3, 46, 8];//从数组中截取一个新的数组[6,7,8,3],返回新的数组//删除[6,7,8,3]和替换成[1,1,1] 数组查找元素 12345//indexOf方法用来查找数组中某个元素第一次出现的位置，如果找不到，返回-1 array.indexOf(search, [fromIndex]); //astIndexOf()从后面开始查找数组中元素出现位置,如果找不到，返回-1 array.lastIndexOf(search, [fromIndex]); 操作数组里的元素 12345678910111213141516171819202122232425262728293031323334353637383940//filter方法返回一个由符合函数要求的元素组成的新数组var arr = [12,34,56,89,78,23,45,19];//调用数组的filter方法，添加过滤方法，符合规则的元素会被存放到新数组里//element:表示数组里的元素;index:表示索引值;array:表示调用filter方法的数组。var newArr = arr.filter(function(element,index,array){ return element > 30;});console.log(arr); //filter方法不会改变原数组里的数据[12,34,56,89,78,23,45,19];console.log(newArr); //新数组里保存符合要求的元素[34, 56, 89, 78, 45]//map方法让数组中的每个元素都调用一次提供的函数，将调用的后的结果存放到一个新数组里并返回。newArr = arr.map(function(element,index,array){ //在数组里的每一个元素的最后面都添加一个字符串\"0\" return element + \"0\";});console.log(newArr); //[\"120\", \"340\", \"560\", \"890\", \"780\", \"230\", \"450\", \"190\"]console.log(arr); //map方法不会改变原数组里的数据 [12,34,56,89,78,23,45,19]//forEach() 方法对数组的每个元素执行一次提供的函数,且这个函数没有返回值var result = arr.forEach(function (element, index, array) { //数组里的每一个元素都会被打印 console.log(\"第\" + index + \"个元素是\" + element);});console.log(result); //函数没有返回值////some() 方法测试数组中的某些元素是否通过由提供的函数实现的测试.result = arr.some(function (element,index,array) { //数组里否有一些元素大于50.只要有一个元素大于，就返回true console.log(element);//12,34,56 return element > 50;});console.log(result); //true//every() 方法测试数组的所有元素是否都通过了指定函数的测试。result = arr.every(function (element,index,array) { //数组里是否每一个元素都大于50.只有在所有的数都大于50时，才返回true console.log(element); //12.第0个数字就已经小于50了，就没有再比较的意义了 return element > 50;});console.log(result); //false 清空数组 123//1．array.splice(0,array.leng);//删除数组中所有的元素//2．array.length = 0;//直接修改数组的长度//3．array = [];//将数组赋值为一个空数组，推荐 数组综合练习 123456var arr = [\"c\", \"a\", \"z\", \"a\", \"x\", \"a\", \"a\", \"z\", \"c\", \"x\", \"a\", \"x\"]//1. 找到数组中第一个a出现的位置//2. 找到数组中最后一个a出现的位置//3. 找到数组中每一个a出现的位置//4. 数组去重，返回一个新数组//5. 获取数组中每个元素出现的次数 String对象 字符串可以看成是一个字符数组。因此字符串也有长度，也可以进行遍历。String对象很多方法的名字和和Array的一样。可以少记很多的单词。 查找指定字符串 12//indexOf:获取某个字符串第一次出现的位置，如果没有，返回-1//lastIndexOf:从后面开始查找第一次出现的位置。如果没有，返回-1 去除空白 1trim();//去除字符串两边的空格，内部空格不会去除 大小写转换 12toUpperCase：全部转换成大写字母toLowerCase：全部转换成小写字母 字符串拼接与截取 1234567//字符串拼接//可以用concat，用法与数组一样，但是字符串拼串我们一般都用+//字符串截取的方法有很多，记得越多，越混乱，因此就记好用的就行//slice ：从start开始，end结束，并且取不到end。//subString ：从start开始，end结束，并且取不到end// substr ： ：从start开始，截取length个字符。(推荐) 字符串切割 1234//split:将字符串分割成数组（很常用）//功能和数组的join正好相反。var str = \"张三,李四,王五\";var arr = str.split(\",\"); 字符串替换 12replace(searchValue, replaceValue)//参数：searchValue:需要替换的值 replaceValue:用来替换的值 练习 12345//1. 截取字符串\"我爱中华人民共和国\"，中的\"中华\"//2. \"abcoefoxyozzopp\"查找字符串中所有o出现的位置//3. 把字符串中所有的o替换成!//4. 把一个字符串中所有的空格全部去掉//5. 统计一个字符串中每个字符出现的次数 基本包装类型 简单数据类型是没有方法的。为了方便操作基本数据类型，JavaScript还提供了三个特殊的引用类型：String/Number/Boolean。 基本包装类型：把基本类型包装成复杂类型。 123456var str = “abc”;var result = str.indexOf(“a”);//发生了三件事情1. 把简单类型转换成复杂类型：var s = new String(str);2. 调用包装类型的indexOf方法：var result = s.indexOf(“a”);3. 销毁刚刚创建的复杂类型（过河拆桥、卸磨杀驴）","categories":[{"name":"web前端","slug":"web前端","permalink":"https://guoweiyanggithub.github.io/categories/web前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://guoweiyanggithub.github.io/tags/javascript/"},{"name":"web前端","slug":"web前端","permalink":"https://guoweiyanggithub.github.io/tags/web前端/"},{"name":"内置对象","slug":"内置对象","permalink":"https://guoweiyanggithub.github.io/tags/内置对象/"}]},{"title":"js基础四","slug":"js基础四","date":"2019-03-08T01:59:34.000Z","updated":"2019-03-14T03:15:00.341Z","comments":true,"path":"2019/03/08/js基础四/","link":"","permalink":"https://guoweiyanggithub.github.io/2019/03/08/js基础四/","excerpt":"","text":"1.对象 学习目标：1.会创建一个对象2.会定义一个构造函数3.会操作一个对象 1.1.对象的基本概念1.1.1.为什么要有对象？ 在JavaScript中，对象跟数组、函数一样，都是一种复杂的数据类型，也叫引用数据类型。是一系列相关的属性的集合，可以很方便的对变量和函数进行管理。 面向对象编程（Object Oritented Programming，简称OOP）是非常重要的软件编程思想。 1.1.2.什么是对象 现在生活中：万物皆对象，对象是一个具体的事物，一个具体的事物就会有行为和特征。 编程语言：在内存上一段有意义的区域被称为对象，它也可以具有相关特征（属性），执行具体的行为（方法）。 思考： 1234567891. 女友对象 //特征：名字、性别、身高、体重、血型、星座、生日 //行为：吃饭、睡觉、拍电影、唱歌、发微博2. 学生对象 //特征：名字、性别、身高、体重、分数 //行为：吃饭、睡觉、学习、敲代码3. 英雄对象 //特征：名字、性别、金钱、等级、技能 //行为：移动、攻击、防御 1.2.创建对象1.2.1.通过构造函数创建123456var hero = new Object(); //创建一个空的对象hero.name = \"奥特曼\";hero.skill = \"打怪兽\";hero.attack = function(){ console.log(\"奥特曼发出光波打败了小怪兽\");} 注意事项： 1.this一定要出现在方法中才有意义，不在方法中的this没有意义。 2.在方法中出现的this，指的是当前对象，即调用这个方法的对象 1.2.2.对象字面量12345678var person = { name : \"迪伽\", age : 2000, sex : \"男\"; fight : function(){ console.log(\"打怪兽\"); }}; 1.3.批量创建对象1.3.1.使用普通函数创建对象优点：可以同时创建多个对象 缺点：创建出来的没有具体的类型，都是Object类型的对象。 1.3.2.查看一个对象的类型123typeof 只能判断基本数据类型instanceof 判断对象的数据 类型constructor.name 也可以获取到对象的具体类型 1.3.3.构造函数 构造函数，是一种特殊的函数，主要用来在创建对象时就给对象初始化，即为对象的成员变量赋值，总与关键字new一起使用在创建对象的语句中。 关键字new所做的操作: 12341.new会创建一个新的空对象2.new会让this指向这个对象3.调用构造函数4.new会返回这个创建好的对象 练习： 1231.学生对象的构造函数2.老师对象的构造函数3.英雄对象的构造函数 1.4.操作对象的属性1.4.1.点语法12345678910111213//获取对象属性//对象.属性 获取对象的某个属性//1.如果这个对象有这个属性，就返回所对应的属性值//2.如果这个对象没有这个属性，则返回undefinedvar name = teacher.name; //获取到老师对象的姓名属性teacher.name = \"苍老师\"; //将老师对象的姓名设置成为苍老师//设置对象属性//对象.属性 = 值//1.如果对象有这个属性，修改这个属性的值//2.如果对象没有这个属性，则给这个对象添加一个新属性var name = teacher[\"name\"]; //获取到老师对象的姓名属性teacher[\"name\"] = \"苍老师\"; //将老师对象的姓名设置成为苍老师 1.4.2.[ ]语法也叫关联数组方式，说白了就是把对象当作数组来看待。 12345//获取对象属性值//对象[\"下标\"] 把对象的属性当成是数组里的元素//设置对象属性//对象[\"下标\"] = 值 注意：如果使用一个变量来获取对象里的属性时，必须要使用[]语法。 12345678function Student(name,age){ this.name = name; this.age = age;}var stu = new Student(\"张三\",18);var tmp = \"name\";var name = stu.tmp; //undefined,在stu对象里找tmp属性name = stu[tmp]; //张三，这里的tmp是一个变量，它指的是\"name\"字符串 1.4.3.遍历对象 使用for..in循环可以遍历一个对象里的数据 1234var obj = {\"name\":\"张三\",\"age\":18,\"sex\":\"男\"};for(var x in obj){ console.log(obj[x]);} 1.5.基本数据类型与引用数据类型 基本数据类型：也叫简单数据类型，原始数据类型或者值类型。在存储时，变量存的就是值本身。 引用数据类型：也叫复杂数据类型。在存储时，变量中存储的仅仅是地址（引用）。 练习1： 12345678910111213141516171819202122232425262728293031//1. var num1 = 10; var num2 = num1; num1 = 20; console.log(num1); console.log(num2); //2. var num = 50; function fn1(num) { num = 60; console.log(num); } fn1(num); console.log(num); //3. var num1 = 55; var num2 = 66; function fn2(num,num1) { num = 100; num1 = 100; num2 = 100; console.log(num); console.log(num1); console.log(num2); } fn2(num1,num2); console.log(num1); console.log(num2); console.log(num); 练习2: 1234567891011121314151617181920212223//1.function Person(name, age) { this.name = name; this.age = age; } var p1 = new Person(\"zs\", 18); var p2 = p1; p2.name = \"ls\"; console.log(p1.name); console.log(p2.name); //2. function Person(name, age) { this.name = name; this.age = age; } function f1(p) { p.name = \"ls\"; console.log(p.name); } var p1 = new Person(\"zs\", 18); console.log(p1.name); f1(p1); console.log(p1.name); 练习3: 1234567891011121314151617181920212223242526272829303132333435//1.function f1(a, b) { a = a + 1; b = b + 1; console.log(\"a = \" + a); console.log(\"b = \" + b); } var x = 5; var y = 6; f1(x, y); console.log(\"x = \" + x); console.log(\"y = \" + y); //2. function Person(name, age) { this.name = name; this.age = age; } function f2(p) { p = new Person(\"ls\", 50); p.name = \"ww\"; console.log(p.name); } var p2 = new Person(\"zs\", 18); f2(p2); console.log(p2.name); //3. function f3(arr) { arr[0] = 100; } var array = [1, 2, 3]; f3(array); console.log(array); //4.冒泡排序的函数中，是否可以不返回数组？ json对象 JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，采用完全独立于语言的文本格式，是理想的数据交换格式。同时，JSON是 JavaScript 原生格式，这意味着在 JavaScript 中处理 JSON数据跟处理对象是一样的。 JSON的属性必须用双引号包裹，而对于JS对象的属性名来说，括号可以省略。 123456789101112131415//对于js对象来说，属性名的双引号是可以省略的。var obj = { name:\"zs\", age:18, sex:\"男\"}//json对象的属性名必须使用双引号括起来var obj = { \"name\":\"zs\", \"age\":18, \"sex\":\"男\"}//在js中，其实就可以把json当成javascript的对象，因此操作是一样。","categories":[{"name":"web前端","slug":"web前端","permalink":"https://guoweiyanggithub.github.io/categories/web前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://guoweiyanggithub.github.io/tags/javascript/"},{"name":"web前端","slug":"web前端","permalink":"https://guoweiyanggithub.github.io/tags/web前端/"},{"name":"对象","slug":"对象","permalink":"https://guoweiyanggithub.github.io/tags/对象/"}]},{"title":"js基础三","slug":"js基础三","date":"2019-03-08T01:57:25.000Z","updated":"2019-03-14T03:13:52.953Z","comments":true,"path":"2019/03/08/js基础三/","link":"","permalink":"https://guoweiyanggithub.github.io/2019/03/08/js基础三/","excerpt":"","text":"1.函数 学习目标：掌握函数的基本用法，会使用函数解决一些问题。 1.1.函数的基础知识1.1.1.为什么要使用函数 在写代码的时候，有一些常用的代码需要书写多次，如果直接复制粘贴的话，会造成大量的冗余代码，为了提高代码的重用率，提高编码效率，我们需要使用函数。函数可以用来封装一段重复的代码，只需要声明一次，就可以被多次调用。 冗余代码缺点： 1.代码重复，可阅读性差。 2.不易维护。一旦逻辑发生改变，所有的地方也都要修改。 1.1.2.函数的声明与调用函数的声明：声明函数需要用到function关键字。 123function 函数名(){ //函数体} 特点： 121.函数在声明时不会执行，只有被调用时才会被执行。2.函数一般用来做一件事，在对函数进行命名时一定要注意，做到顾名思义。 函数的调用： 1函数名(); 示例代码： 123456//声明一个函数function sayHi(){ alert(\"吃了没\");}//调用函数sayHi(); 练习: 1231.封装一个打招呼的函数2.封装一个函数，计算两个数的和3.封装一个函数，计算1~100之间所有数的和 1.1.3.函数的参数 1.形式参数：在定义函数名和函数体的时候使用的参数，目的是用来接收调用该函数时传入的值。这个参数是一个不存在的变量，仅仅只是为了占用位置，所以我们可以称它为形式参数，简称形参。 2.实际参数：在调用有参函数时，函数名后面括号中的参数被称为实际参数，实参可以是常量、变量或者表达式。 语法： 123456//有参函数在声明时，需要在函数名后的括号里写上形参function 函数名(形参1,形参2,形参3...){ //函数体}//调用有参函数,在函数名后面的括号里直接传入实际参数函数名(实参1,实参2,实参3...); 练习： 1231.计算1~n的数字之和2.计算两个数的和3.计算m~n之间数字之和 1.1.4.函数的返回值 很多情况下，调用者在函数执行完成以后，需要拿到函数执行的结果（比如，拿到两个数的和，拿到两个数的较大数等），这个返回的结果就叫做返回值。 返回值语法：使用return关键字标识函数的返回值。 12345function 函数名(形参1,形参2,形参3...) { //函数体 return 返回值; //return关键字用来标识函数的返回值}var result = 函数名(形参1,形参2,形参3...); //调用者定义一个变量，用来保存函数的返回值。 练习: 1231.计算1~n之间所有数的和，并返回结果。2.计算两个数的和，并返回结果3.计算m~n之间所有数的和，并返回结果。 1.1.5.函数三要素函数的三要素指的是：函数名、参数以及返回值。 文档注释：文档注释/ * /通常用在函数的声明中，用来解释这个函数的作用。（包括函数名，参数以及返回值的作用） 声明函数时，使用文档注释对函数进行说明，是一种良好的开发习惯 123456789 /** * 求圆的面积 * @param r {number} 圆的半径 * @returns {number} 圆的面积 */function getArea(r){ return Math.PI*r*r;}getArea(3); 练习： 12345671.根据半径计算圆的面积2.根据半径计算圆的周长3.求两个数中的较大数。4.求一个数组中的最大数。5.求一个数组中的最小数。6.翻转一个数组，返回一个新的数组。7.给一个数组进行倒序排序。 1.2.函数的高级知识1.2.1.函数调用 在函数内部是可以调用其它函数的 1234567891011function fn1(){ console.log(\"fn1开始\"); fn2(); //在函数fn1里调用了fn2函数 console.log(\"fn1结束\");}function fn2(){ console.log(\"fn2的代码\"); console.log(\"fn2的代码\"); console.log(\"fn2的代码\");}fn1(); 断点调试： 12341.F8:跳转到下一个断点2.F10:单步运行（不会跳入到函数里）3.F11:单步调试（跳入到函数里）4.Shift+F11:跳出函数调用 练习： 1231.求阶乘2.求阶乘的和3.求任意三个数的最大值。 1.2.2.函数参数与返回值详解函数的参数详解： 1.在JavaScript中，没有函数重载，只有覆盖。如果定义了两个同名函数，后面的函数会覆盖掉前面的函数。 2.在JavaScript中，实参的个数可以和形参的个数不一致。 如果实参的个数大于形参的个数，多余的实参会被舍弃。 如果实参的个数小于形参的个数，不足的实参使用undefined替代。 函数返回值详解： 1231.return 语句作为函数的返回，它后面的语句不会执行。2.函数也可以没有return语句。如果一个函数没有明确的返回值，那么这个函数的返回值是undefined.3.函数也可以直接return，而不给返回值，相当于return undefined.作用是用来结束函数的调用。 练习: 121.比较两个数据大小，返回更大的那个数。2.求数组中的最大值和最大值所在的位置，并且返回。 1.2.3.函数的作用域全局变量：在最外层声明的变量就是全局变量，全局变量在任何地方都能够被访问。 局部变量：在函数中声明的变量就是局部变量，局部变量只能在当前函数内能够被访问。 隐式全局变量：没有使用var声明的变量也是全局变量。 作用域：变量可以发挥作用的区域。 全局作用域：在script标签内，函数外定义的作用域就是全局作用域。在全局作用域中定义的变量是全局变量。 函数作用域：在函数中的区域叫做函数区域，在函数作用域中定义的变量就是局部变量，只能在当前函数中访问。 在函数中，只有全局作用域和函数作用域。在if、while、for等语句中定义的变量都是全局变量。 1.2.4.预解析 JS解析器在执行JS代码的时候，分为两个过程：预解析过程和代码执行过程。 预解析过程： 1.把变量的声明提升到当前作用域的最前面，只会提升声明，不会提升赋值。 2.把函数的声明提升到当前作用域的最前面，只会提升声明，不会提升调用。 3.先提升var,再提升function 思考： 123456console.log(a);function a(){ console.log(\"aaaaa\");}var a = 1;console.log(a); 面试题： 12345678910111213141516171819202122232425var num = 10;fn1();function fn1(){ console.log(num); var num = 20;}var a = 18;fn2();function fn2(){ var b = 9; console.log(a); console.log(b);}fn3();console.log(c);console.log(b);console.log(a);function fn3(){ a = b = c = 9; console.log(a); console.log(b); console.log(c);} 1.2.5.声明函数的两种方式函数声明（命名函数） 123function 函数名(){ //函数体} 函数表达式(匿名函数) 123var 函数名 = function(){ //函数体} 这两种函数的区别： 1.命名函数可以在声明之前调用，因为预解析时，会先把函数的声明给解析出来。 2.匿名函数的调用必须要放在声明之后，因为预解析时，只会声明变量，不会给变量赋值！（DOM注册事件） 1.2.6.匿名函数 匿名函数：没有名字的函数 匿名函数的使用: 1234567891.将匿名函数赋值给一个变量，通过变量名来调用函数。var test = function(){ //将匿名函数赋值给一个变量 console.log(\"Hello\");}test(); //通过变量名来调用函数2.匿名自调用函数。(function(){ console.log(\"Hi\");})(); 自执行函数的作用：防止全局变量污染。","categories":[{"name":"web前端","slug":"web前端","permalink":"https://guoweiyanggithub.github.io/categories/web前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://guoweiyanggithub.github.io/tags/javascript/"},{"name":"web前端","slug":"web前端","permalink":"https://guoweiyanggithub.github.io/tags/web前端/"},{"name":"函数与数组","slug":"函数与数组","permalink":"https://guoweiyanggithub.github.io/tags/函数与数组/"}]},{"title":"js基础二","slug":"js基础二","date":"2019-03-08T01:53:35.000Z","updated":"2019-03-14T03:14:16.245Z","comments":true,"path":"2019/03/08/js基础二/","link":"","permalink":"https://guoweiyanggithub.github.io/2019/03/08/js基础二/","excerpt":"","text":"1.选择语句1.1.if..else12345678//语法if(condition) { statement1 } else if (condition) { statement2 } else { statement3} 思考： 1231. 是否年满18岁2. 素质教育（把分数变成ABCDE）90-1003. 判断星期几 1.2.switch..case123456789101112//语法switch (expression) { case value: statement break; // break 关键字会导致代码执行流跳出 switch 语句 case value: statement break; default: statement} 思考： 1234567891011var a = \"10\"; switch (a) { case 10: console.log(\"10\"); case 20: console.log(\"20\"); case 30: console.log(\"30\"); default : console.log(\"haha\"); } 思考2： 1今天星期几 1.3.三元运算符12表达式1 ? 表达式2 : 表达式3var sex = sex == 1 ? '男':'女'; 思考： 1从两个数中找最大值 2.循环语句 在JavaScript中，循环语句有三种，while、do while和for循环。 2.1. while循环基本语法： 123456//当满足循环条件时，执行循环体里的代码//每执行完一次循环体的代码以后，再判断一下循环条件//如果循环不成立时，结束循环while(循环条件){ //循环体} 示例代码： 123456789//计算1~100所有整数之和var i = 0; //初始化变量，用来表示循环了多少次var sum = 0; //初始化变量，用来记录和//while语句的判断条件是i点击行号添加断点 调试中的相关技巧： 123Watch:监视。通过Watch可以查看变量的值，非常实用。F10:单步运程，程序执行到下一行代码。F8:直接运行到下一个断点。如果程序中没有其它断点，程序就直接运行结束 tips： 不要随便监视表达式，如果监视了表达式，表达式会被执行 3.数组 所谓数组，就是将多个元素（通常是同一类型的数据）按照一定的顺序放到一个集合中，这个集合我们就称它为数组。 练习： 123为什么要使用数组？1.一个变量同时只能用来存储一个值，当我们需要存储多个值，如全班每个人的成绩时，就必须要用到数组了。2.使用数组把同一类型的数据放到一个集合里，便于管理，同时操作起来也比较方便。 3.1.创建数组 数组是一个有长度且按照一定顺序排列的列表。在JavaScript里，数组的长度可以动态调整。 通过构造函数创建数组： 123var arr1 = new Array(); //创建了一个空的数组，这个数组里没有数据var arr2 = new Array(10); //创建了一个空的数组，但是指定了这个数组的长度是10var arr3 = new Array(10,13,14); //创建了一个数组，并且在这个数组里放入了三个数字10,13,14 通过字面量来直接创建数组 123var arr1 = []; //创建了一个空的数组var arr2 = [12]; //创建了一个数组，并在这个数组里放入了一个数字12var arr3 = [\"ab\",\"cd\",\"ef\"]; //创建了一个数组，并在这个数组里放入了三个字符串，注意使用逗号分隔 3.2.数组的长度与下标数组的长度：和字符串一样，数组也有一个length属性，指数组中存储的数据的个数。 12var arr = [\"123\",\"Hello\",345,true];arr.length; //数组的长度是4 数组的下标：数组是有序的，数组里的每一个元素都有对应的下标，我们可以通过下标很方便的拿到数组里的数据。注意：数组里的下标是从0开始的。 123var arr = [\"hello\",1234,true,4567,\"world\"];arr[3]; //取出的结果是4567arr[10]; //下标超出了数组的长度，返回值是undefined 3.3.数组的取值与赋值数组的取值：可以通过数组的下标，很方便的取出数组里对应位置上的值。 12var arr = [12,34,23,78,3,1,9];arr[3]; //将数组里的第3个元素78取出 数组的改值：通过数组的下标，也可以很方便的修改数组里对应位置上的值。 123var arr = [34,23,5,8,120];arr[2] = \"Hello\"; //将数组里第2个元素数字5改成了字符串\"Hello\"arr[8] = \"World\"; //在数组的第8个位置上插入了一个字符串\"World\" 练习： 1231.将1~100以内所有的数都放到数组里2.将1~100以内所有的奇数放到数组里。3.将1~100以内能被3整除的数放到数组里。 3.4.数组的遍历 遍历：将数组里的每一个元素都访问一次，就叫遍历一次数组。 数组遍历的基本语法: 123for(var i = 0; i < arr.length; i ++) { //可以操作数组里的每一个元素} 练习1： 12345var arr = [234,12,86,59,30,28,49,71];1.求数组中所有数据之和以及平均数。2.求数组里的最大数。3.求数组里最大值和最小值所在的位置4.求数组里的最大最小值以及它们所在的位置。 练习2： 12345var arr = [\"abc\",\"def\",\"Hello\",\"Hi\",\"World\"];1.将字符串数组用|或其它符号分割2.有一个字符串数组，求字符串数组中每项的长度，并把长度存入到一个新的数组里。3.将数组中值为0的项去掉，将不为0的值存入一个新的数组4.让一个数组倒序保存到另一个数组里 3.5.冒泡排序使用冒泡排序将一个数组里的数据升序或降序进行排列。","categories":[{"name":"web前端","slug":"web前端","permalink":"https://guoweiyanggithub.github.io/categories/web前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://guoweiyanggithub.github.io/tags/javascript/"},{"name":"web前端","slug":"web前端","permalink":"https://guoweiyanggithub.github.io/tags/web前端/"},{"name":"循环与运算符","slug":"循环与运算符","permalink":"https://guoweiyanggithub.github.io/tags/循环与运算符/"}]},{"title":"js基础1","slug":"js基础一","date":"2019-03-07T06:13:03.000Z","updated":"2019-03-14T03:13:40.306Z","comments":true,"path":"2019/03/07/js基础一/","link":"","permalink":"https://guoweiyanggithub.github.io/2019/03/07/js基础一/","excerpt":"","text":"什么是JS语言 javascript是一种运行在客户端 的脚本语言 客户端：即接受服务的一端，与服务端相对应，在前端开发中，通常客户端指的就是浏览器。 脚本语言：也叫解释型语言，特点是**执行一行，解释一行，如果发现报错，代码就停止执行* 。 javascript的三个组成部分：ECMAScript、BOM、DOM ECMAScript：定义了javascript的语法规范。 BOM：一套操作浏览器功能的API。 DOM：一套操作页面元素的API。 script标签 书写Javascript代码有两种方式，第一种是直接在script标签中书写，第二种是将代码写在js文件中，通过script进行引入。 直接在script中书写javascript代码： 123 alert(\"今天天气真好呀\"); 通过script标签引入一个JS文件，需要指定src属性 1 tips：如果script标签指定了src属性，说明是想要引入一个js文件，这个时候不能继续在script标签中写JS代码，即便写了，也不会执行。 123 alert(\"Hello World\"); //这段代码不会执行 script标签的书写位置，原则上来说，可以在页面中的任意位置书写script标签。 写在head标签中，style标签之后。 写在body结束标签的前面。 1234 写在html结束标签的后面，即页面的最后面。 1234 输入输出语句 在实际开发，基本不能使用3、4、5,因为用户体验不好。 console.log 控制台输出日志 document.write 往页面中写入内容 alert 弹框警告 confirm 确认框 prompt 输入框 注释 不被程序执行的代码。用于程序员标记代码，在后期的修改，以及他人的学习时有所帮助，在JS中，分为单行注释、多行注释以及文档注释 12345678910111213141516//这是单行注释，只能注释一行/* 这是多行注释，不能嵌套*///文档注释在JS中通常用于对函数进行说明/*** 计算圆的面积* @param r{number} 圆的半径* @returns {number} 根据圆的半径计算出来的面积*/function getArea(r) { return Math.PI * r * r;} 注释的作用： 1. 模块划分，方便代码查找和维护 2. 用于解释复杂代码的逻辑，方便维护和后期开发。 要求：写代码的时候必须要写注释，但是需要注意注释的合理性。 【永无bug.js】 变量 变量，可以变化的量，变量是在计算机中存储数据的一个标识符。可以把变量看成存储数据的容器。 变量与字面量： 字面量：10、20、“abc”、true这种从字面上就能看出来类型和值的量叫做字面量。 变量：可以变化的量。 变量的声明与赋值123451.变量可以同时声明并赋值。2.先声明后赋值3.不声明，直接赋值4.既不声明，也不赋值5.同时声明多个变量 【测试1.html】 变量的命名规则与规范12345678命名规则（必须遵守）：1.由字母、数字、下划线、$符号组成，开头不能是数字。2.不能使用关键字和保留字3.严格区分大小写命名规范（建议遵守）：1. 命名要有意义2. 遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。 【测试2.html】 变量练习121. 交换两个变量的值（掌握）2. 不使用临时变量，交换两个数值变量的值（了解） tips:javascript是一种弱类型语言，不管声明什么类型的变量，都是用var，并且变量的类型是可以变化的。 12var age = 90;age = \"张三\"; 数据类型 基本数据类型包括了：number、string、boolean、undefined、null 如何查看数据类型使用typeof关键字查看数据类型 12typeof name;typeof(name); Number类型进制123451. 十进制，我们平时使用的就是十进制，进行运算时，八进制和十六进制的值最终都会转换成十进制。2. 八进制，0开头的数值，数值序列：0-73. 十六进制，0x开头的数值，数值序列：0-9A-F进制了解即可，基本都是使用十进制，稍微了解一下进制之间的转换。 浮点数科学计数法： 123var num = 5e+3;var num1 = 5e-2;//如何表示0.003和20000？ 浮点数的精度问题： 120.1 + 0.2 = ?0.07 * 100 = ? 浮点数在运算的时候会出现精度丢失的问题，因此在做比较运算的时候，尽量不要用小数进行比较。 数值范围 javascript不能表示世界上所有的数，因此在javascript中，数值大小是有一定限制的。 1234Number.MIN_VALUE :5e-324Number.MAX_VALUE :1.7976931348623157e+308Infinity :正无穷-Infinity ：负无穷 数值判断1231. NaN:表示一个非数值，当无法运算或者运算错误的时候，会得到一个NaN，NaN是number类型，表示一个非数值。2. NaN不等于NaN3. isNaN用来判断是否是一个数字，当返回true的时候，表示不是一个数字，返回false表示是一个数字。 【案例：计算用户的工资.html】 String类型字面量字符串的字面量：“abc” 、 ‘abc’ 字符串可以是双引号，也可以是单引号引起来。 123思考：如何打印以下字符串。我是一个\"正直\"的人 我很喜欢\"传'智'播客\" 字符串长度length属性用来获取字符串的长度 12var str = \"abckjdlkfjd\";str.length;//字符串的长度 字符串拼接拼接字符串使用+号 12345//思考：console.log(11 + 11);console.log(\"hello\" + \" world\");console.log(\"100\" + \"100\");console.log(\"11\" + 11); 两边只要有一个是字符串，那么+就是字符串拼接功能 两边如果都是数字，那么就是算术功能。 boolean类型boolean类型只有两个字面量，true和false，区分大小写。 所有类型的值都可以转化成true或者false 1NaN、\"\"、undefined、null、false、0 这6个值可以转换成false，其余的都是true。 undefined类型与null类型123456undefined表示一个声明了没有赋值的变量null表示一个空的对象。undefined派生自null。undefined == null -->trueundefined === null -->false 类型转换如何使用谷歌浏览器，快速的查看数据类型？ 字符串的颜色是黑色的，数值类型是蓝色的，布尔类型也是蓝色的，undefined和null是灰色的，这个在调试过程中时非常有用的。 转换成字符串类型 toString() String() 在数据的最后面加上空字符串(value+””) 转换成数值类型 Number() parseInt parseFloat +num, -0等运算 转换成布尔类型 Boolean !! 运算符赋值运算符123var a = 23;var b = a;a += 10; 算数运算符12345var a = 1; console.log(a + 1);var a = 1; console.log(a - 1);var a = 1; console.log(a * 1);var a = 1; console.log(a / 1);var a = 10; console.log(a % 2); 一元运算符12345思考：var a = 1; var b = ++a + ++a; console.log(b); var a = 1; var b = a++ + ++a; console.log(b); var a = 1; var b = a++ + a++; console.log(b); var a = 1; var b = ++a + a++; console.log(b); 逻辑运算符12345678910111213&&:只要有一个值为假，结果就是假。找假值||:只要有一个值为真，结果就是真。找真值!:取反思考：true && true;false || false;null && undefinednull || undefined“abc” && undefined“abc” || undefinednull || false || 0 || 1 || null“abc” && “bcd” && “def” 运算符的优先级1234561. () 优先级最高2. 一元运算符 ++ -- !3. 算数运算符 先* / % 后 + -4. 关系运算符 > >= < = 6) || (\"人\" != \"狗\")) && !(((12 * 2) == 144) && true) //练习4var num = 10;if(5 == num / 2 && (2 + 2 * num).toString() === \"22\") { console.log(true);}","categories":[{"name":"web前端","slug":"web前端","permalink":"https://guoweiyanggithub.github.io/categories/web前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://guoweiyanggithub.github.io/tags/javascript/"},{"name":"了解js","slug":"了解js","permalink":"https://guoweiyanggithub.github.io/tags/了解js/"}]}]}