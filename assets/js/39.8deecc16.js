(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{640:function(t,v,_){"use strict";_.r(v);var a=_(7),s=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"计算机网络"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#计算机网络"}},[t._v("#")]),t._v(" 计算机网络")]),t._v(" "),_("h2",{attrs:{id:"常用code码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常用code码"}},[t._v("#")]),t._v(" 常用code码")]),t._v(" "),_("ul",[_("li",[t._v("200 - 请求成功")]),t._v(" "),_("li",[t._v("301 - 永久重定向")]),t._v(" "),_("li",[t._v("302 - 临时重定向")]),t._v(" "),_("li",[t._v("304 - 自从上次请求后，请求网页未修改- 过，服务器返回响应，不返回内容（从缓存中读取）")]),t._v(" "),_("li",[t._v("400 - 服务器不理解请求的语法")]),t._v(" "),_("li",[t._v("403 - Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求")]),t._v(" "),_("li",[t._v("404 - 请求的资源（网页等）不存在")]),t._v(" "),_("li",[t._v("413 - 请求体过大，超出服务器的处理能力上限")]),t._v(" "),_("li",[t._v("414 - 请求url太长，服务器无法处理")]),t._v(" "),_("li",[t._v("500 - 内部服务器错误")]),t._v(" "),_("li",[t._v("502 - Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应")])]),t._v(" "),_("h2",{attrs:{id:"浏览器缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存"}},[t._v("#")]),t._v(" 浏览器缓存")]),t._v(" "),_("h3",{attrs:{id:"浏览器缓存的意义"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存的意义"}},[t._v("#")]),t._v(" 浏览器缓存的意义")]),t._v(" "),_("ul",[_("li",[t._v("避免了冗余的数据传输，节省流量")]),t._v(" "),_("li",[t._v("加快了用户访问速度")]),t._v(" "),_("li",[t._v("减小了服务器的压力")])]),t._v(" "),_("h3",{attrs:{id:"浏览器缓存策略"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存策略"}},[t._v("#")]),t._v(" 浏览器缓存策略")]),t._v(" "),_("ul",[_("li",[t._v("第一次请求数据时，浏览器没有对应的缓存数据，此时需要请求服务器，服务器返回数据后，会把请求数据缓存。")]),t._v(" "),_("li",[t._v("当浏览器有缓存数据后，可以根据是否向服务器发送请求，将缓存类型分为： 协商缓存与强缓存")])]),t._v(" "),_("h4",{attrs:{id:"强缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[t._v("#")]),t._v(" 强缓存")]),t._v(" "),_("ul",[_("li",[t._v("命中缓存后，不会向服务器发送请求,直接从本地获取。返回的状态码为 200(from disk cache) 或 200（from memory cache）")])]),t._v(" "),_("h4",{attrs:{id:"协商缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[t._v("#")]),t._v(" 协商缓存")]),t._v(" "),_("ul",[_("li",[t._v("缓存过期，浏览器会向服务器发送请求，协商对比服务端和本地的资源，验证本地资源是否失效。若服务器资源与本地资源相同，则命中缓存，返回304，否则直接请求服务器资源。")]),t._v(" "),_("li",[t._v("协商缓存的响应结果，不仅验证资源的有效性，同时还会更新浏览器缓存")]),t._v(" "),_("li",[t._v("Age:0 表示命中了代理服务器的缓存, age 值为 0 表示代理服务器刚刚刷新了一次缓存.")])]),t._v(" "),_("h4",{attrs:{id:"强缓存与协商缓存的关系"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#强缓存与协商缓存的关系"}},[t._v("#")]),t._v(" 强缓存与协商缓存的关系")]),t._v(" "),_("ul",[_("li",[t._v("相同点： 强缓存与协商缓存在命中缓存资源后都是从本地读取资源。")]),t._v(" "),_("li",[t._v("不同点：\n"),_("ul",[_("li",[t._v("如果强缓存生效，不需要再向服务端发起请求。")]),t._v(" "),_("li",[t._v("协商缓存，不管是否使用缓存，必须向服务器发送一个请求来协商。")])])])]),t._v(" "),_("h4",{attrs:{id:"优先级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#优先级"}},[t._v("#")]),t._v(" 优先级")]),t._v(" "),_("ul",[_("li",[t._v("两类缓存规则同时存在的情况下， "),_("code",[t._v("强缓存 > 协商缓存")])]),t._v(" "),_("li",[t._v("当执行强缓存的规则时，如果缓存生效，直接使用缓存，不再执行协商缓存规则。如果强制缓存规则不生效，则需要进行协商缓存判断")])]),t._v(" "),_("h4",{attrs:{id:"总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),_("ul",[_("li",[t._v("浏览器第一次请求数据时，浏览器缓存中没有对应的缓存数据，此时需要请求服务器，浏览器返回数据后，会把请求数据缓存。")]),t._v(" "),_("li",[t._v("浏览器再次访问同一url，则会根据请求资源是否过期向服务器发送不同请求，此时分为强缓存和协商缓存。")]),t._v(" "),_("li",[t._v("若资源未过期（expires和cache-control）时，命中缓存，不会向服务器发送请求，直接从缓存中读取。")]),t._v(" "),_("li",[t._v("若资源显示过期（if-modified-since/Last-Modified）和（if-none-match/Etag），则会向服务器发送请求，协商对比服务器资源，验证是否失效。若相同，命中协商缓存，返回304，否则直接请求服务器。")])]),t._v(" "),_("h4",{attrs:{id:"清除浏览器缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#清除浏览器缓存"}},[t._v("#")]),t._v(" 清除浏览器缓存")]),t._v(" "),_("ul",[_("li",[t._v("meta标签中令"),_("code",[t._v("cache-control")]),t._v("为"),_("code",[t._v("no-cache")]),t._v("或者"),_("code",[t._v("expires")]),t._v("为"),_("code",[t._v("0")])])]),t._v(" "),_("div",{staticClass:"language-js line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-js"}},[_("code",[_("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//不缓存")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("meta http"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("equiv"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),_("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Cache-Control"')]),t._v(" content"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),_("span",{pre:!0,attrs:{class:"token string"}},[t._v('"no-cache, must-revalidate"')]),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("meta http"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("equiv"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),_("span",{pre:!0,attrs:{class:"token string"}},[t._v('"expires"')]),t._v(" content"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),_("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0"')]),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])]),t._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[t._v("1")]),_("br"),_("span",{staticClass:"line-number"},[t._v("2")]),_("br"),_("span",{staticClass:"line-number"},[t._v("3")]),_("br")])]),_("h3",{attrs:{id:"哪些不能被浏览器缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#哪些不能被浏览器缓存"}},[t._v("#")]),t._v(" 哪些不能被浏览器缓存")]),t._v(" "),_("ol",[_("li",[t._v("http头中cache-control为no-cache或者为max-age: 0")]),t._v(" "),_("li",[t._v("需要根据cookie，和输入内容的动态请求")]),t._v(" "),_("li",[t._v("经过https加密的请求")]),t._v(" "),_("li",[t._v("post请求不可以被缓存")]),t._v(" "),_("li",[t._v("http响应头中不含Last-Modified/Etag，也不包含Cache-Control/Expires的请求无法被缓存")])]),t._v(" "),_("h2",{attrs:{id:"浏览器原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器原理"}},[t._v("#")]),t._v(" 浏览器原理")]),t._v(" "),_("h3",{attrs:{id:"在浏览器中输入一个网址到页面展示-会经历什么-重要"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#在浏览器中输入一个网址到页面展示-会经历什么-重要"}},[t._v("#")]),t._v(" 在浏览器中输入一个网址到页面展示，会经历什么？（重要）")]),t._v(" "),_("p",[_("a",{attrs:{href:"https://www.zhihu.com/question/440812545/answer/2379426038",target:"_blank",rel:"noopener noreferrer"}},[t._v("传送门"),_("OutboundLink")],1)]),t._v(" "),_("ol",[_("li",[t._v("浏览器输入url")]),t._v(" "),_("li",[t._v("查找缓存： 浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有，则显示该页面，没有则进行下一步.")]),t._v(" "),_("li",[t._v("DNS域名解析： 浏览器向dns服务器发送请求，解析该URL域名中对应的ip地址。（dns服务器是基于UDP的，因此会用到UDP协议）")]),t._v(" "),_("li",[t._v("建立TCP连接：解析出IP地址后，根据IP地址和默认的端口，和服务器建立TCP连接。")]),t._v(" "),_("li",[t._v("发起http请求： 浏览器发起读取文件的http请求，改请求作为TCP三次握手的第三次数据发送给服务器")]),t._v(" "),_("li",[t._v("服务器响应并返回结果： 服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器")]),t._v(" "),_("li",[t._v("关闭TCP连接： 通过四次挥手释放TCP连接")]),t._v(" "),_("li",[t._v("浏览器渲染： 客户端解析html内容并渲染出来\n"),_("ol",[_("li",[t._v("构建dom树：词法分析然后解析成dom树（dom tree），是由dom元素及属性节点组成，树的跟是document对象")]),t._v(" "),_("li",[t._v("构建css规则树： 生成css规则树（CSS Rule Tree）")]),t._v(" "),_("li",[t._v("构建render树： 浏览器将dom和CSSOM结合，并构建出渲染树（render Tree）")]),t._v(" "),_("li",[t._v("布局（Layout）：计算出每个节点在屏幕中的位置")]),t._v(" "),_("li",[t._v("GPU绘制（Painting）：遍历render树，并使用UI后端层绘制每个节点")])])])]),t._v(" "),_("h3",{attrs:{id:"tcp的三次握手和四次挥手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp的三次握手和四次挥手"}},[t._v("#")]),t._v(" TCP的三次握手和四次挥手")]),t._v(" "),_("h4",{attrs:{id:"三次握手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三次握手"}},[t._v("#")]),t._v(" 三次握手")]),t._v(" "),_("ul",[_("li",[t._v("客户端向服务端发送syn请求包，询问服务端能不能收到请求")]),t._v(" "),_("li",[t._v("服务端接收后向客户端发送ack确认包，告诉客户端能收到")]),t._v(" "),_("li",[t._v("客户端向服务端发送ack确认包，告诉服务端我也能收到，然后客户端进入准备状态，服务器接收后也进入准备状态。")])]),t._v(" "),_("h4",{attrs:{id:"四次挥手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手"}},[t._v("#")]),t._v(" 四次挥手")]),t._v(" "),_("ul",[_("li",[t._v("客户端向服务端发送fin请求包，告诉服务端要断开连接")]),t._v(" "),_("li",[t._v("服务端收到后发送ack确认包告诉客户端收到了断开请求")]),t._v(" "),_("li",[t._v("服务端有未传完的数据会继续传完，然后向客户端发送fin请求包，告诉客户端可以断开连接了")]),t._v(" "),_("li",[t._v("客户端收到后向服务端发送ack确认包，然后客户单断开连接，服务端收到后也断开连接")])]),t._v(" "),_("h3",{attrs:{id:"浏览器的重绘、重排-回流"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的重绘、重排-回流"}},[t._v("#")]),t._v(" 浏览器的重绘、重排/回流")]),t._v(" "),_("ul",[_("li",[t._v("重排/回流（Reflow）: 当dom变化影响元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为：重新生成布局，重新排列元素。")]),t._v(" "),_("li",[t._v("重绘(Repaint): 当一个元素外观发生改变，但没有改变布局，重新把元素外观绘制出来的过程，叫重绘。表现为某些元素的外观被改变")])]),t._v(" "),_("h4",{attrs:{id:"如何触发重排和重绘"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何触发重排和重绘"}},[t._v("#")]),t._v(" 如何触发重排和重绘？")]),t._v(" "),_("ul",[_("li",[t._v("重排\n"),_("ul",[_("li",[t._v("触发条件:\n"),_("ul",[_("li",[t._v("增.删.改.移 DOM")]),t._v(" "),_("li",[t._v("修改 CSS 样式")]),t._v(" "),_("li",[t._v("改变浏览器窗口的大小")]),t._v(" "),_("li",[t._v("页面滚动")]),t._v(" "),_("li",[t._v("修改网页的默认字体")]),t._v(" "),_("li",[t._v("获取一些 style 信息时 ,offsetWidth, offsetHeight, ...")])])])])]),t._v(" "),_("li",[t._v("重绘\n"),_("ul",[_("li",[t._v("触发条件:\n"),_("ul",[_("li",[t._v("DOM 改动")]),t._v(" "),_("li",[t._v("CSS 某些改动样式的改动,比如 颜色")])])])])])]),t._v(" "),_("h4",{attrs:{id:"如何避免重排重绘"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何避免重排重绘"}},[t._v("#")]),t._v(" 如何避免重排重绘？")]),t._v(" "),_("ul",[_("li",[_("code",[t._v("集中改变样式")]),t._v("，不要一条一条地修改 DOM 的样式")]),t._v(" "),_("li",[_("code",[t._v("不要把 DOM 节点的属性值放在循环里当成循环里的变量")]),t._v("。")]),t._v(" "),_("li",[_("code",[t._v("动画元素使用定位")]),t._v("，那么修改他们的CSS时是不会重排的。")]),t._v(" "),_("li",[_("code",[t._v("不使用 table 布局")]),t._v("。")]),t._v(" "),_("li",[_("code",[t._v("尽量只修改定位元素")]),t._v("。例如"),_("code",[t._v("position：absolute")]),t._v("或fixed元素，对其他元素影响不大")]),t._v(" "),_("li",[t._v("动画"),_("code",[t._v("开启GPU加速")]),t._v("，translate使用3D变化")])]),t._v(" "),_("h2",{attrs:{id:"osi七层模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#osi七层模型"}},[t._v("#")]),t._v(" OSI七层模型")]),t._v(" "),_("ul",[_("li",[t._v("（1）应用层 （"),_("strong",[t._v("为计算机用户提供应用接口或网络服务")]),t._v("。网络协议： HTTP,HTTPS,FTP,POP3,SMTP）")]),t._v(" "),_("li",[t._v("（2）表示层 （提供应用层数据的加密"),_("strong",[t._v("例如base64、ase加密")]),t._v("）")]),t._v(" "),_("li",[t._v("（3）会话层 （负责"),_("strong",[t._v("建立、管理、终止表示层之间的通信")]),t._v("）")]),t._v(" "),_("li",[t._v("（4）传输层 （为上层协议"),_("strong",[t._v("提供端到端的数据传输服务")]),t._v("）")]),t._v(" "),_("li",[t._v("（5）网络层 （通过IP寻址"),_("strong",[t._v("建立两个节点之间的连接")]),t._v("）")]),t._v(" "),_("li",[t._v("（6）数据链路层 （将比特组合成字节，再将字节组合成帧，使用链路层地址访问介质，并进行差错检测。）")]),t._v(" "),_("li",[t._v("（7）物理层 （最终信号的传输。通过物理介质传输比特流"),_("strong",[t._v("网线、中继器")]),t._v("）")])]),t._v(" "),_("h3",{attrs:{id:"https的加密是在iso七层模型中的哪一层"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#https的加密是在iso七层模型中的哪一层"}},[t._v("#")]),t._v(" https的加密是在ISO七层模型中的哪一层？")]),t._v(" "),_("ul",[_("li",[t._v("https的加密在OSI 七层模型中的"),_("code",[t._v("表示层")]),t._v("。")])]),t._v(" "),_("h2",{attrs:{id:"http、http2、https"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http、http2、https"}},[t._v("#")]),t._v(" http、http2、https")]),t._v(" "),_("h3",{attrs:{id:"http-报文的组成部分"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-报文的组成部分"}},[t._v("#")]),t._v(" HTTP 报文的组成部分")]),t._v(" "),_("ul",[_("li",[t._v("请求报文: 请求行 请求头 空行 请求体")]),t._v(" "),_("li",[t._v("响应报文: 状态行 响应头 空行 响应体\n"),_("ul",[_("li",[t._v("请求头: HTTP 方法,页面地址,http 协议及版本")]),t._v(" "),_("li",[t._v("请求头: key-value 值,告诉服务端需要的内容")]),t._v(" "),_("li",[t._v("空行: 告知服务端一下内容为请求体")]),t._v(" "),_("li",[t._v("请求体: 数据部分")])])])]),t._v(" "),_("h3",{attrs:{id:"https"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#https"}},[t._v("#")]),t._v(" https")]),t._v(" "),_("ul",[_("li",[t._v("https是通过tls对数据进行了加密，使用了对称加密(AES)和非对称加密(RSA)")])]),t._v(" "),_("h3",{attrs:{id:"http2和http的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http2和http的区别"}},[t._v("#")]),t._v(" http2和http的区别")]),t._v(" "),_("ul",[_("li",[t._v("http1同时只能请求6个连接，而http2实现了多路复用，可以复用一个tcp连接。")]),t._v(" "),_("li",[t._v("http1通过文本方式传输数据，http2通过二进制传输。")]),t._v(" "),_("li",[t._v("https2对header进行了压缩。")]),t._v(" "),_("li",[t._v("http2可以由服务端push推送。")])]),t._v(" "),_("h3",{attrs:{id:"https和http的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#https和http的区别"}},[t._v("#")]),t._v(" https和http的区别")]),t._v(" "),_("ul",[_("li",[t._v("安全方面：http使用的是"),_("code",[t._v("无状态和明文传输")]),t._v("。而https实际上是"),_("code",[t._v("http+ssl协议组成的加密传输协议")])]),t._v(" "),_("li",[t._v("响应速度： 理论上http响应速度更快，只需要三次握手；而https则在三次握手的情况下，还需要一次ssl握手")]),t._v(" "),_("li",[t._v("端口： http默认是"),_("code",[t._v("80")]),t._v("端口，而https默认端口是"),_("code",[t._v("443")])]),t._v(" "),_("li",[t._v("消耗资源方面：https是构建在ssl之上的协议，所以https会消耗更多的服务资源。")]),t._v(" "),_("li",[t._v("展示方面： https会在浏览器上面加上一个绿色的锁。")])]),t._v(" "),_("h2",{attrs:{id:"udp和tcp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#udp和tcp"}},[t._v("#")]),t._v(" UDP和TCP")]),t._v(" "),_("blockquote",[_("p",[t._v("与TCP相比，UDP更轻便，不需要经历建立连接和断开连接的阶段，适合直播。")])]),t._v(" "),_("ul",[_("li",[_("p",[t._v("TCP三次握手：")]),t._v(" "),_("ul",[_("li",[t._v("客户端向服务端发送syn请求包，询问服务端能不能收到请求")]),t._v(" "),_("li",[t._v("服务端接收后向客户端发送ack确认包，告诉客户端能收到")]),t._v(" "),_("li",[t._v("客户端向服务端发送ack确认包，告诉服务端我也能收到，然后客户端进入准备状态，服务器接收后也进入准备状态。")])])]),t._v(" "),_("li",[_("p",[t._v("TCP四次挥手：")]),t._v(" "),_("ul",[_("li",[t._v("客户端向服务端发送fin请求包，告诉服务端要断开连接")]),t._v(" "),_("li",[t._v("服务端收到后发送ack确认包告诉客户端收到了断开请求")]),t._v(" "),_("li",[t._v("服务端有未传完的数据会继续传完，然后向客户端发送fin请求包，告诉客户端可以断开连接了")]),t._v(" "),_("li",[t._v("客户端收到后向服务端发送ack确认包，然后客户单断开连接，服务端收到后也断开连接")])])])]),t._v(" "),_("h2",{attrs:{id:"前后端的通信有哪些"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前后端的通信有哪些"}},[t._v("#")]),t._v(" 前后端的通信有哪些")]),t._v(" "),_("ul",[_("li",[t._v("ajax: 同源下的通信")]),t._v(" "),_("li",[t._v("WebSocket: 不受同源策略限制")]),t._v(" "),_("li",[t._v("CORS: 支持跨域通信,也支持同源通信")])]),t._v(" "),_("h2",{attrs:{id:"跨域的解决方案有哪些-协议-域名-端口"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#跨域的解决方案有哪些-协议-域名-端口"}},[t._v("#")]),t._v(" 跨域的解决方案有哪些(协议，域名，端口)")]),t._v(" "),_("ul",[_("li",[t._v("1.jsonp 跨域")]),t._v(" "),_("li",[t._v("2.location.hash 跨域")]),t._v(" "),_("li",[t._v("3.postMessage 跨域")]),t._v(" "),_("li",[t._v("4.WebSocket 跨域")]),t._v(" "),_("li",[t._v("5.CORS 跨域(后台设置响应头)")]),t._v(" "),_("li",[t._v("6.反向代理(在 vue 中经常用到)")]),t._v(" "),_("li",[t._v("nginx 代理")])]),t._v(" "),_("h2",{attrs:{id:"垃圾回收机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收机制"}},[t._v("#")]),t._v(" 垃圾回收机制")]),t._v(" "),_("ul",[_("li",[_("p",[_("code",[t._v("标记清除法清除")]),t._v("(现代浏览器都使用的是标记清除法)")]),t._v(" "),_("ul",[_("li",[t._v("此算法假定设置一个叫做根(root)的对象, 在(js 中,根是全局对象 window),定期的让垃圾回收器从根开始,找到所有从根开始引用的对象, 然后找到这些对象的引用对象, 从根开始,垃圾回收器将找到所有可以获得的对象和所有不能获得的对象")])])])])])}),[],!1,null,null,null);v.default=s.exports}}]);